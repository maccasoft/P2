{
    COMPUKIT UK101 Emulator
    Copyright (c) 2022-23 by Marco Maccaferri <macca@maccasoft.com>
}

CON

    _CLKFREQ = 160_000_000

    VGA_PIN  = 48

    PS2_DATA_PIN  = 47
    PS2_CLOCK_PIN = 46

    USB_BASE_PIN  = 40

    ACTIVITY_LED  = 57
    ERROR_LED     = 56

    ACIA_RX_PIN   = 63  { I }                 ' programming / debug
    ACIA_TX_PIN   = 62  { O }
    ACIA_BAUD     = 300

DAT             ' Startup
                org     $000

startup
                asmclk
                drvl    #ACTIVITY_LED
                drvl    #ERROR_LED

                coginit #3, ##@video_driver ' start video driver on cog #3
                coginit #2, ##@ps2_driver   ' start PS/2 driver on cog #2
                coginit #1, ##@usb_host_start ' start USB driver on cog #1
                coginit #0, ##@cog_6502     ' start 6502 on cog #0 (this)

                orgh

'
'
' Shared memory locations
'
uk101_keyboard  byte    %11111110   ' R0 %000
                byte    %11111111   ' R1 %001
                byte    %11111111   ' R2 %010
                byte    %11111111   ' R3 %011
                byte    %11111111   ' R4 %100
                byte    %11111111   ' R5 %101
                byte    %11111111   ' R6 %110
                byte    %11111111   ' R7 %111

DAT             ' PS/2 keyboard driver
                org     $000

ps2_driver
                fltl    #PS2_DATA_PIN
                fltl    #PS2_CLOCK_PIN

                mov     ps2_data, #$F3      ' auto-repeat
                call    #ps2_transmit
                and     ps2_data, #%011_11111 ' slow 1s / 2cps
                call    #ps2_transmit

                mov     ps2_state, #%0_000  ' turn off all leds
                jmp     #ps2_locks

ps2_reset
                wrlong  ##$FF_FF_FF_FE, #@uk101_keyboard
                wrlong  ##$FF_FF_FF_FF, #@uk101_keyboard+4

ps2_loop        and     ps2_state, #$07     ' keep locks state

.l1             testp   #PS2_DATA_PIN   wz  ' wait initial clock low
        if_x1   jmp     #$-1

                call    #ps2_rx
                getbyte ps2_code, ps2_data, #0

                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #.l1

                cmp     ps2_data, #$E0  wz
        if_z    bith    ps2_state, #28
        if_z    jmp     #ps2_ext0
                cmp     ps2_data, #$E1  wz
        if_z    bith    ps2_state, #29
        if_z    jmp     #ps2_ext1

ps2_ext_ret     testbn  ps2_state, #29  wz
        if_nz   jmp     #ps2_loop           ' E1 codes are ignored

                testb   ps2_state, #7   wc  ' release

                cmp     ps2_code, #$14  wz  ' left control
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_CTRLF

                cmp     ps2_code, #$14  wz  ' right control
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_CTRLF

                cmp     ps2_code, #$12  wz  ' left shift
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_SHIFTF
                cmp     ps2_data, #$59  wz  ' right shift
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_SHIFTF

                cmp     ps2_code, #$11  wz  ' left alt
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_ALTF

                cmp     ps2_code, #$11  wz  ' right alt
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_ALTF

                cmp     ps2_code, #$1F  wz  ' left gui
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_GUIF
                cmp     ps2_code, #$27  wz  ' right gui
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_GUIF

                cmp     ps2_code, #$77  wz  ' num. lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #0       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds
                cmp     ps2_code, #$58  wz  ' caps lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #1       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds
                cmp     ps2_code, #$7E  wz  ' scroll lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #2       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds

                test    ps2_shift, #LEFT_GUIF  wz ' check reset key combination
        if_nz   test    ps2_shift, #RIGHT_GUIF wz ' |
        if_nz   andn    ps2_shift, #LEFT_GUIF|RIGHT_GUIF
        if_nz   coginit #0, ##@cog_6502         ' re-start 6502 on cog #0 (this)
        if_nz   jmp     #ps2_loop

                testb   ps2_state, #28  wc      ' extended code
                rcl     ps2_code, #1            '   to bit 0
                shl     ps2_code, #1            '   to word offset

                mov     ps2_key, ##@ps2_table
                add     ps2_key, ps2_code
                rdword  ps2_key, ps2_key    wz
        if_z    jmp     #ps2_loop

                testb   ps2_state, #7   wc      ' release

                getnib  ps2_data, ps2_key, #2
                mov     ptra, #@uk101_keyboard
                add     ptra, ps2_data
                rdbyte  ps2_temp, ptra
                muxc    ps2_temp, ps2_key
                wrbyte  ps2_temp, ptra
                jmp     #ps2_loop

ps2_caps        rdbyte  ps2_temp, #@uk101_keyboard
                bitnot  ps2_temp, #0    wcz
                wrbyte  ps2_temp, #@uk101_keyboard
                bitc    ps2_state, #1
                ' fall-through

ps2_locks       mov     ps2_data, #$ED
                call    #ps2_transmit
                mov     ps2_data, #0
                testb   ps2_state, #0   wz  ' num. lock
                bitz    ps2_data, #1
                testb   ps2_state, #1   wz  ' caps lock
                bitz    ps2_data, #2
                testb   ps2_state, #2   wz  ' scroll lock
                bitz    ps2_data, #0
                call    #ps2_transmit
                jmp     #ps2_loop

ps2_ext1        call    #ps2_receive
                setbyte ps2_code, ps2_data, #1
                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #ps2_ext1

                ' fall through

ps2_ext0        call    #ps2_receive
                setbyte ps2_code, ps2_data, #0
                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #ps2_ext0

                jmp     #ps2_ext_ret

ps2_transmit    drvl    #PS2_CLOCK_PIN      ' pull clock low
                getct   ps2_tout            ' hold clock for 128us (must be > 100us)
                addct1  ps2_tout, ps2_us128 ' |
                jnct1   #$
                drvl    #PS2_DATA_PIN       ' pull data low
                getct   ps2_tout            ' hold data for 4us
                addct1  ps2_tout, ps2_us4   ' |
                jnct1   #$

                fltl    #PS2_CLOCK_PIN      ' release clock
                getct   ps2_tout            ' allow pin to float
                addct1  ps2_tout, ps2_us1   ' |
                jnct1   #$

                test    ps2_data, #$FF  wc  ' append parity
                muxnc   ps2_data, #$100     ' |
                bith    ps2_data, #9        ' append stop bit

                getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ps2_us6000

                mov     ps2_bits, #10
.l1             testp   #PS2_CLOCK_PIN  wz  ' wait until clock low
        if_x1   jct1    #ps2_reset          ' | check timeout
        if_x1   jmp     #.l1                ' |
                shr     ps2_data, #1    wc  ' output data bit
                drvc    #PS2_DATA_PIN       ' |
.l2             testp   #PS2_CLOCK_PIN  wz  ' wait until clock high
        if_x0   jct1    #ps2_reset          ' | check timeout
        if_x0   jmp     #.l2                ' |
                djnz    ps2_bits, #.l1      ' another bit ?

                fltl    #PS2_DATA_PIN

.l3             testp   #PS2_CLOCK_PIN  wc  ' wait until clock and data low
                testp   #PS2_DATA_PIN   wz  ' |
    if_not_00   jct1    #ps2_reset          ' | check timeout
    if_not_00   jmp     #.l3                ' |

.l4             testp   #PS2_CLOCK_PIN  wc  ' wait until clock and data high
                testp   #PS2_DATA_PIN   wz  ' |
    if_not_11   jct1    #ps2_reset          ' | check timeout
    if_not_11   jmp     #.l4                ' |

                ' Fall through to receive ack

ps2_receive     getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ps2_us6000

.l0             testp   #PS2_DATA_PIN   wz  ' wait until data low
        if_x1   jct1    #ps2_reset          ' | check timeout
        if_x1   jmp     #.l0                ' |

ps2_rx
                getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ps2_us3000

                mov     ps2_bits, #11
.l1             testp   #PS2_CLOCK_PIN  wz  ' wait until clock low
        if_x1   jct1    #ps2_reset          ' | check timeout
        if_x1   jmp     #.l1                ' |
                testp   #PS2_DATA_PIN   wc  ' sample data
                rcr     ps2_data, #1        ' |
.l2             testp   #PS2_CLOCK_PIN  wz  ' wait until clock high
        if_x0   jct1    #ps2_reset          ' | check timeout
        if_x0   jmp     #.l2                ' |
                djnz    ps2_bits, #.l1      ' another bit?

.l3             testp   #PS2_CLOCK_PIN  wc  ' wait until clock and data high
                testp   #PS2_DATA_PIN   wz  ' |
    if_not_11   jct1    #.l4                ' | check timeout
    if_not_11   jmp     #.l3                ' |
.l4
                shr     ps2_data, #22       ' align byte
                test    ps2_data, #$1FF wc  ' test parity
        if_nc   jmp     #ps2_reset          ' |
        _ret_   and     ps2_data, #$FF      ' ok

ps2_us1         long    _CLKFREQ / 1_000_000 * 1    ' 1 usec.
ps2_us4         long    _CLKFREQ / 1_000_000 * 4    ' 4 usec.
ps2_us128       long    _CLKFREQ / 1_000_000 * 128  ' 128 usec.
ps2_us3000      long    _CLKFREQ / 1_000_000 * 3000 ' 3000 usec.
ps2_us6000      long    _CLKFREQ / 1_000_000 * 6000 ' 6000 usec.

ps2_bits        long    0
ps2_code        long    0
ps2_state       long    0
ps2_shift       long    0
ps2_key         long    0

ps2_data        long    0
ps2_tout        long    0
ps2_temp        long    0

DAT             ' PS/2 Lookup table
                orgh

'       The keyboard matrix has the following layout:
'
'               C7    C6    C5    C4    C3    C2    C1    C0
'                |     |     |     |     |     |     |     |
'              ! |   " |   # |   $ |   % |   & |   ' |     |
'              1 |   2 |   3 |   4 |   5 |   6 |   7 |     |
'       R7 ------+-----+-----+-----+-----+-----+-----+-----+
'              ( |   ) |(1)  |   * |   = | RUB |     |     |
'              8 |   9 |   0 |   : |   - | OUT |     |     |
'       R6 ------+-----+-----+-----+-----+-----+-----+-----+
'              > |   \ |     |(2)  |     |     |     |     |
'              . |   L |   O |   ^ |  CR |     |     |     |
'       R5 ------+-----+-----+-----+-----+-----+-----+-----+
'                |     |     |     |     |     |     |     |
'              W |   E |   R |   T |   Y |   U |   I |     |
'       R4 ------+-----+-----+-----+-----+-----+-----+-----+
'                |     |     |     |     |  LF |   [ |     |
'              S |   D |   F |   G |   H |   J |   K |     |
'       R3 ------+-----+-----+-----+-----+-----+-----+-----+
'                | ETX |     |     |     |   ] |   < |     |
'              X |   C |   V |   B |   N |   M |   , |     |
'       R2 ------+-----+-----+-----+-----+-----+-----+-----+
'                |     |     |     |   ? |   + |   @ |     |
'              Q |   A |   Z |space|   / |   ; |   P |     |
'       R1 ------+-----+-----+-----+-----+-----+-----+-----+
'           (3)  |     |(4)  |     |     | left|right|SHIFT|
'                | CTRL|     |     |     |SHIFT|SHIFT| LOCK|
'       R0 ------+-----+-----+-----+-----+-----+-----+-----+

'                        ROW C7....C0   ROW C7....C0

ps2_table       word                       0,                    0    '00
                word                       0,                    0    '01     F9
                word                       0,                    0    '02
                word                       0,                    0    '03     F5
                word                       0,                    0    '04     F3
                word                       0,                    0    '05     F1
                word                       0,                    0    '06     F2
                word                       0,                    0    '07     F12
                word                       0,                    0    '08
                word                       0,                    0    '09     F10
                word                       0,                    0    '0A     F8
                word                       0,                    0    '0B     F6
                word                       0,                    0    '0C     F4
                word                       0,                    0    '0D     Tab
                word                       0,                    0    '0E     `
                word                       0,                    0    '0F
                word                       0,                    0    '10
                word                       0,                    0    '11     Alt-L    Alt-R
                word    (0 << 8) | %00000100,                    0    '12     Shift-L
                word                       0,                    0    '13
                word    (0 << 8) | %01000000, (0 << 8) | %01000000    '14     Ctrl-L   Ctrl-R
                word    (1 << 8) | %10000000,                    0    '15     q
                word    (7 << 8) | %10000000,                    0    '16     1
                word                       0,                    0    '17
                word                       0,                    0    '18
                word                       0,                    0    '19
                word    (1 << 8) | %00100000,                    0    '1A     z
                word    (3 << 8) | %10000000,                    0    '1B     s
                word    (1 << 8) | %01000000,                    0    '1C     a
                word    (4 << 8) | %10000000,                    0    '1D     w
                word    (7 << 8) | %01000000,                    0    '1E     2
                word                       0,                    0    '1F              Win-L
                word                       0,                    0    '20
                word    (2 << 8) | %01000000,                    0    '21     c
                word    (2 << 8) | %10000000,                    0    '22     x
                word    (3 << 8) | %01000000,                    0    '23     d
                word    (4 << 8) | %01000000,                    0    '24     e
                word    (7 << 8) | %00010000,                    0    '25     4
                word    (7 << 8) | %00100000,                    0    '26     3
                word                       0,                    0    '27              Win-R
                word                       0,                    0    '28
                word    (1 << 8) | %00010000,                    0    '29     Space
                word    (2 << 8) | %00100000,                    0    '2A     v
                word    (3 << 8) | %00100000,                    0    '2B     f
                word    (4 << 8) | %00010000,                    0    '2C     t
                word    (4 << 8) | %00100000,                    0    '2D     r
                word    (7 << 8) | %00001000,                    0    '2E     5
                word                       0,                    0    '2F              Apps
                word                       0,                    0    '30
                word    (2 << 8) | %00001000,                    0    '31     n
                word    (2 << 8) | %00010000,                    0    '32     b
                word    (3 << 8) | %00001000,                    0    '33     h
                word    (3 << 8) | %00010000,                    0    '34     g
                word    (4 << 8) | %00001000,                    0    '35     y
                word    (7 << 8) | %00000100,                    0    '36     6
                word                       0,                    0    '37              Power
                word                       0,                    0    '38
                word                       0,                    0    '39
                word    (2 << 8) | %00000100,                    0    '3A     m
                word    (3 << 8) | %00000100,                    0    '3B     j
                word    (4 << 8) | %00000100,                    0    '3C     u
                word    (7 << 8) | %00000010,                    0    '3D     7
                word    (6 << 8) | %10000000,                    0    '3E     8
                word                       0,                    0    '3F              Sleep
                word                       0,                    0    '40
                word    (2 << 8) | %00000010,                    0    '41     ,
                word    (3 << 8) | %00000010,                    0    '42     k
                word    (4 << 8) | %00000010,                    0    '43     i
                word    (5 << 8) | %00100000,                    0    '44     o
                word    (6 << 8) | %00100000,                    0    '45     0
                word    (6 << 8) | %01000000,                    0    '46     9
                word                       0,                    0    '47
                word                       0,                    0    '48
                word    (5 << 8) | %10000000,                    0    '49     .
                word    (1 << 8) | %00001000,                    0    '4A     /        (/)
                word    (5 << 8) | %01000000,                    0    '4B     l
                word    (1 << 8) | %00000100,                    0    '4C     ;
                word    (1 << 8) | %00000010,                    0    '4D     p
                word    (6 << 8) | %00010000,                    0    '4E     -
                word                       0,                    0    '4F
                word                       0,                    0    '50
                word                       0,                    0    '51
                word                       0,                    0    '52     '
                word                       0,                    0    '53
                word    (5 << 8) | %00010000,                    0    '54     [
                word    (6 << 8) | %00001000,                    0    '55     =
                word                       0,                    0    '56
                word                       0,                    0    '57
                word                       0,                    0    '58     CapsLock
                word    (0 << 8) | %00000010,                    0    '59     Shift-R
                word    (5 << 8) | %00001000,                    0    '5A     Enter    (Enter)
                word                       0,                    0    '5B     ]
                word                       0,                    0    '5C
                word                       0,                    0    '5D     \
                word                       0,                    0    '5E              WakeUp
                word                       0,                    0    '5F
                word                       0,                    0    '60
                word                       0,                    0    '61
                word                       0,                    0    '62
                word                       0,                    0    '63
                word                       0,                    0    '64
                word                       0,                    0    '65
                word    (6 << 8) | %00000100,                    0    '66     BackSpace
                word                       0,                    0    '67
                word                       0,                    0    '68
                word                       0,                    0    '69     (1)      End
                word                       0,                    0    '6A
                word                       0,                    0    '6B     (4)      Left
                word                       0,                    0    '6C     (7)      Home
                word                       0,                    0    '6D
                word                       0,                    0    '6E
                word                       0,                    0    '6F
                word                       0,                    0    '70     (0)      Insert
                word                       0,                    0    '71     (.)      Delete
                word                       0,                    0    '72     (2)      Down
                word                       0,                    0    '73     (5)
                word                       0,                    0    '74     (6)      Right
                word                       0,                    0    '75     (8)      Up
                word                       0,                    0    '76     Esc
                word                       0,                    0    '77     NumLock
                word                       0,                    0    '78     F11
                word                       0,                    0    '79     (+)
                word                       0,                    0    '7A     (3)      PageDn
                word                       0,                    0    '7B     (-)
                word                       0,                    0    '7C     (*)      PrScr
                word                       0,                    0    '7D     (9)      PageUp
                word                       0,                    0    '7E     ScrLock
                word                       0,                    0    '7F
                word                       0,                    0    '80
                word                       0,                    0    '81
                word                       0,                    0    '82
                word                       0,                    0    '83     F7

DAT             ' USB Host driver
                org     $000

usb_host_start
                mov     hcog_base_addr, ptrb

                mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
                shr     htmp, #2                        ' so byte->long for the lut cell count
                loc     pb, #@hlut_start - @usb_host_start
                add     pb, hcog_base_addr
                setq2   htmp
                rdlong  0, pb                           ' Do the hub->lut copy

                loc     pb, #@usb_host_init - @usb_host_start
                add     pb, hcog_base_addr
                jmp     pb                              ' Initialize host and enter main processing loop

'------------------------------------------------------------------------------
' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
' special because the receiving function must not respond with either STALL or
' NAK, and must accept the DATAx packet that follows the SETUP token. If a
' non-control endpoint receives a SETUP token, or the function receives a
' corrupt packet, it must ignore the transaction
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data struct.
' On exit:
'   retval - PID_ACK on success, otherwise error code.
'------------------------------------------------------------------------------
txn_setup
                setbyte ep_addr_pid, #PID_SETUP, #0
                mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
                bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
                mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
                mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
.setup
                call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
                cmp     retval, #PID_ACK        wz
        if_z    ret
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    ret
                mov     ptra, pa                        ' Restore SETUP's DATAx pointer
                jmp     #.setup

'------------------------------------------------------------------------------
' IN/INTERRUPT transaction.
' Possible function response: STALL or NAK handshake, or DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
' On exit:
'------------------------------------------------------------------------------
txn_in
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                setbyte ep_addr_pid, #PID_IN, #0
                call    #utx_token                      ' Put IN request on the bus

                ' Fall through to urx_packet

'------------------------------------------------------------------------------
' Wait for a packet from a device/function. As host, the only two packet types
' received are handshakes and IN DATAx.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'     returned.
'------------------------------------------------------------------------------
urx_packet
                rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
                testb   urx, #SOPB              wc
        if_c    jmp     #urx_packet
                getct   hct2
                addct2  hct2, tat_wait                  ' Start the response turn-around timer
                bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
                mov     newb_flg, #0                    ' Initialize for multi-byte read
.wait_sop
                rdpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #.get_pid
                jnct2   #.wait_sop
        _ret_   mov     retval, #ERR_TAT
.get_pid
                call    #urx_next
                testb   urx, #BUS_ERRB          wc
        if_nc   jmp     #.chk_pid
        _ret_   mov     retval, #ERR_URX
.chk_pid
                cmp     retval, #PID_ACK        wz
        if_nz   cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
                testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
                cmp     retval, #PID_DATA0      wz
   if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
   if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
                cmp     retval, #PID_DATA1      wz
   if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
   if_z_and_nc  jmp     #.ack_resend
        _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
.ack_resend
                rqpin   urx, dm
                testb   urx, #EOPB              wc
        if_nc   jmp     #.ack_resend
                mov     retval, #PID_ACK
                call    #utx_handshake                  ' Send handshake PID and return to caller
        _ret_   mov     retval, #ERR_DATAX_SYNC
.chk_eop
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
                call    #urx_next                       ' Low-speed requires an additional read to get EOP status
                testb   hstatus, #EOPB          wc
        if_c    jmp     #.idle                          ' Low-speed EOP seen
                testb   urx, #BUS_ERRB          wz
        if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
        if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
                ret
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
                ret

'------------------------------------------------------------------------------
' Send a token packet with CRC5 checksum of address and endpoint. It is the
' responsibility of the caller to append the appropriate inter-packet delay,
' if one is required.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - packed with the PID, address and endpoint.
' On exit:
'------------------------------------------------------------------------------
utx_token
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #utx_token
                testb   hstatus, #DWNSTRM_HUBB  wc
        if_c    call    #utx_pre
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     htmp, ep_addr_pid               ' Preserve the PID and destination
                mov     pkt_cnt, #3
.next_byte
                getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
                shr     htmp, #8                        ' Shift to next byte to send
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   utx, dm
        _ret_   djnz    pkt_cnt, #.next_byte

'------------------------------------------------------------------------------
' SETUP/OUT/INTERRUPT transaction.
' Possible function response in order of precedence: STALL, ACK, NAK.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
'   PTRA - start address of the data buff/struct that has the bytes to send.
'   pkt_data - count of DATAx payload bytes to send.
' On exit:
'------------------------------------------------------------------------------
txn_out
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                call    #utx_token                      ' Put SETUP/OUT token on the bus
                rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
                mov     pkt_cnt, pkt_data

                ' Fall through to utx_data

'------------------------------------------------------------------------------
' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
' calculated while the data byte is being shifted out. Since data stage
' success/fail is not determined until the status stage of the transaction,
' this routine is only concerned about the current DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - hub start address of the data to read.
'   pkt_cnt - data payload size.
' On exit:
'------------------------------------------------------------------------------
utx_data
                rqpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #utx_data
                mov     hctwait, ip_delay
                call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
                testb   hstatus, #DWNSTRM_HUBB  wc
        if_c    call    #utx_pre
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                bmask   crc, #15                        ' Prime the CRC16 pump
                testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
        if_nc   mov     utx, #PID_DATA0
        if_c    mov     utx, #PID_DATA1
                call    #utx_byte                       ' No CRC calc done on PID
                cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
        if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
.read_byte
                rfbyte  utx                             ' Fetch data byte
                call    #utx_byte
                rev     utx                             ' Calculate CRC while the data is shifting out
                setq    utx                             ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
                djnz    pkt_cnt, #.read_byte
.send_crc
                bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
                getbyte utx, crc, #0
                call    #utx_byte
                getbyte utx, crc, #1
                call    #utx_byte                       ' Last CRC byte out
                jmp     #urx_packet                     ' Handle function response/error and back to caller

'------------------------------------------------------------------------------
' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
' payload bytes are received. The routine reads bytes until EOP is detected and
' expects that the packet includes at least the CRC word.
'
' In control transfers, it's possible to recieve fewer data bytes than what
' was requested, which makes it difficult to determine where the data stops
' and the CRC word begins. So the CRC calculation is done on every byte of the
' packet, including the CRC word. The CRC value should then be equal to the
' USB-16 expected residual value of 0xB001.
'
' The routine writes the IN packet data to a static max_packet_size buffer
' so the caller can verify IN success before writing the data to its final
' destination.
'------------------------------------------------------------------------------
' On entry:
'   pkt_data - max byte count expected to be in the packet.
'   newb_flg - signals new byte ready when toggled.
' On exit:
'   pkt_cnt - actual number of bytes read.
'------------------------------------------------------------------------------
urx_data
                mov     htmp2, pb
                mov     pb, urx_buff_p
                wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
                mov     pb, htmp2
                bmask   crc, #15                        ' Prime the CRC16 pump
                mov     pkt_cnt, #0                     ' Keep track of payload bytes received
                mov     pkt_tmp, pkt_data
                add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
.wait_byte
' In-line rx for max speed
                rqpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   jmp     #.get_byte                      ' New byte!
                testb   urx, #EOPB              wc
        if_c    jmp     #.chk_crc                       ' At end-of-packet
                jmp     #.wait_byte
.get_byte
                getbyte retval, urx, #1                 ' New byte from smart pins
                wfbyte  retval                          ' Add it to the data buffer
                rev     retval                          ' Calculate CRC while next byte is shifting in
                setq    retval                          ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
.end_crc
                add     pkt_cnt, #1
                cmp     pkt_cnt, pkt_tmp        wcz
        if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
        if_a    ret
' For full-speed at 80MHz, the time it takes to do the final byte write and
' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
' to miss it, so cheat a bit and look for SOP clear here.
                rqpin   urx, dm
                testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
        if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
.chk_crc
                sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
                xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
        if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
                mov     retval, #PID_ACK
                mov     hctwait, ip_delay
                call    #poll_waitx

                ' Fall through to utx_handshake

'------------------------------------------------------------------------------
' Transmit a handshake PID. The routine assumes that the bus is IDLE and
' the appropriate IP delay has been inserted.
'------------------------------------------------------------------------------
' On entry:
'   retval - handshake PID to send.
' On exit:
'   retval unchanged.
'------------------------------------------------------------------------------
utx_handshake
                testb   hstatus, #DWNSTRM_HUBB  wc
        if_c    call    #utx_pre
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                mov     utx, retval
                call    #utx_byte                       ' Send handshake PID
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
                mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
                jmp     #poll_waitx

'------------------------------------------------------------------------------
' Wait for the USB tx buffer to empty and feed it a new byte.
'------------------------------------------------------------------------------
' On entry:
'   utx - byte to transmit.
' On exit:
'------------------------------------------------------------------------------
utx_byte
                testp   dp                      wc
        if_nc   jmp     #utx_byte
                akpin   dp
                waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
        _ret_   wypin   utx, dm

'------------------------------------------------------------------------------
' Fetch the next data byte of a packet. Always check receiver status for EOP.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the byte read.
'   urx - the receiver status. The caller must check the hstatus reg EOP flag
'     on return. If EOP is set, the byte in reg retval remains as the last byte
'     received.
'------------------------------------------------------------------------------
urx_next
                rdpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
        if_nz   ret                                     ' New byte is priority, so return now
                testb   urx, #SOPB              wc
                testb   urx, #BUS_ERRB          wz
   if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
        if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
                ret

'------------------------------------------------------------------------------
' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
' the data used for the USB-5 CRC lookups. The token packet is three bytes in
' length, and the PID is not included in the CRC calculation:
'  CRC5  FRAME_NUMBER SOF (full-speed)
'  CRC5  ENDP ADDRESS PID
' %00000_1111_1111111_xxxxxxxx
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - stuffed with the function endpoint, address and
'     SETUP/IN/OUT/SOF PID according to the USB standard.
' On exit:
'   ep_addr_pid - CRC value appended to the packet.
'------------------------------------------------------------------------------
calc_crc5
                and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
                mov     htmp, ep_addr_pid
                shr     htmp, #8                        ' PID not included in CRC calc
                mov     crc, #$1f                       ' Initial CRC5 value
                rev     htmp                            ' Input data reflected
                setq    htmp                            ' CRCNIB setup for data bits 0..7
                crcnib  crc, #USB5_POLY
                crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
                shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
                crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                xor     crc, #$1f                       ' Final XOR value
                shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
        _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home

'------------------------------------------------------------------------------
' Full-speed/low-speed frame timing interrupt service routine.
'------------------------------------------------------------------------------
isr1_fsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                mov     utx, #PID_SOF
                wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
                call    #utx_byte                       ' Send token PID byte
                mov     icrc, #$1f                      ' Prime the CRC5 pump
                mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
                rev     sof_pkt                         ' Input data reflected
                setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
                crcnib  icrc, #USB5_POLY
                crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
                getbyte utx, frame, #0                  ' Send the low byte of the frame number
                call    #utx_byte
                shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
                rep     #2, #3                          ' Three data bits left to process
                shl     sof_pkt, #1             wc
                crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
                xor     icrc, #$1f                      ' Final XOR value
                getbyte utx, frame, #1                  ' Send remaining frame number bits
                shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
                or      utx, icrc
                call    #utx_byte                       ' Last start-of-frame byte is on the wire
                mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
                jmp     #isr1_wait
isr1_lsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
                mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
isr1_wait
                rqpin   utx, dm
                testb   utx, #SOPB                 wc
        if_c    jmp     #isr1_wait
                add     frame, #1                       ' Next frame# and check for wrap around
                zerox   frame, #10
                waitx   isrtmp1                         ' Make sure bus is idle
                reti1

'------------------------------------------------------------------------------
' Wait for a window within the 1ms frame boundary that will ensure that a
' transaction will complete before the next frame is triggered.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
wait_txn_ok
                getct   htmp2
                sub     htmp2, iframe_ct_base
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    cmp     htmp2, _txn_ok_ls_      wcz
        if_nc   cmp     htmp2, _txn_ok_fs_      wcz
        if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
                ret

'------------------------------------------------------------------------------
' A device connection was detected, or a bus reset was requested by the USB
' client. Set the appropriate smart pin FS/LS speed mode to match the device
' and perform a reset sequence prior to device enumeration.
'------------------------------------------------------------------------------
dev_reset
                rqpin   urx, dm
                testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
        if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
        if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
reset
                setint1 #0                              ' Don't want frame interrupt while in reset
                wypin   #OUT_SE0, dm                    ' Assert bus reset
                waitx   _reset_hold_                    ' Spec is >= 10ms
                wypin   #OUT_IDLE, dm
                mov     frame, #0                       ' Reset the frame timespan count
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
                add     htmp, #36
                setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
.framewait
                cmp     frame, htmp             wcz
        if_b    jmp     #.framewait
                ret

'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - source address.
'   PB - destination address.
'   hr0 - length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
hmemcpy
                rdbyte  htmp, ptra++
                wrbyte  htmp, pb
                add     pb, #1
        _ret_   djnz    hr0, #hmemcpy

'------------------------------------------------------------------------------
' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
' loop until the errant device is disconnected.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
host_error
                drvl    host_error_led
                jmp     #host_reset                     ' See if it works...

' USB commands and error codes
cmd_data        long    0
usb_err_code    long    ERR_NONE

' Parameters block assigned at cog startup
dm              long    USB_BASE_PIN + 2    ' Client defines the basepin for four consecutive USB port pins
dp              long    USB_BASE_PIN + 3
usb_event_pin   long    USB_BASE_PIN        ' Host event reporting uses a long repository smart pin
host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
hid_report_p    long    0, 0[4]
hub_descr_p     long    0
urx_buff_p      long    0
dev_desc_buff_p long    0
con_desc_buff_p long    0
cache_start_p   long    0
cache_end_p     long    0

hdev_init_start
hdev_port       long    0
hdev_next_datax long    0, 0
hub_intf_num    long    0
hub_next_datax  long    0
hub_status_chg  long    0
hub_port_status long    0
kb_intf_num     long    0
kb_interval     long    0
kb_in_max_pkt   long    0
kb_max_index    long    0
kb_led_states   long    0
hdev_init_end

' Initialized at cog startup:
save_sysclk     long    0         ' Save the current sysclock as the client may change it
hcog_base_addr  long    0         ' This object's start address in hub, read from PTRB at cog creation
iframe_ct_new   long    0
iframe_ct_base  long    0
p2rev_val       long    P2RevB
utx_tweak       long    0         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
' This register block is reset to zero when a USB device connects
hreg_init_start
hstatus         long    0         ' Host status flags
hctwait         long    0         ' Poll-based wait clocks
ip_delay        long    0         ' Inter-packet delay in bit periods for connected device speed
tat_wait        long    0         ' Maximum bus turn-around time in bit periods for connected device speed
nak_retry       long    0         ' NAK retry count, unlimited retries if zero
xfer_retry      long    0         ' Control transfer retry count
retry           long    0         ' Transaction retry count
utx             long    0         ' Byte to transmit on USB
urx             long    0         ' LSByte receiver status flags, MSByte received data
newb_flg        long    0         ' Receive "new byte" bit toggle detector
max_pkt_size    long    0         ' Maximum payload bytes allowed, likely to change on device connect.
total_data      long    0         ' Total bytes to tx/rx in a transfer data stage
stage_data      long    0         ' Count of bytes sent/received so far during a data stage.
pkt_data        long    0         ' Payload size of an OUT packet or bytes received on IN
frame           long    0         ' USB 1ms frame counter value
sof_pkt         long    0         ' ISR frame# packet and CRC5
icrc            long    0         ' Only used by the 1ms frame output ISR routine
pkt_cnt         long    0         ' Count of DATAx packet payload bytes
crc             long    0         ' Used for CRC16 calculation
ep_addr_pid     long    0         ' Endpoint and device addresses for connected device
retval          long    0         ' Global success/fail return parameter
context_retval  long    0         ' Operation contextual return parameter
' Device stuff
hdev_id         long    0
hdev_bcd        long    0
hdev_type       long    0, 0      ' Configured device indicator
' Keyboard/mouse stuff
hctrl_ep_addr   long    0
hctrl_max_pkt   long    0
hconfig_base    long    0
hcon_tot_len    long    0         ' Size of the complete config descriptor chain
hdev_intf_idx   long    0         ' Used during verbose descriptor terminal output
hdev_class      long    0
hdev_subclass   long    0
hdev_protocol   long    0
hsearch_key     long    0         ' Descriptor type to search for in the config chain
hnext_desc      long    0         ' Offset from the config descriptor start address to the next descriptor in the chain
hhub_ctrl_ep    long    0         ' Hub control endpoint address
hhub_ep_addr    long    0         ' Hub interface endpoint address
hkbd_ctrl_ep    long    0         ' Keyboard control endpoint address
hkbd_ep_addr    long    0         ' Keyboard interface endpoint address
hkbd_poll_cnt   long    0         ' Poll interval counter used for key auto-repeat
hkbd_ledstates  long    0         ' Off/on state of keyboard LEDs
hdev_ep_addr    long    0, 0[4]
hdev_out_addr   long    0
hreg_init_end
' Variables dependent on the system freqency
_var_64_lower_  res     1
_var_64_upper_  res     1
_12Mbps_        res     1
_1_5Mbps_       res     1
_1ns16fp_       res     1         ' 1ns as 32,16 fixed point
_1us_           res     1         ' 1us
_10us_          res     1         ' 10us
_33us_          res     1         ' 33us
_txn_err_       res     1         ' 250us
_500us_         res     1         ' 500us
_txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
_txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
_ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
_ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
_tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
_tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
_preamble_wait_ res     1
_1ms_           res     1         ' 1ms
_2ms_           res     1         ' 2ms
_suspend_wait_  res     1         ' 3ms
_4ms_           res     1         ' 4ms
_xfer_wait_     res     1         ' 5ms
_8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
_reset_hold_    res     1         ' 15ms
_resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
_21ms_          res     1         ' 21ms
_100ms_         res     1         ' 100ms
_500ms_         res     1         ' 500ms
_pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
_frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'------------------------------------------------------------------------------
_usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
_usb_d_ls_nco_  res     1
_usb_h_fs_nco_  res     1
_usb_d_fs_nco_  res     1
'------------------------------------------------------------------------------
' Scratch registers
htmp            res     1         ' Scratch registers whose context remains within the same code block
htmp1           res     1
htmp2           res     1
htmp3           res     1
hrep            res     1         ' Repeat count
hsave0          res     1         ' Subroutine parameter saves
hsave1          res     1
hsave2          res     1
isrtmp1         res     1
pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
hr0             res     1         ' Multi-purpose registers
hr1             res     1
hr2             res     1
hr3             res     1
hpar1           res     1         ' Routine entry/exit parameters
hpar2           res     1
hpar3           res     1
hct2            res     1         ' Function response bus turn-around timer
hct3            res     1         ' Keyboard/mouse poll timer
mod_cnt         res     1         ' Used in idle loops

                fit     $1F0

DAT             ' USB Host LUT execution
                org     $200
hlut_start

'------------------------------------------------------------------------------
' Full-speed is the host's native speed, so all that is needed is to set the FS
' settings to startup defaults.
'------------------------------------------------------------------------------
' On entry:
' On exit: Save/restore caller C flag state if C is changed in this routine!
'------------------------------------------------------------------------------
set_speed_full
                mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
'                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' When a low-speed device connects, the D-/D+ signaling is inverted. If there
' is a downstream hub connected (not yet implemented), the baud generator
' remains set at the full-speed rate, but signaling is switched to low-speed,
' which reverses the D-/D+ polarity. The polarity can be changed without
' putting the smart pins into reset.
'------------------------------------------------------------------------------
' On entry:
' On exit: CZ flags restored to caller states
'------------------------------------------------------------------------------
set_speed_low
                test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
        if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
                testb   p2rev_val, #0           wc      ' P2 Revision is either %0001 (A) or %0010 (B+)
        if_c    dirl    dm                              ' P2RevA needs to be completely reconfigured
        if_c    dirl    dp
        if_c    wrpin   ##USB_V1HMODE_LS, dm            ' Low-speed signaling is always used
        if_c    wrpin   ##USB_V1HMODE_LS, dp
        if_c    wxpin   _1_5Mbps_, dm                   ' Set 1.5Mbs baud if no downstream hub
        if_c    dirh    dm
        if_c    dirh    dp
        if_nc   wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
                bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' Perform configuration stuff required when a device intitially connects.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
on_connect
                mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
                call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
.retry
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
        if_nc   mov     hpar1, #USB_SPEED_FULL
                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.get_dev_desc
                mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
                call    #poll_waitx
                sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
        if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
                call    #reset                          ' Try another reset to see if the device responds
                jmp     #.retry
.get_dev_desc
                mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
                call    #reset
                loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
                add     ptra, hcog_base_addr
                wrword  #8, ptra[wValue]                ' Only support one device port at this time
                call    #control_write                  ' Execute SetAddress()
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctwait, _8ms_
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
                call    #calc_crc5
                loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
                add     ptra, hcog_base_addr
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
                mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
                rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
                mov     hctwait, _500us_
                call    #poll_waitx
                loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   ret
                mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
                mov     hconfig_base, ptra              ' Will need this for configuration
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    mov     retval, #ERR_CONFIG_FAIL
        if_b    jmp     #host_error
                loc     pa, #@init_kbdm_data - @usb_host_start
                add     pa, hcog_base_addr
                call    pa
                loc     pa, #@hparse_con_desc - @usb_host_start
                add     pa, hcog_base_addr
                jmp     pa

'------------------------------------------------------------------------------
' Perform a control read transaction (Section 8.5.3, Figure 8-37).
' Status reporting is always in the function-to-host direction.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data in hub.
'   PB - start address of the buffer/struct to be written to during the IN data
'     stage.
'   ep_addr_pid - device address, endpoint and CRC5.
' On exit:
'   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'     contains the count of data stage bytes actually received, which must
'     always be <= the count requested.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_read
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb                       ' Save dest buffer pointer
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                mov     nak_retry, ##IN_NAK_RETRIES
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
.nak_retry
                mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
.in_retry
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' Commit on ACK
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak_retry                     ' Function not ready to send data
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.in_retry                      ' Bus error retry
                ret                                     ' The transfer has failed
.commit
                cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
        if_z    jmp     #.pre_status                    ' and also end-of-data
                mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
                mov     hr0, pkt_cnt
                cmp     ptra, pb                wz
        if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
                add     stage_data, pkt_cnt             ' Update bytes received on commit
                cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
        if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
                cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
        if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
        if_a    mov     retval, #ERR_PACKET
        if_a    mov     context_retval, retval          ' In this case overall and context are the same
        if_a    ret                                     ' Caller must handle ERR_PACKET
                bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
                jmp     #.data                          ' Start next IN transaction
.pre_status
                mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
                setbyte ep_addr_pid, #PID_OUT, #0
                mov     pkt_data, #0
                bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
                mov     nak_retry, ##OUT_NAK_RETRIES
.out_retry
                call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
                cmp     retval, #PID_ACK        wz
        if_z    ret                                     ' All is good when ACK
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
                ret                                     ' Caller must handle transfer retirement
' I've encountered transfer STALL, even though the data looks correct, and
' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
' ControlRead() transfer gets things unstuck most of the time...
.xfer_retry
                mov     hctwait, _xfer_wait_
                call    #poll_waitx
                call    #wait_txn_ok
                mov     ep_addr_pid, hpar1
                mov     ptra, hpar2
                mov     pb, hpar3
                djnz    xfer_retry, #.xfer_start
                mov     context_retval, retval          ' Preserve the USB error code
        _ret_   mov     retval, #ERR_XFER_RETRY

'------------------------------------------------------------------------------
' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
' reporting is always in the function-to-host direction. It is assumed that
' the SETUP data struct is filled with the required values.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to the start of the struct for the SETUP data.
'   PB - the start address of the struct/buffer to be read for the OUT data
'     stage.
'   ep_addr_pid - the proper CRC'd address and endpoint to use.
' On exit:
'   retval - used to convey the success/failure of each stage.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_write
                testb   ep_addr_pid, #31        wc
        if_c    bith    hstatus, #DWNSTRM_HUBB
        if_c    bith    _usb_h_ls_nco_, #14

                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
.out_retry
                mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
                call    #txn_out
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit                        ' Function got the data
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
        if_nz   jmp     #.out_retry
                jmp     #dwnstream_reset                ' Caller must handle transfer retirement
.commit
                mov     pb, ptra                        ' Save the current buffer/struct location
                add     stage_data, pkt_data
                cmp     stage_data, total_data  wz
        if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
        if_nz   jmp     #.data                          ' More data to send
pre_status_in
                bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.status_retry
                mov     pkt_data, #0
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
        if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
        if_z    jmp     #dwnstream_reset                ' Control Write finished
                cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
        if_z    jmp     #dwnstream_reset
                call    #retry_wait                     ' NAK or bus error, so delay a bit
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.status_retry
'                ret                                     ' Caller must handle transfer retirement

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - The function address and endpoint for the IN request.
'   hpar2 - Address of the IN data buffer
'   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
' On exit:
'   retval - the result of the operation.
'   hpar3 - the count of IN data bytes actually received.
'------------------------------------------------------------------------------
do_int_in
                testb   ep_addr_pid, #31        wc
        if_c    bith    hstatus, #DWNSTRM_HUBB
        if_c    bith    _usb_h_ls_nco_, #14

                getword htmp, hpar3, #0
                cmp     htmp, #PID_DATA0        wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
                mov     retry, #TXN_RETRIES
.retry
                getword pkt_data, hpar3, #1             ' IN max packet length
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK if data received
        if_z    jmp     #.commit
                cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
        if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
        if_z    jmp     #.post_ret                      ' The caller must handle either
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    jmp     #.post_ret
                jmp     #.retry
.commit
                mov     ptra, urx_buff_p                ' Copy the rx buffer
                mov     pb, hpar2                       ' to the destination buffer
                mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
        if_nz   cmp     ptra, pb                wz
        if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
.post_ret
                mov     hpar3, pkt_cnt                  ' IN bytes actually received

'------------------------------------------------------------------------------
' Resets the downstream hub port to FS
'------------------------------------------------------------------------------
dwnstream_reset
                testb   ep_addr_pid, #31        wc
        if_nc   ret                                     ' No LS device, reset not needed
                bitl    _usb_h_ls_nco_, #14
                bitl    hstatus, #DWNSTRM_HUBB
                wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods

'------------------------------------------------------------------------------
' The one millisecond frame timer is implemented as an interrupt service
' routine. Since this timing is critical, care must be taken to avoid any
' instructions that can delay the interrupt branch, which will likely upset
' the timer. WAITX is among those instructions, so any time you're inside
' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'------------------------------------------------------------------------------
' On entry:
'   hctwait - wait interval in sysclocks.
' On exit:
'------------------------------------------------------------------------------
poll_waitx
                getct   hct2
                addct2  hct2, hctwait
.wait
                jnct2   #.wait
                ret

'------------------------------------------------------------------------------
' Transaction retry handling for NAK/STALL or bus error.
'------------------------------------------------------------------------------
' On entry:
'   retval - transaction response PID or error code.
' On exit:
'------------------------------------------------------------------------------
retry_wait
                cmp     retval, #PID_STALL      wz
        if_z    ret                                     ' STALL is special case
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak
                mov     hctwait, _txn_err_              ' Transaction error wait...
                call    #poll_waitx
.dec
                sub     retry, #1               wz
        if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
                ret                                     ' Retry result to caller
.nak
                mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
                call    #poll_waitx
                cmp     nak_retry, #NAK_NOLIMIT wz
        if_z    ret                                     ' Indefinite NAK retries
                sub     nak_retry, #1           wz
        if_z    mov     retval, #ERR_NAK
                ret

host_reset
                setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
                mov     htmp, ##_CLKFREQ                ' Get current sysclock setting
' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
                cmp     htmp, ##168_000_000     wcz
        if_be   mov     utx_tweak, #0
        if_a    mov     utx_tweak, #3   '#20
' Check to see if the system clock has been changed.
                cmp     htmp, save_sysclk       wz
        if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
        if_nz   add     pb, hcog_base_addr
        if_nz   call    pb                              ' Recalculate sysclk dependent timing values
                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                cmp     p2rev_val, #P2RevB      wz
        if_z    jmp     #.not_reva
                wrpin   ##USB_V1HMODE_FS, dm            ' The host is also the root hub, so full-speed is its native speed
                wrpin   ##USB_V1HMODE_FS, dp
                wxpin   _12Mbps_, dm                    ' Default to Full-Speed
                jmp     #.enable
.not_reva
                wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
                wrpin   ##USB_V2_DRVOUT, dp
                wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
.enable
                dirh    dm                              ' Crank them smart pins up
                dirh    dp
                waitx   _1us_
                wypin   #OUT_IDLE, dm

                ' Handle Port protection enable and startup delay
                mov     htmp, usb_event_pin             ' I/O + 1 pin is the Serial Host USB Protection enable/disable
                add     htmp, #1                        ' Protection enable is a one-time operation
                drvl    htmp                            ' disable port
                waitx   _21ms_                          ' Wait a while for everything to turn off
                drvh    htmp                            ' Enable the port
                waitx   _21ms_                          ' Hold to let the idle state get settled

                setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
                rep     @.regloop,#hreg_init_end - hreg_init_start
                alti    pa, #%000_111_000
                mov     0-0, #0
.regloop

discon_entry
                mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one

                ' Fall through to disconnected loop

'-----------------------------------------------------------------------------------------------------------------
' Device connect handling (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
' device to connect (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
disconnected
                mov     hr1, ##_CLKFREQ                 ' Check to see if the system frequency has changed
                cmp     hr1, save_sysclk        wz
        if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
                shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
                waitx   hr1                             ' it down to smaller wait chunks
                incmod  mod_cnt, #8             wc
        if_c    drvnot  host_active_led
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
        if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
        if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
.se1_test
                mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
                call    #poll_waitx
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
        if_ne   jmp     #discon_entry                   ' Back to connect detection loop
.se1            'SE1 is a fatal error condition
                mov     hctwait, _100ms_
                call    #poll_waitx
                mov     retval, #ERR_SE1
                call    #host_error                     ' Seeing SE1 for any length of time is not good...
.connect_test                                           ' Test lines until stable J/K state seen
                waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_z    jmp     #discon_entry                   ' D+ and D- low
        if_e    jmp     #.se1_test                      ' D+ and D- high
connected
                bith    hstatus, #CONNECTEDB            ' Device plugged in
                call    #on_connect                     ' Initial device configuration
                cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
        if_nz   jmp     #discon_entry
.set_pulse
                getct   _pulse_time_
                add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
' of 1ms and make a correction, if necessary.
'                mov     htmp, _1ms_
'                subs    htmp, iframe_delta
'                adds    _frame1ms_clks_, htmp
'                debug(udec(_frame1ms_clks_))

                ' Fall through to idle/processing loop

                cmp     hdev_port, #4           wcz
        if_a    mov     hdev_port, #0

hidle
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_c    jmp     #.se0_test
                pollct3                         wc
        if_nc   jmp     #.nopoll
                getct   hct3
                addct3  hct3, _2ms_                     ' Set the timer for next poll interval

                altgb   hdev_port, #hdev_type
                getbyte htmp

                cmp     htmp, #HUB_READY        wz
        if_z    loc     pa, #@hget_hub_status - @usb_host_start
        if_z    jmp     #.poll

                cmp     htmp, #KB_READY         wz
        if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
        'if_z    jmp     #.poll

.poll
        if_z    add     pa, hcog_base_addr
        if_z    call    pa

                incmod  hdev_port, #4

.nopoll
                cmp     cmd_data, #CMD_SUSPEND  wz
        if_z    jmp     #hsuspend
                cmp     cmd_data, #CMD_RESET    wz
        if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
        if_z    jmp     #host_reset                     ' See if it works...
                getct   hr0
                cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
        if_ae   drvnot  host_active_led
        if_ae   getct   _pulse_time_
        if_ae   add     _pulse_time_, _500ms_
                jmp     #hidle
' Check for extended SE0 state on the bus
.se0_test
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Wait a bit and test for SE0 again
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #hidle                          ' Bus still IDLE
                call    #wait_txn_ok
                wypin   ##OUT_IDLE, dm                  ' Float USB
                wxpin   #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
                jmp     #host_reset                     ' Device disconnected

hsuspend
                call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
                setint1 #0                              ' Stopping the 1ms frame packets signals suspend
                waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
                wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
                mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
                mov     mod_cnt, #0

                ' Fall through to resume wait loop

hwait_resume
                mov     hr1, ##_CLKFREQ                 ' Use the CLKFREQ value, as the sysclock may change
                shr     hr1, #2
                waitx   hr1                             ' Pulse the activity LED every two seconds but break
                incmod  mod_cnt, #8             wc      ' it down to smaller wait chunks
        if_c    drvnot  host_active_led
                cmp     cmd_data, #CMD_RESUME   wz
        if_nz   jmp     #hwait_resume
                mov     htmp, ##_CLKFREQ                ' Check to see if the system frequency has changed
                cmp     htmp, save_sysclk       wz
        if_z    jmp     #.resume
                loc     pb, #@hinit_usb_timings - @usb_host_start
                add     pb, hcog_base_addr
                call    pb                              ' Recalculate sysclk dependent timing values
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
        if_c    wxpin   _usb_h_ls_nco_, dm
.resume
                wypin   #OUT_K, dm
                waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
                wypin   #OUT_SE0, dm
                mov     htmp, _ip_delay_ls_
                shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
                waitx   htmp
                wypin   #OUT_J, dm
                shr     htmp, #1
                waitx   htmp
                wypin   #OUT_IDLE, dm
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                setint1 #1                              ' Enable the 1ms frame ISR
                mov     hctwait, _4ms_
                call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
        _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete

'------------------------------------------------------------------------------
' Send preamble to enable low-speed HUB ports
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   USB baud rate set to low-speed
'------------------------------------------------------------------------------
utx_pre
                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                wrpin   #0, dm                          ' Disable smartpin mode
                wrpin   #0, dp
                drvl    dm
                drvh    dp

                mov     htmp, ##OUT_SOP | (PID_PRE << 8)

                rep     @.l1, #16 + 1
                shr     htmp, #1        wc
        if_nc   setq    #1
        if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
                waitx   _preamble_wait_
.l1

                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
                wrpin   ##USB_V2_DRVOUT, dp
                wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
                dirh    dm                              ' Crank them smart pins up
                dirh    dp
                wypin   #OUT_IDLE, dm

                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods

hlut_end
                fit     $400

DAT             ' USB Host HUB execution
                orgh
'------------------------------------------------------------------------------
' Routines called from cog space.
'------------------------------------------------------------------------------
' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'------------------------------------------------------------------------------

'------------------------------------------------------------------------------
' USB host cog initialization.
'------------------------------------------------------------------------------
usb_host_init
                loc     pb, #hid_report
                mov     hid_report_p, pb
                add     pb, #KBD_IN_RPT_LEN
                mov     hid_report_p + 1, pb
                add     pb, #KBD_IN_RPT_LEN
                mov     hid_report_p + 2, pb
                add     pb, #KBD_IN_RPT_LEN
                mov     hid_report_p + 3, pb
                add     pb, #KBD_IN_RPT_LEN
                mov     hid_report_p + 4, pb

                loc     pb, #hub_descr
                mov     hub_descr_p, pb
                loc     pb, #urx_buff
                mov     urx_buff_p, pb
                loc     pb, #dev_desc_buff
                mov     dev_desc_buff_p, pb
                loc     pb, #con_desc_buff
                mov     con_desc_buff_p, pb
                loc     pb, #usb_cache_start
                mov     cache_start_p, pb
                loc     pb, #usb_cache_end
                mov     cache_end_p, pb

                drvl    host_error_led                  ' Ensure fatal error LED is inactive
'                mov     p2rev_val, ptrb                 ' Running on P2RevA or P2RevB+ silicon?
'                setq    #1
'                rdlong  $1e0, ptrb++
'                subr    p2rev_val, ptrb
'                shr     p2rev_val, #2           wz      ' RevA if shift result is zero
'        if_z    mov     p2rev_val, #P2RevA              ' 1 == RevA, 2 == RevB+
'                loc     ptrb, #p2rev_char               ' Make a revision "A" or "B" char accessible to Spin2
'                mov     htmp, p2rev_val
'                add     htmp, #"@"
'                wrbyte  htmp, ptrb
                dirl    usb_event_pin                   ' Configure the USB event mailbox smart pin
                wrpin   ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
                dirh    usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
' Configure and enable the Serial Host USB port.
                jmp     #host_reset                     ' Initialize host and enter main processing loop

'------------------------------------------------------------------------------
' Timing calculations happen before any interrupt(s) are enabled.
'------------------------------------------------------------------------------
' On entry:
'   htmp - current CLKFREQ value.
'------------------------------------------------------------------------------
hinit_usb_timings
'                getct   htmp2
                mov     save_sysclk, htmp
                qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
                getqx   _12Mbps_
                shr     _12Mbps_, #16           wc
                addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
                mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
                shl     _usb_h_fs_nco_, #14
                add     _usb_h_fs_nco_, _12Mbps_
                mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
                shl     _usb_d_fs_nco_, #14
                add     _usb_d_fs_nco_, _12Mbps_
                mov     _1_5Mbps_, _12Mbps_
                shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
                mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
                shl     _usb_h_ls_nco_, #14
                add     _usb_h_ls_nco_, _1_5Mbps_
                mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
                qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1b
                getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1m
                getqx   _1us_                           ' 1us as 32,9 fixed point
                mov     hsave0, _1us_                   ' Save it to compute other us values
                shr     _1us_, #9               wc
                addx    _1us_, #0                       ' Round to final value
                qmul    hsave0, #10                     ' Calc 10us
                getqx   _10us_
                shr     _10us_, #9              wc
                addx    _10us_, #0                      ' 10us
                qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
                getqx   _33us_
                shr     _33us_, #9              wc
                addx    _33us_, #0                      ' 33us
                qmul    hsave0, #250                    ' Calc 250us
                getqx   _txn_err_
                shr     _txn_err_, #9           wc
                addx    _txn_err_, #0                   ' 250us
                qmul    hsave0, #500                    ' Calc 500us
                getqx   _500us_
                shr     _500us_, #9             wc
                addx    _500us_, #0                     ' 500us
                qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
                getqx   _txn_ok_ls_
                shr     _txn_ok_ls_, #9         wc
                addx    _txn_ok_ls_, #0                 ' 666us
                qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
                getqx   _txn_ok_fs_
                shr     _txn_ok_fs_, #9         wc
                addx    _txn_ok_fs_, #0                 ' 850us
                mov     _ip_delay_ls_, _1ns16fp_
                mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_ls_, #16      wc
                addx    _ip_delay_ls_, #0
                mov     _tat_wait_ls_, _1ns16fp_
                mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
                shr     _tat_wait_ls_, #16      wc
                addx    _tat_wait_ls_, #0
                mov     _ip_delay_fs_, _1ns16fp_
                mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_fs_, #16      wc
                addx    _ip_delay_fs_, #0
                mov     _tat_wait_fs_, _1ns16fp_
                mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
                shr     _tat_wait_fs_, #16      wc
                addx    _tat_wait_fs_, #0
                qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
                getqx   _preamble_wait_
                sub     _preamble_wait_,# 9 - 1
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1thou
                getqx   _1ms_                           ' 1ms as 32,9 fixed point
                shr     _1ms_, #9               wc
                addx    _1ms_, #0                       ' 1ms
                mov     _frame1ms_clks_, ##-14
                adds    _frame1ms_clks_, _1ms_
                mov     _2ms_, _1ms_
                shl     _2ms_, #1                       ' 2ms
                mov     _suspend_wait_, _1ms_
                add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
                mov     _4ms_, _1ms_
                shl     _4ms_, #2                       ' 4ms
                mov     _xfer_wait_, _4ms_
                add     _xfer_wait_, _1ms_              ' 5ms
                mov     _reset_hold_, _xfer_wait_       ' 5ms
                mov     _resume_hold_, _reset_hold_
                shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
                mov     _100ms_, _resume_hold_          ' 20ms
                shl     _100ms_, #1                     ' 40ms
                mov     _8ms_, _1ms_
                shl     _8ms_, #3                       ' 8ms
                shl     _reset_hold_, #1                ' 10ms
                add     _100ms_, _reset_hold_           ' 50ms
                add     _reset_hold_, _xfer_wait_       ' 15ms
                mov     _21ms_, _xfer_wait_             ' 5ms
                shl     _21ms_, #2                      ' 20ms
                add     _21ms_, _1ms_                   ' 21ms
                mov     _500ms_, _100ms_                ' 50ms
                shl     _100ms_, #1                     ' 100ms
                shl     _500ms_, #3                     ' 400ms
        _ret_   add     _500ms_, _100ms_                ' 500ms
'        _ret_   mov     _1sec_, save_sysclk
'        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'                ret
{
                getct   htmp
                sub     htmp, htmp2
        debug("USB timing calc sysclocks: ", udec( htmp))
                ret
}

'------------------------------------------------------------------------------
' Parse a configuration descriptor chain to see if the device is a recognized
' one. If it is, start the task progression that will configure the device for
' use.
'------------------------------------------------------------------------------
' On entry:
'   hconfig_base - start address of the cached config descriptor chain.
' On exit:
'------------------------------------------------------------------------------
hparse_con_desc
                mov     ptrb, dev_desc_buff_p
                rdlong  hdev_id, ptrb[2]                ' idVendor + idProduct
                movbyts hdev_id, #%%1032                ' |
                rdword  hdev_bcd, ptrb[6]               ' bcdDevice
                debug(uhex_long(hdev_id), uhex_word(hdev_bcd))

                mov     pa, #CON_wTotalLen
                add     pa, hconfig_base
                rdword  hcon_tot_len, pa                ' Keep config chain size handy
                debug(uhex_byte_array(hconfig_base, hcon_tot_len))
' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
' that defines a keyboard and/or mouse.
                rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
.next_intf
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #hset_config
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.intf
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                jmp     #.next_intf
.intf
                mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
                mov     hpar3, #0
                rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
                rdbyte  hdev_class, ptrb[INTF_bIntfClass]
                rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
                rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
                debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))

.endp
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #.get_device
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.get_device
                cmp     htmp, #TYPE_ENDPOINT    wz
        if_z    jmp     #.get_ep
                jmp     #.endp
.get_ep
                rdbyte  hr1, ptrb[ENDP_bAddress]
                testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
                shl     hr1, #8 + 7
                mov     htmp, hctrl_ep_addr
                and     htmp, ##ADDR_MASK
                or      htmp, hr1                       ' endpoint address
                cmp     hpar2, #0               wz
 if_z_and_c     jmp     #.in_ep
                cmp     hpar3, #0               wz
 if_z_and_nc    jmp     #.out_ep
                jmp     #.endp
.in_ep
                mov     hpar2, htmp                     ' IN endpoint
                rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr2, hr0, #3
                jmp     #.endp
.out_ep
                mov     hpar3, htmp                     ' OUT endpoint
                rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr3, hr0, #3
                jmp     #.endp

.get_device
                cmp     hdev_class, #CLASS_HUB  wz
        if_z    jmp     #.hub
                cmp     hdev_class, #CLASS_HID              wz
        if_nz   jmp     #.next_intf                     ' No HID class, ignore
                cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
        if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
                cmp     hdev_protocol, #INTF_PROTO_KBD      wz
        if_nz   jmp     #.next_intf                     ' No Keyboard
.keyboard
                cmp     hkbd_ep_addr, #0    wz
        if_nz   jmp     #.next_intf
                getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
                getbyte kb_interval, hr2, #3
                getbyte kb_in_max_pkt, hr2, #0
                mov     hkbd_ep_addr, hpar2             ' IN endpoint address
                'debug(udec(kb_intf_num))
                debug(uhex_long(hkbd_ep_addr),uhex_long(hdev_out_addr),udec(kb_in_max_pkt,kb_interval))
                debug(uhex_long(hdev_ep_addr),uhex_long_(hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4))
                jmp     #.next_intf
.hub
                cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
        if_nz   jmp     #.next_intf
                cmp     hdev_protocol, #INTF_PROTO_NONE     wz
        if_nz   cmp     hdev_protocol, #2                   wz
        if_nz   jmp     #.next_intf
                cmp     hhub_ep_addr, #0    wz
        if_nz   jmp     #.next_intf
                getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
                mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
                mov     ep_addr_pid, hpar2              ' IN endpoint address
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                mov     hhub_ep_addr, ep_addr_pid
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
                debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
                debug(uhex_long(hdev_ep_addr),uhex_long_(hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4))
                jmp     #.next_intf

'------------------------------------------------------------------------------
' If a newly-connected device is recognized, do whatever is needed to configure
' it according to its function, or functions. In the case of this boot protocol
' keyboard/mouse class driver:
' - SetConfiguration(config_num)
' - SetProtocol(boot)
' - SetIdle(indefinite)
' - Enter the device interrupt IN polling task stage.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hset_config
                mov     htmp2, #DEV_UNKNOWN
                altd    hdev_port, #hdev_ep_addr
                cmp     0-0, #0                 wz
        if_z    cmp     hkbd_ep_addr, #0        wz
        if_z    cmp     hhub_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No known device
.set_config
                loc     ptra, #set_config
                mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
                add     pa, hconfig_base
                rdbyte  hpar1, pa
                wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
                mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
                mov     pb, #0                          ' SetConfiguration() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   ret
.kbd_config
                cmp     hkbd_ep_addr, #0        wz
        if_z    jmp     #.hub_config                    ' No keyboard
                mov     htmp, hkbd_ep_addr
                and     htmp, ##ADDR_MASK
                mov     htmp1, ep_addr_pid
                and     htmp1, ##ADDR_MASK
                cmp     htmp, htmp1             wz
        if_nz   jmp     #.hub_config                    ' No keyboard

                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_protocol
                wrword  #BOOT_PROTOCOL, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                mov     pb, #0                          ' SetProtocol() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
                getbyte hpar2, kb_intf_num, #0
                call    #hset_idle
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hctwait, _2ms_
                call    #poll_waitx
                mov     kb_led_states, #LED_NUMLKF
                mov     hkbd_ledstates, kb_led_states
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     ep_addr_pid, hkbd_ep_addr
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                testb   hub_port_status, #HUB_PORT_LOWSPEED wc
                bitc    ep_addr_pid, #31
                mov     hkbd_ep_addr, ep_addr_pid
                mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
                bitc    hkbd_ctrl_ep, #31
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
                mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
                mov     htmp2, #KB_READY                ' Keyboard interface configured
                jmp     #.notify_client
.hub_config
                cmp     hhub_ep_addr, #0    wz
        if_z    ret                                     ' No HUB
                mov     htmp, hhub_ep_addr
                and     htmp, ##ADDR_MASK
                mov     htmp1, ep_addr_pid
                and     htmp1, ##ADDR_MASK
                cmp     htmp, htmp1             wz
        if_nz   ret                                     ' No HUB

                loc     ptra, #get_hub_desc             ' Get HUB descriptor
                wrword  #$FF, ptra[wLength]
                mov     pb, hub_descr_p
                call    #control_read
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hhub_ep_addr, #0
        if_nz   jmp     #.notify_client
                debug(uhex_byte_array(hub_descr_p,total_data))

                loc     ptra, #set_port_feat            ' Power on ports
                wrword  #HUB_PORT_POWER, ptra[wValue]
                wrword  #1, ptra[wIndex]
                call    #control_write
                loc     ptra, #set_port_feat
                wrword  #2, ptra[wIndex]
                call    #control_write
                loc     ptra, #set_port_feat
                wrword  #3, ptra[wIndex]
                call    #control_write
                loc     ptra, #set_port_feat
                wrword  #4, ptra[wIndex]
                call    #control_write

                mov     hctwait, _500ms_
                add     hctwait, _100ms_
                call    #poll_waitx

                mov     htmp2, #HUB_READY               ' Hub ready
                'jmp     #.notify_client

.notify_client
                altsb   hdev_port, #hdev_type
                setbyte htmp2                           ' Save device ready
                debug("hdev_type = ", uhex_long_(hdev_type+1,hdev_type))
        _ret_   wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured

'------------------------------------------------------------------------------
' Initialize the keyboard/mouse data area to start-up values.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
init_kbdm_data
                mov     hkbd_ep_addr, #0
                mov     hdev_ep_addr, #0

                mov     ptra, cache_start_p         ' Clear cached data buffers
                mov     pa, cache_end_p
.loop
                wrbyte  #0, ptra++
                cmp     ptra, pa                wcz
        if_b    jmp     #.loop

                mov     pa, #hdev_init_start        ' Clear device data registers
.regloop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hdev_init_end      wz
        if_nz   jmp     #.regloop

                setbyte hdev_next_datax, #PID_DATA0, #0         ' Reset interrupt IN datax sequence PIDs
                setbyte hdev_next_datax, #PID_DATA0, #1
                setbyte hdev_next_datax, #PID_DATA0, #2
                setbyte hdev_next_datax, #PID_DATA0, #3
                setbyte hdev_next_datax + 1, #PID_DATA0, #0
                setbyte hdev_next_datax + 1, #PID_DATA0, #1
                setbyte hdev_next_datax + 1, #PID_DATA0, #2
                setbyte hdev_next_datax + 1, #PID_DATA0, #3
        _ret_   mov     hub_next_datax, #PID_DATA0

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
' function.
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'   hpar2 - index number of the target interface.
' On exit:
'------------------------------------------------------------------------------
hset_idle
                mov     hctwait, _2ms_
                call    #poll_waitx
                loc     ptra, #set_idle
                wrword  hpar1, ptra[wValue]
                wrword  hpar2, ptra[wIndex]
                jmp     #control_write

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - device address and enpoint for the request.
' On exit:
'   retval - transaction result.
'------------------------------------------------------------------------------
hset_kbdled_report
                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_report
                wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
                wrword  htmp, ptra[wIndex]
                wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
                mov     pb, urx_buff_p
                wrbyte  kb_led_states, pb
                jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for keyboard activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_kbd_in_report
                mov     ep_addr_pid, hkbd_ep_addr
                mov     hpar2, urx_buff_p
                altgb   hdev_port, #hdev_next_datax
                getbyte hpar3
                setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' No ACK, ignore
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet

                altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
                getbyte htmp                            ' |
                cmp     htmp, #PID_DATA0        wz      ' |
        if_z    mov     htmp, #PID_DATA1                ' |
        if_nz   mov     htmp, #PID_DATA0                ' |
                altsb   hdev_port, #hdev_next_datax     ' |
                setbyte htmp                            ' |

                mov     kb_max_index, hpar3             ' Save actual bytes read
                call    #hkbd_compare
.led_check
                mov     htmp, kb_led_states
                cmp     hkbd_ledstates, htmp    wz
        if_z    ret                                     ' No toggle key indicator changes, so we're done
                mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
                mov     ep_addr_pid, hkbd_ctrl_ep
                jmp     #hset_kbdled_report             ' Set report and ignore errors

'------------------------------------------------------------------------------
' Compare current and previous keyboard data buffers for keypress changes.
'------------------------------------------------------------------------------
hkbd_compare
                mov     ptra, urx_buff_p
                alts    hdev_port, #hid_report_p
                mov     ptrb, 0-0
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
                cmp     htmp1, htmp2    wz
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
        if_z    cmp     htmp1, htmp2    wz
        if_z    ret

                alts    hdev_port, #hid_report_p
                mov     ptra, 0-0

                mov     hpar1, #0
                rdbyte  hpar2, hid_report_p
                rdbyte  htmp, ptra
                cmp     hpar2, htmp     wz
        if_nz   modc    _clr    wc
        if_nz   call    #hkbd_translate

.release        modc    _set            wc
                'alts    hdev_port, #hid_report_p
                'mov     ptra, 0-0
                add     ptra, #2
                mov     pa, #6
.rl1            rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.rl3
                mov     ptrb, urx_buff_p
                add     ptrb, #2
                mov     pb, #6
.rl2            rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.rl3
                djnz    pb, #.rl2
                call    #hkbd_translate
.rl3            djnz    pa, #.rl1

                mov     hpar3, #0
                bith    hpar3, #31

.press          modc    _clr    wc
                mov     ptra, urx_buff_p
                add     ptra, #2
                mov     pa, #6
.pl1            rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.pl3
                alts    hdev_port, #hid_report_p
                mov     ptrb, 0-0
                add     ptrb, #2
                mov     pb, #6
.pl2            rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.pl3
                djnz    pb, #.pl2
                call    #hkbd_translate
.pl3            djnz    pa, #.pl1

.copy           mov     ptra, urx_buff_p
                alts    hdev_port, #hid_report_p
                mov     ptrb, 0-0
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++

                test    hpar2, #LEFT_GUIF   wz  ' check reset key combination
        if_nz   test    hpar2, #RIGHT_GUIF  wz  ' |
        if_nz   coginit #0, ##@cog_6502         ' re-start 6502 on cog #0

                ret

'------------------------------------------------------------------------------
' Translate keyboard scancode to ASCII
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - scancode
'   hpar2 - key modifiers state
'       c - pressed (0) or released (1) flag
'------------------------------------------------------------------------------
hkbd_translate
                test    hpar2, #LEFT_SHIFTF wz
                rdbyte  htmp, #@uk101_keyboard+0
                muxz    htmp, #%00000100
                wrbyte  htmp, #@uk101_keyboard+0

                test    hpar2, #RIGHT_SHIFTF wz
                rdbyte  htmp, #@uk101_keyboard+0
                muxz    htmp, #%00000010
                wrbyte  htmp, #@uk101_keyboard+0

                test    hpar2, #KEYS_CTRL   wz
                rdbyte  htmp, #@uk101_keyboard+0
                muxz    htmp, #%01000000
                wrbyte  htmp, #@uk101_keyboard+0

                cmp     hpar1, #$39         wz  ' CAPS LOCK
 if_z_and_nc    jmp     #.caps                  '   only pressed event

                shl     hpar1, #1
                add     hpar1, ##@usb_table
                rdword  hpar1, hpar1
                getnib  ptrb, hpar1, #2
                add     ptrb, #@uk101_keyboard
                rdbyte  htmp, ptrb
                muxc    htmp, hpar1
        _ret_   wrbyte  htmp, ptrb

.caps
                rdbyte  htmp, #@uk101_keyboard+0
                bitnot  htmp, #0
                bitnot  hkbd_ledstates, #LED_CAPSLKB
        _ret_   wrbyte  htmp, #@uk101_keyboard+0

'       The keyboard matrix has the following layout:
'
'               C7    C6    C5    C4    C3    C2    C1    C0
'                |     |     |     |     |     |     |     |
'              ! |   " |   # |   $ |   % |   & |   ' |     |
'              1 |   2 |   3 |   4 |   5 |   6 |   7 |     |
'       R7 ------+-----+-----+-----+-----+-----+-----+-----+
'              ( |   ) |(1)  |   * |   = | RUB |     |     |
'              8 |   9 |   0 |   : |   - | OUT |     |     |
'       R6 ------+-----+-----+-----+-----+-----+-----+-----+
'              > |   \ |     |(2)  |     |     |     |     |
'              . |   L |   O |   ^ |  CR |     |     |     |
'       R5 ------+-----+-----+-----+-----+-----+-----+-----+
'                |     |     |     |     |     |     |     |
'              W |   E |   R |   T |   Y |   U |   I |     |
'       R4 ------+-----+-----+-----+-----+-----+-----+-----+
'                |     |     |     |     |  LF |   [ |     |
'              S |   D |   F |   G |   H |   J |   K |     |
'       R3 ------+-----+-----+-----+-----+-----+-----+-----+
'                | ETX |     |     |     |   ] |   < |     |
'              X |   C |   V |   B |   N |   M |   , |     |
'       R2 ------+-----+-----+-----+-----+-----+-----+-----+
'                |     |     |     |   ? |   + |   @ |     |
'              Q |   A |   Z |space|   / |   ; |   P |     |
'       R1 ------+-----+-----+-----+-----+-----+-----+-----+
'           (3)  |     |(4)  |     |     | left|right|SHIFT|
'                | CTRL|     |     |     |SHIFT|SHIFT| LOCK|
'       R0 ------+-----+-----+-----+-----+-----+-----+-----+

'                        ROW        C7....C0
usb_table       word                       0  '00
                word                       0  '01
                word                       0  '02
                word                       0  '03
                word    (1 << 8) | %01000000  '04    a
                word    (2 << 8) | %00010000  '05    b
                word    (2 << 8) | %01000000  '06    c
                word    (3 << 8) | %01000000  '07    d
                word    (4 << 8) | %01000000  '08    e
                word    (3 << 8) | %00100000  '09    f
                word    (3 << 8) | %00010000  '0A    g
                word    (3 << 8) | %00001000  '0B    h
                word    (4 << 8) | %00000010  '0C    i
                word    (3 << 8) | %00000100  '0D    j
                word    (3 << 8) | %00000010  '0E    k
                word    (5 << 8) | %01000000  '0F    l
                word    (2 << 8) | %00000100  '10    m
                word    (2 << 8) | %00001000  '11    n
                word    (5 << 8) | %00100000  '12    o
                word    (1 << 8) | %00000010  '13    p
                word    (1 << 8) | %10000000  '14    q
                word    (4 << 8) | %00100000  '15    r
                word    (3 << 8) | %10000000  '16    s
                word    (4 << 8) | %00010000  '17    t
                word    (4 << 8) | %00000100  '18    u
                word    (2 << 8) | %00100000  '19    v
                word    (4 << 8) | %10000000  '1A    w
                word    (2 << 8) | %10000000  '1B    x
                word    (4 << 8) | %00001000  '1C    y
                word    (1 << 8) | %00100000  '1D    z

                word    (7 << 8) | %10000000  '1E    1
                word    (7 << 8) | %01000000  '1F    2
                word    (7 << 8) | %00100000  '20    3
                word    (7 << 8) | %00010000  '21    4
                word    (7 << 8) | %00001000  '22    5
                word    (7 << 8) | %00000100  '23    6
                word    (7 << 8) | %00000010  '24    7
                word    (6 << 8) | %10000000  '25    8
                word    (6 << 8) | %01000000  '26    9
                word    (6 << 8) | %00100000  '27    0

                word    (5 << 8) | %00001000  '28    Enter
                word                       0  '29    Esc
                word    (6 << 8) | %00000100  '2A    BS
                word                       0  '2B    Tab
                word    (1 << 8) | %00010000  '2C    Space
                word    (6 << 8) | %00010000  '2D    - and _
                word    (6 << 8) | %00001000  '2E    = and +
                word    (5 << 8) | %00010000  '2F    [ and {
                word                       0  '30    ] and }
                word                       0  '31    \ and |
                word                       0  '32    ` and ~
                word    (1 << 8) | %00000100  '33    ; and :
                word                       0  '34    ' and "
                word                       0  '35    ` and ~
                word    (2 << 8) | %00000010  '36    , and <
                word    (5 << 8) | %10000000  '37    . and >
                word    (1 << 8) | %00001000  '38    / and ?
                word                       0  '39    CapsLock
                word                       0  '3A    F1
                word                       0  '3B    F2
                word                       0  '3C    F3
                word                       0  '3D    F4
                word                       0  '3E    F5
                word                       0  '3F    F6
                word                       0  '40    F7
                word                       0  '41    F8
                word                       0  '42    F9
                word                       0  '43    F10
                word                       0  '44    F11
                word                       0  '45    F12
                word                       0  '46    PrScr
                word                       0  '47    ScrLock
                word                       0  '48    Pause
                word                       0  '49    Insert
                word                       0  '4A    Home
                word                       0  '4B    PageUp
                word                       0  '4C    Delete
                word                       0  '4D    End
                word                       0  '4E    PageDown
                word                       0  '4F    Right
                word                       0  '50    Left
                word                       0  '51    Down
                word                       0  '52    Up
                word                       0  '53    NumLock
                word                       0  '54    (/)
                word                       0  '55    (*)
                word                       0  '56    (-)
                word                       0  '57    (+)
                word                       0  '58    (Enter)
                word                       0  '59    (1)
                word                       0  '5A    (2)
                word                       0  '5B    (3)
                word                       0  '5C    (4)
                word                       0  '5D    (5)
                word                       0  '5E    (6)
                word                       0  '5F    (7)
                word                       0  '60    (8)
                word                       0  '61    (9)
                word                       0  '62    (0)
                word                       0  '63    (.)
                word                       0  '64    \ and |
                word                       0  '65    App

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for gamepad activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_hub_status
                mov     ep_addr_pid, hhub_ep_addr
                mov     hpar2, urx_buff_p
                setword hpar3, hub_next_datax, #0
                setword hpar3, #1, #1
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.data
                cmp     retval, #PID_NAK        wz
        if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
                ret
.data
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet

                cmp     hub_next_datax, #PID_DATA0  wz
        if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
        if_nz   mov     hub_next_datax, #PID_DATA0
                rdlong  hub_status_chg, urx_buff_p
                debug(ubin_long(hub_status_chg))

                testb   hub_status_chg, #1      wz
        if_x0   jmp     #.port2
                mov     hdev_port, #1
                call    #hub_port_handler
.port2
                testb   hub_status_chg, #2      wz
        if_x0   jmp     #.port3
                mov     hdev_port, #2
                call    #hub_port_handler
.port3
                testb   hub_status_chg, #3      wz
        if_x0   jmp     #.port4
                mov     hdev_port, #3
                call    #hub_port_handler
.port4
                testb   hub_status_chg, #4      wz
        if_x0   jmp     #.portN
                mov     hdev_port, #4
                call    #hub_port_handler
.portN
                ret

hub_port_handler
                mov     ep_addr_pid, hhub_ctrl_ep
                loc     ptra, #get_port_status          ' Get HUB port status
                mov     pb, urx_buff_p
                wrword  hdev_port, ptra[wIndex]
                call    #control_read
                rdlong  hub_port_status, urx_buff_p
                debug(udec(hdev_port), ubin_long(hub_port_status))

                testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
        if_x0   jmp     #.other
                loc     ptra, #clr_port_feat
                wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
                wrword  hdev_port, ptra[wIndex]
                call    #control_write
                testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
        if_x0   jmp     #.disconnect
                mov     hctwait, _100ms_
                call    #poll_waitx

                loc     ptra, #set_port_feat            ' reset port
                wrword  #HUB_PORT_RESET, ptra[wValue]
                wrword  hdev_port, ptra[wIndex]
                call    #control_write

                mov     htmp3, #2
.wait_reset
                mov     hctwait, _8ms_
                call    #poll_waitx
                loc     ptra, #get_port_status          ' Get HUB port status
                mov     pb, urx_buff_p
                wrword  hdev_port, ptra[wIndex]
                call    #control_read
                rdlong  hub_port_status, urx_buff_p
                testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
        if_x0   djnz    htmp3, #.wait_reset

                loc     ptra, #clr_port_feat
                wrword  #HUB_C_PORT_RESET, ptra[wValue]
                wrword  hdev_port, ptra[wIndex]
                call    #control_write

                mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
.wait_recover
                mov     hctwait, _1ms_
                call    #poll_waitx
                djnz    htmp,#.wait_recover

                testb   hub_port_status, #HUB_PORT_LOWSPEED wc
        if_c    bith    hstatus, #DWNSTRM_HUBB
        if_c    bith    _usb_h_ls_nco_, #14

                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
                wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done
.get_dev_desc
                mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
                mov     htmp, hdev_port             ' Address is hub port number
                wrword  htmp, ptra[wValue]
                call    #control_write                  ' Execute SetAddress()
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done                          ' Back to idle if not ACK
                mov     hctwait, _8ms_
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, hdev_port
                shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
                call    #calc_crc5
                loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done                          ' Back to idle if not ACK
                mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
                mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
                'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
                mov     hctwait, _500us_
                call    #poll_waitx
                loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
                wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done
                mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
                mov     hconfig_base, ptra              ' Will need this for configuration
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    mov     retval, #ERR_CONFIG_FAIL
        if_b    jmp     #.done
                call    #hparse_con_desc
                jmp     #.done

.other
                testb   hub_port_status, #HUB_C_PORT_RESET wz
        if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
        if_x1   jmp     #.reset_feature
                testb   hub_port_status, #HUB_C_PORT_ENABLE wz
        if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
        if_x1   jmp     #.reset_feature
                testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
        if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
        if_x1   jmp     #.reset_feature
                testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
        if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
        if_x1   jmp     #.reset_feature
                jmp     #.done
.reset_feature
                loc     ptra, #clr_port_feat
                wrword  hdev_port, ptra[wIndex]
                call    #control_write
                jmp     #.done
.disconnect
                altgb   hdev_port, #hdev_type
                getbyte htmp
                cmp     htmp, #KB_READY         wz
        if_z    mov     hkbd_ep_addr, #0
        if_z    mov     hkbd_ctrl_ep, #0
        if_z    mov     kb_led_states, #0
        if_z    mov     hkbd_ledstates, kb_led_states

                altsb   hdev_port, #hdev_type
                setbyte #0
                altd    hdev_port, #hdev_ep_addr
                mov     0-0, #0

.done
                bitl    _usb_h_ls_nco_, #14     wcz
                bitl    hstatus, #DWNSTRM_HUBB
        if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
                mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods

                loc     ptra, #get_port_status          ' Get HUB port status
                mov     pb, urx_buff_p
                wrword  hdev_port, ptra[wIndex]
                call    #control_read
                rdlong  hub_port_status, ptra
                debug(udec(hdev_port), ubin_long(hub_port_status))
                ret

'------------------------------------------------------------------------------
' Partially populated SETUP packets
'------------------------------------------------------------------------------
get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_DEVICE << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_CONFIG << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_CONFIG
                word    0       ' Configuration value
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_CONFIG has no data stage
set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_ADDR
                word    0       ' Zero
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_ADDR has no data stage
'------------------------------------------------------------------------------
' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
' wValue field dictates which protocol should be used.
'
' When initialized, all devices default to report protocol. However the host
' should not make any assumptions about the device state and should set the
' desired protocol whenever initializing a device.
'------------------------------------------------------------------------------
set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_PROTO
                word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
                                                ' (HID 1.11 Section 7.2.6).
                word    0               ' Interface index number.
                word    0               ' Zero, as HID_SET_PROTO has no data stage.
'------------------------------------------------------------------------------
set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_IDLE
                word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
                                        ' reporting until a change is detected in the report data

                                        ' (HID 1.11 Section 7.2.4).
                word    0       ' Interface index number.
                word    0       ' Zero, as HID_SET_IDLE has no data stage.
set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_REPORT
                word    0       ' Byte1 = report type, byte0 = ReportID.
                                        ' (HID 1.11 Section 7.2.2).
                word    0       ' Interface index number.
                word    0       ' Size of the report, in bytes.
get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
                byte    REQ_GET_DESC
                word    TYPE_REPORT << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
'------------------------------------------------------------------------------
get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_HUB << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
                byte    REQ_SET_FEATURE
                word    0       ' port power
                word    1       ' Port index number (1+)
                word    0       ' Number of bytes to transfer if there is a data stage
clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
                byte    REQ_CLEAR_FEATURE
                word    0       ' port power
                word    1       ' Port index number (1+)
                word    0       ' Number of bytes to transfer if there is a data stage
get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
                byte    REQ_GET_STATUS
                word    0
                word    1       ' Port index number (1+)
                word    4       ' Number of bytes to transfer if there is a data stage

'------------------------------------------------------------------------------
' The USB data cache area gets zero-filled at every device disconnect
'------------------------------------------------------------------------------
usb_cache_start

' HID descriptor and report buffers
hid_report      byte    0[KBD_IN_RPT_LEN * 5]

' HUB descriptor
hub_descr       byte    0   ' bDescLength
                byte    0   ' bDescriptorType
                byte    0   ' bNbrPorts
                word    0   ' wHubCharacteristics
                byte    0   ' bPwrOn2PwrGood
                byte    0   ' bHubContrCurrent
                byte    0   ' DeviceRemoveable
                byte    0   ' PortPwrCtrlMask

usb_cache_end

urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain

CON ' USB Host Shared constants
'------------------------------------------------------------------------------
' Smart pin configuration for "long repository" mode with output enabled,
' regardless of DIR. This allows one pin to provide a long event code via IN
' and also to control the USB port activity LED on/off state vio OUT.
    SP_REPO1_MODE = %01_00001_0 | 1 << 16    ' %TT_MMMMM_0, P[12:10] != %101
'------------------------------------------------------------------------------
' A simple event/cmd system using a smart pin configured in "long repository"
' mode. The USB_EVENT_REPO pin defined above is used to allow the USB cog to
' signal the client that a particular event has occurred. The client must poll
' this smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main"
' loop and process the event IDs you're interested in.
'------------------------------------------------------------------------------
    #0, NO_EVENT, USB_ERROR, DEV_UNKNOWN, KB_READY, M_READY, KBM_READY, HID_READY
    XINPUT_READY, PS3_READY, HUB_READY, DEV_DISCONNECT, DBG_DATA, M_DATA, GP_DATA
    CMD_SUSPEND, CMD_RESUME, CMD_RESET
'------------------------------------------------------------------------------
' The CMD_* tokens are asynchronous USB commands available to the user, through
' the Spin2 usbCommand method of this object. This method will post the cmd
' token to the host and when the cmd is complete the host will post the CMD_*
' token to byte[0] of the event long. Byte[1] is typically set to one of the
' below protocol error codes, with bytes[2..3] available for additional cmd data.
'------------------------------------------------------------------------------
' Protocol error codes:
    #0, ERR_NONE, ERR_CMD, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY
    ERR_XFER_RETRY, ERR_NAK, ERR_DATAX_SYNC, ERR_CONFIG_FAIL, ERR_TIMEOUT
'------------------------------------------------------------------------------
' Keyboard LED output report toggle key bit postions:
    #0, LED_NUMLKB, LED_CAPSLKB, LED_SCRLKB, LED_COMPOSEB
    LED_KANAB, LED_CONST0B, LED_CONST1B, LED_CONST2B
' Keyboard LED output report toggle key bitflags:
    LED_NUMLKF   = decod(LED_NUMLKB)
    LED_CAPSLKF  = decod(LED_CAPSLKB)
    LED_SCRLKF   = decod(LED_SCRLKB)
    LED_COMPOSEF = decod(LED_COMPOSEB)
    LED_KANAF    = decod(LED_KANAB)
    LED_CONST0F  = decod(LED_CONST0B)
    LED_CONST1F  = decod(LED_CONST1B)
    LED_CONST2F  = decod(LED_CONST2B)
' Keyboard modifier key bit positions:
    #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
    RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
' Keyboard modifier bitflags
    LEFT_CTRLF   = decod(LEFT_CTRLB)
    LEFT_SHIFTF  = decod(LEFT_SHIFTB)
    LEFT_ALTF    = decod(LEFT_ALTB)
    LEFT_GUIF    = decod(LEFT_GUIB)
    RIGHT_CTRLF  = decod(RIGHT_CTRLB)
    RIGHT_SHIFTF = decod(RIGHT_SHIFTB)
    RIGHT_ALTF   = decod(RIGHT_ALTB)
    RIGHT_GUIF   = decod(RIGHT_GUIB)
' Consolidated left/right modkeys. Add the modifier keys you want to trap
' together, then add the key scan code e.g. CTRL+ALT+"X" would be: $600 + KEY_X_x.
' The key() Spin2 method does this and the rawKey() method returns the key data
' as packed by the USB keyboard driver.
'   SHIFT = $100
'   CTRL  = $200
'   ALT   = $400
'   APP   = $800
' L|R key modifier flag combinations:
    KEYS_APP   = LEFT_GUIF + RIGHT_GUIF
    KEYS_ALT   = LEFT_ALTF + RIGHT_ALTF
    KEYS_CTRL  = LEFT_CTRLF + RIGHT_CTRLF
    KEYS_SHIFT = LEFT_SHIFTF + RIGHT_SHIFTF
'-------------
' Keyboard keys
' The first four scancodes are info/error indicators:
    #$00, KEY_NO_KEY, KEY_ERR_ROLLOVER, KEY_POST_FAIL, KEY_ERR_UNDEF
' Letters:
    KEY_A         = $04
    KEY_B         = $05
    KEY_C         = $06
    KEY_D         = $07
    KEY_E         = $08
    KEY_F         = $09
    KEY_G         = $0a
    KEY_H         = $0b
    KEY_I         = $0c
    KEY_J         = $0d
    KEY_K         = $0e
    KEY_L         = $0f
    KEY_M         = $10
    KEY_N         = $11
    KEY_O         = $12
    KEY_P         = $13
    KEY_Q         = $14
    KEY_R         = $15
    KEY_S         = $16
    KEY_T         = $17
    KEY_U         = $18
    KEY_V         = $19
    KEY_W         = $1a
    KEY_X         = $1b
    KEY_Y         = $1c
    KEY_Z         = $1d
' Number Row:
    KEY_1         = $1e
    KEY_2         = $1f
    KEY_3         = $20
    KEY_4         = $21
    KEY_5         = $22
    KEY_6         = $23
    KEY_7         = $24
    KEY_8         = $25
    KEY_9         = $26
    KEY_0         = $27
' Keyboard return (ENTER), tab, space, etc.:
    KEY_ENTER     = $28
    KEY_ESC       = $29
    KEY_BACKSPACE = $2a   ' Delete (backspace)
    KEY_TAB       = $2b
    KEY_SPACE     = $2c
    KEY_MINUS     = $2d   ' - and _
    KEY_EQUAL     = $2e   ' = and +
    KEY_LBRACE    = $2f   ' [ and {
    KEY_RBRACE    = $30   ' ] and }
    KEY_BACKSLASH = $31   ' \ and |
    KEY_HASHTILDE = $32   ' None-US # and ~
    KEY_SEMICOLON = $33   ' ; and :
    KEY_APOST     = $34   ' ' and "
    KEY_GRAVE     = $35   ' ` and ~
    KEY_COMMA     = $36   ' , and <
    KEY_DOT       = $37   ' . and >
    KEY_SLASH     = $38   ' / and ?
    KEY_CAPSLOCK  = $39
' Function key scancodes:
    KEY_F1        = $3a
    KEY_F2        = $3b
    KEY_F3        = $3c
    KEY_F4        = $3d
    KEY_F5        = $3e
    KEY_F6        = $3f
    KEY_F7        = $40
    KEY_F8        = $41
    KEY_F9        = $42
    KEY_F10       = $43
    KEY_F11       = $44
    KEY_F12       = $45
' Special, toggle and movement keys:
    KEY_PRINTSCREEN = $46
    KEY_SCROLLLOCK  = $47
    KEY_PAUSE       = $48
    KEY_INSERT      = $49
    KEY_HOME        = $4a
    KEY_PAGEUP      = $4b
    KEY_DELETE      = $4c
    KEY_END         = $4d
    KEY_PAGEDOWN    = $4e
    KEY_RIGHT       = $4f
    KEY_LEFT        = $50
    KEY_DOWN        = $51
    KEY_UP          = $52
' Keypad keys:
    KEY_NUMLOCK   = $53
    KEY_NUMSLASH  = $54
    KEY_NUMASTER  = $55
    KEY_NUMMINUS  = $56
    KEY_NUMPLUS   = $57
    KEY_NUMENTER  = $58
    KEY_NUM1      = $59
    KEY_NUM2      = $5a
    KEY_NUM3      = $5b
    KEY_NUM4      = $5c
    KEY_NUM5      = $5d
    KEY_NUM6      = $5e
    KEY_NUM7      = $5f
    KEY_NUM8      = $60
    KEY_NUM9      = $61
    KEY_NUM0      = $62
    KEY_DOT_DEL   = $63
    KEY_NOUS_SP   = $64   ' Non-US \ and |
    KEY_APP       = $65   ' Application key
' Modifier keys:
    KEY_LCTRL     = $E0
    KEY_LSHIFT    = $E1
    KEY_LALT      = $E2
    KEY_LMETA     = $E3 ' The left "Windows" key
    KEY_RCTRL     = $E4
    KEY_RSHIFT    = $E5
    KEY_RALT      = $E6
    KEY_RMETA     = $E7 ' The right "Windows" key

CON ' USB Host constants
'------------------------------------------------------------------------------
    _1thou         = 1_000
    _1m            = 1_000_000
    _1b            = 1_000_000_000
    _12m           = 12_000_000
    LSBTns         = 672.0                  ' Low-Speed bit period, in nanoseconds
    FSBTns         = 83.54                  ' Full-Speed bit period, in nanoseconds
    LSBTns4        = round(LSBTns * 4.0)    ' Low-Speed inter-packet delay, in nanoseconds
    LSBTns22       = round(LSBTns * 22.0)   ' Low-Speed turnaround wait time, in nanoseconds
    FSBTns4        = round(FSBTns * 4.0)    ' Full-Speed inter-packet delay, in nanoseconds
    FSBTns28       = round(FSBTns * 28.0)   ' Full-Speed turnaround wait time, in nanoseconds
' NCO baud calculations for low-speed/full-speed:
'        _1_5Mbps  = round(1_500_000.0 / _FCLKFREQ * 65536.0)  ' = NCO 492 @200MHz, 614 @160
'        _12Mbps   = round(12_000_000.0 / _FCLKFREQ * 65536.0) ' = NCO 3932 @200MHz, 4915 @160
' To configure RevA silicon LS/FS NCO baud: (WXPIN _1_5Mbps, D-) or (WXPIN _12Mbps, D-)
' To configure RevA LS/FS host/device: WRPIN appropriate LS/FS mode to D- (lower) and D+ (upper) pins:
    USB_V1HMODE_LS = %1_11000_0 + 1 << 16   ' Host mode
    USB_V1DMODE_LS = %1_11010_0 + 1 << 16   ' Device mode
    USB_V1HMODE_FS = %1_11001_0 + 1 << 16
    USB_V1DMODE_FS = %1_11011_0 + 1 << 16
' On RevB+ the USB smart pin mode is set to the D- and D+ pins via (WRPIN USBMode, pin#):
    USB_V2_DRVOUT  = %1_11011_0 + 1 << 16
    USB_V2_SNIFF   = %0_11011_0 + 1 << 16   ' Disable output to create a USB "sniffer"
' To configure NCO baud, host/device for LS/FS, set the appropriate mode to the D- pin# (WXPIN NCOMode, D-)
'   USB_H_LS_NCO   = %10 << 14 + _1_5Mbps   ' Host mode at NCO baud
'   USB_D_LS_NCO   = %00 << 14 + _1_5Mbps   ' Device mode at NCO baud
'   USB_H_FS_NCO   = %11 << 14 + _12Mbps
'   USB_D_FS_NCO   = %01 << 14 + _12Mbps
'------------------------------------------------------------------------------
' Time delays and intervals
' Useful USB constants and wait intervals:
    XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
    TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
    NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
    IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
    OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
' Standard Device request maximum timeout periods (reference):
{
    TO_STANDARD  = _1ms * 5000              ' Non-specific maximum timout period
    TO_DATA      = _1ms * 500               ' Standard Device requests with a data stage
    TO_NODATA    = _1ms * 50                ' Standard Device requests without a data stage
    TO_SETADDR   = _1ms * 50                ' Device SetAddress() command processing maximum
    TO_CHGADDR   = _1ms * 2                 ' Device SetAddress() period allowed to change its address before next request sent
}
'------------------------------------------------------------------------------
' Token packet format.
'------------------------------------------------------------------------------
'                   CRC5  ENDP ADDRESS PID
    CRC_MASK     = %11111_0000_0000000_00000000
    EP_MASK      = %00000_1111_0000000_00000000
    ADDR_MASK    = %00000_0000_1111111_00000000
    EP_ADDR_MASK = %00000_1111_1111111_11111111
    EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
'------------------------------------------------------------------------------
' Packet Identifier Bytes (PID). Notice that the first two LSBits are
' identical for each group.
'------------------------------------------------------------------------------
' Token:
    PID_OUT   = %1110_0001                  ' $e1
    PID_IN    = %0110_1001                  ' $69
    PID_SOF   = %1010_0101                  ' $a5
    PID_SETUP = %0010_1101                  ' $2d
' Data:
    PID_DATA0 = %1100_0011                  ' $c3
    PID_DATA1 = %0100_1011                  ' $4b
    PID_DATA2 = %1000_0111                  ' $87
    PID_MDATA = %0000_1111                  ' $0f
' Handshake:
    PID_ACK   = %1101_0010                  ' $d2
    PID_NAK   = %0101_1010                  ' $5a
    PID_STALL = %0001_1110                  ' $1e
    PID_NYET  = %1001_0110                  ' $96
' Special:
    PID_PRE   = %0011_1100                  ' $3c
    PID_ERR   = %0011_1100                  ' $3c
    PID_SPLIT = %0111_1000                  ' $78
    PID_PING  = %1011_0100                  ' $b4
    PID_RESVD = %1111_0000                  ' $f0
' Tx, rx and host related constants
' USB transmitter WYPIN D line state options:
    OUT_IDLE = 0
    OUT_SE0  = 1
    OUT_K    = 2
    OUT_J    = 3
    OUT_EOP  = 4
    OUT_SOP  = $80
' USB receiver RDPIN status bit positions:
    #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
' USB receiver RDPIN status bitflags:
    J_IDLEF    = decod(J_IDLEB)
    K_RESUMEF  = decod(K_RESUMEB)
    SE0_RESETF = decod(SE0_RESETB)
    SE1_BADF   = decod(SE1_BADB)
    SOPF       = decod(SOPB)
    EOPF       = decod(EOPB)
    BUS_ERRF   = decod(BUS_ERRB)
    BYTE_TGLF  = decod(BYTE_TGLB)
' USB CRC constants:
    USB5_POLY      = %0_0101 rev (5 - 1)    ' USB5 polynomial is reflected when calculating CRC
    USB5_RESIDUAL  = %0_1100 rev (5 - 1)    ' Expected CRC5 residual value when checking received data
    USB16_POLY     = $8005 rev (16 - 1)     ' USB16 polynomial is reflected when calculating CRC
    USB16_RESIDUAL = $800d rev (16 - 1)     ' Expected CRC16 residual value when checking received data
' Host->class driver USB connect speed:
    #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
    #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB[4], DWNSTRM_HUBB, SUSPENDB, KBM_TOGGLEB
' Host status bitflags. Unless otherwise noted, bit states are active high:
    IDLEF        = decod(IDLEB)             ' Set when USB in idle state
    CONNECTEDF   = decod(CONNECTEDB)        ' USB device connected
    LOW_SPEEDF   = decod(LOW_SPEEDB)        ' Low-speed device connected, clear if full-speed
    DATAx_TGLF   = decod(DATAx_TGLB)        ' Cleared if sending DATA0 packet, set if sending DATA1 packet
'   EOPF         = decod(EOPB)              ' Same bit position as the USB rx RDPIN status constants defined above
'   BUS_ERRF     = decod(BUS_ERRB)          ' Same bit position as the USB rx RDPIN status constants defined above
'   BYTE_TGLF    = decod(BYTE_TGLB)         ' Same bit position as the USB rx RDPIN status constants defined above
    DWNSTRM_HUBF = decod(DWNSTRM_HUBB)      ' NYI: downstream hub(s) connected
    SUSPENDF     = decod(SUSPENDB)          ' NYI: command the host to signal a global suspend
'------------------------------------------------------------------------------
' P2 silicon revision detection:
'------------------------------------------------------------------------------
    #1, P2RevA, P2RevB
'------------------------------------------------------------------------------

CON ' USB Descriptor Definitions
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
'------------------------------------------------------------------------------
' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
' Use TYPE_STANDARD for all USB Standard Device Request codes.
'------------------------------------------------------------------------------
' D7 Data direction  | D6:5 Type    | D4:0 Recipient
'------------------------------------------------------------------------------
' 0 - Host-to-device | 0 = Standard | 0 = Device
' 1 - Device-to-host | 1 = Class    | 1 = Interface
'                    | 2 = Vendor   | 2 = Endpoint
'                    | 3 = Reserved | 3 = Other
'                    |              | 4 -31 = Reserved
'------------------------------------------------------------------------------
    DIR_HOST_TO_DEV = 0 << 7
    DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
    TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
    TYPE_CLASS      = %01 << 5
    TYPE_VENDOR     = %10 << 5
    TYPE_RESERVED   = %11 << 5
    RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
    RECIP_INTERFACE = %0_0001
    RECIP_ENDPOINT  = %0_0010
    RECIP_OTHER     = %0_0011
'    RECIP 4 - 31 = Reserved
'------------------------------------------------------------------------------
' Standard Device Request codes (Section 9.4, Table 9-4):
'------------------------------------------------------------------------------
    #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
    REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
    REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
'------------------------------------------------------------------------------
' Standard descriptor types (Section 9.4, Table 9-5):
'------------------------------------------------------------------------------
    #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
    TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
'------------------------------------------------------------------------------
' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
'------------------------------------------------------------------------------
    #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
    CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
    CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
    CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
    CLASS_DIAGNOSTIC_DEV  = $dc
    CLASS_WIRELESS_CTRL   = $e0
    CLASS_MISCELLANEOUS   = $ef
    CLASS_APP_SPECIFIC    = $fe
    CLASS_VENDOR_SPECIFIC = $ff
'------------------------------------------------------------------------------
' HUB Class Requests
'------------------------------------------------------------------------------
    #0, HUB_PORT_CONNECTION, HUB_PORT_ENABLE, HUB_PORT_SUSPEND, HUB_PORT_OVERCURRENT
    HUB_PORT_RESET[4], HUB_PORT_POWER, HUB_PORT_LOWSPEED[7]
    HUB_C_PORT_CONNECTION, HUB_C_PORT_ENABLE, HUB_C_PORT_SUSPEND, HUB_C_PORT_OVERCURRENT
    HUB_C_PORT_RESET, HUB_PORT_TEST, HUB_PORT_INDICATOR
'------------------------------------------------------------------------------
' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
'------------------------------------------------------------------------------
    #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
    HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
' HID Descriptor types:
    #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
    #$29, TYPE_HUB
'------------------------------------------------------------------------------
' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
'------------------------------------------------------------------------------
    #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
'------------------------------------------------------------------------------
' HID Interface SubClasses:
'------------------------------------------------------------------------------
    #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
'------------------------------------------------------------------------------
' HID Protocol codes:
'------------------------------------------------------------------------------
    #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
    #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
'------------------------------------------------------------------------------
' Other HID buffer lengths:
'------------------------------------------------------------------------------
    MAX_HID_REPTS   = 4             ' We have this many HID report buffers
    REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
    REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
    LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
    USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
'------------------------------------------------------------------------------
' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
'------------------------------------------------------------------------------
    LANG_ENG_US  = $0409            ' English (United States)
    LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
'------------------------------------------------------------------------------
' SETUP structure member offsets.
' NOTE: These offsets are defined in terms of the structure member's data type,
'       to take advantage of PTRA/B scaled indexing, e.g.:
'         RDBYTE D,   PTRA[bRequest]
'         WRWORD D/#, PTRA[wLength]
'------------------------------------------------------------------------------
    bmRequestType = 0
    bRequest      = 1
    wValue        = 1
    wIndex        = 2
    wLength       = 3
' SETUP bmRequestType combinations:
{
    HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
    DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
    HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
    HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
}
'------------------------------------------------------------------------------
' Standard USB descriptor structure sizes in bytes. The values defined are the
' minimum size of the descriptor:
'------------------------------------------------------------------------------
    SETUP_TXN_LEN = 8
    DEV_DESC_LEN  = 18
    CON_DESC_LEN  = 9
    INTF_DESC_LEN = 9
    ENDP_DESC_LEN = 7
    STR0_DESC_LEN = 4
    USTR_DESC_LEN = 4
'------------------------------------------------------------------------------
' Other USB-related buffer sizes:
'------------------------------------------------------------------------------
    URX_BUFF_LEN = 128      ' USB receiver scratch buffer
    CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
'------------------------------------------------------------------------------
' CON_bmAttrs member bit positions:
'------------------------------------------------------------------------------
    ATTR_RESVB     = 7      ' Reserved (should always be one)
    ATTR_SELF_PWRB = 6      ' Device Self-Powered
    ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
'    bmAttributes bits 4..0 reserved and reset to zero
'------------------------------------------------------------------------------
' Standard USB descriptor struct member offset and member size, in bytes. Note
' that the DESC_bLength and DESC_bDescType members are defined in all of the
' descriptors (including HID) at the offsets shown.
'------------------+
' !!! IMPORTANT !!!|
'------------------+
' All standard descriptor member offsets are defined in bytes, so if you want
' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
'       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
' If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
' must be very careful...
'------------------------------------------------------------------------------
'       Member          Offset  Size    Value           Description
'------------------------------------------------------------------------------
    DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
    DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
' Device Descriptor (Section 9.6.1, Table 9-8):
    DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
    DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
    DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
    DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
    DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
    DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
    DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
    DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
    DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
    DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
    DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
    DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
  ' Configuration Descriptor (Section 9.6.3, Table 9-10):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
    CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
    CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
    CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
    CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
    CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
    CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
' Interface Descriptor (Section 9.6.5, Table 9-12):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
    INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
    INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
    INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
    INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
    INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
                            '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
                            '                       reserved for assignment by the USB-IF.
    INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
                            '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
                            '                       vendor-specific protocol for this interface.
    INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
' Endpoint Descriptor (Section 9.6.6, Table 9-13):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
    ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
    ENDP_bmAttrs     = 3    ' 1     Bitmap
    ENDP_wMaxPktSize = 4    ' 2     Number
    ENDP_bInterval   = 6    ' 1     Number
' String Descriptor Zero (Section 9.6.7, Table 9-15):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
' Unicode String Descriptor (Section 9.6.7, Table 9-16):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    USTR_wString     = 2    ' N     wString[(N - 2) / 2]
'------------------------------------------------------------------------------
' HID Descriptor (Section 6.2.1)
'------------------------------------------------------------------------------
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
    HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
    HID_bCountryCode = 4    ' 1     Number          Hardware target country
    HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
    HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
    HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).

' Keyboard report data buffer lengths (boot protocol):
    KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
    KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size

DAT             ' VGA Driver COG resident code
                org     $000

video_driver
                wrlut   ##$00_00_00_00, #0      ' background
                wrlut   ##$F0_F0_F0_00, #1      ' foreground

                setcmod #%01_0_000_0            ' enable colorspace conversion
                setcy   ##VGA_INTENSITY << 24   ' r      set colorspace for rgb
                setci   ##VGA_INTENSITY << 16   ' g
                setcq   ##VGA_INTENSITY << 08   ' b
                setxfrq vga_xf                  ' set transfer frequency

                cogid   pa                  ' insert cogid into dac modes
                setnib  dacmode_s, pa, #2
                setnib  dacmode_c, pa, #2

                wrpin   dacmode_s, vga_pn   ' enable 123-ohm 3.3V dac mode in pin +0

                xor     vga_pn, #2<<6|1     ' enable 75-ohm 2.0V dac mode in pins +1..3
                wrpin   dacmode_c, vga_pn

                xor     vga_pn, #3<<6 ^(2<<6|1) ' make pins +0..3 outputs
                drvl    vga_pn

                xor     vga_pn, #4|(3<<6)   ' leave av_base pointing to pin +4 (vertical sync)
                drvl    vga_pn

vga_field
                callpa  #22, #.border       ' top border

                mov     _sl, #0
                mov     pa, #128            ' visible lines
                mov     ptra, ##@video_ram+12
.loop           call    #.line
                call    #.line
                call    #.line
                call    #.line
                incmod  _sl, #7         wc
        if_c    add     ptra, #64
                djnz    pa, #.loop

                callpa  #22, #.border       ' bottom border

                callpa  #1, #.blank         ' front-porch

                drvnot  vga_pn              ' vertical sync on
                callpa  #4, #.blank         ' sync-lines
                drvnot  vga_pn              ' vertical sync off

                callpa  #23, #.blank        ' back-porch

                jmp     #vga_field          ' loop

.line           xcont   vga_bs, #0          ' do before-sync part of scan line
                xzero   vga_ds, #1          ' do sync part of scan line
                xcont   vga_as, #0          ' do before-visible part of scan line
                xcont   vga_bv, #0          ' do left border

                mov     pb, #48
.l1             rdbyte  _ch, ptra++
                shl     _ch, #3
                add     _ch, ##@chargen_rom
                add     _ch, _sl
                rdbyte  _ch, _ch
                rev     _ch
                shr     _ch, #24
                xcont   vga_dv, _ch
                djnz    pb, #.l1
                sub     ptra, #48

        _ret_   xcont   vga_av, #0             ' do right border

.border         xcont   vga_bs, #0             ' do before-sync part of scan line
                xzero   vga_ds, #1             ' do sync part of scan line
                xcont   vga_as, #0             ' do before-visible part of scan line
                xcont   vga_vi, #0             ' do visible part of scan line (blank)

                xcont   vga_bs, #0             ' do before-sync part of scan line
                xzero   vga_ds, #1             ' do sync part of scan line
                xcont   vga_as, #0             ' do before-visible part of scan line
                xcont   vga_vi, #0             ' do visible part of scan line (blank)
        _ret_   djnz    pa, #.border

.blank          xcont   vga_bs, #0             ' do before-sync part of scan line
                xzero   vga_ds, #1             ' do sync part of scan line
                xcont   vga_as, #0             ' do before-visible part of scan line
                xcont   vga_vi, #0             ' do visible part of scan line (blank)
        _ret_   djnz    pa, #.blank

'
'
' Data
'
dacmode_s       long    P_DAC_124R_3V + P_CHANNEL ' %0000_0000_000_1011000000000_01_00000_0         'hsync is 123-ohm, 3.3V
dacmode_c       long    P_DAC_75R_2V + P_CHANNEL  ' %0000_0000_000_1011100000000_01_00000_0         'R/G/B are 75-ohm, 2.0V

vga_xf          long   (VGA_FPIX frac _CLKFREQ) >> 1             ' streamer frequency setting
vga_bs          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  20    ' streamer command: before-sync
vga_ds          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  64    ' streamer command: during-sync
vga_as          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  44    ' streamer command: after sync
vga_vi          long    X_IMM_32X1_LUT|X_DACS_3_2_1_0   + 400    ' streamer command: visible
vga_bv          long    X_IMM_32X1_LUT|X_DACS_3_2_1_0   +   8    ' streamer command: before visible
vga_dv          long    X_IMM_32X1_LUT|X_DACS_3_2_1_0   +   8    ' streamer command: during visible
vga_av          long    X_IMM_32X1_LUT|X_DACS_3_2_1_0   +   8    ' streamer command: after visible
vga_pn          long    VGA_PIN & $38       ' base pin

'_vx             long    0

_sl             long    0                   ' scanline counter
_lb             long    0                   ' line buffer pointer
_cp             long    0                   ' character pointer
_bm             long    0[2]                ' character bitmap

_ch             long    0
_fc             long    0

                fit     $1F0

CON             ' VGA constants

    VGA_FPIX      = 20_000_000
    VGA_INTENSITY = 80    '0..128

DAT             ' Character generator ROM
                orgh

chargen_rom     file    "CHGUK101.ROM"

DAT             ' 6502 COG resident code
                org     $000

cog_6502
                add     ptrb, ##@lut_6502 - @cog_6502
                setq2   #$200-1
                rdlong  0, ptrb

                call    #\io_init

                getct   ts                  ' timer reference for clock throttling
                mov     _I, #4              ' reset cycles

                mov     _P, #%00110000      ' initial flags
                mov     _S, #$FF            ' initial stack pointer

                mov     ptrb, ##$FFFC       ' read reset vector
                add     ptrb, ram_addr      ' |
                rdword  ptrb, ptrb          ' |
                add     ptrb, ram_addr      ' |

                rep     @.loop, #8          ' ready to single-step
                push    #.loop

.loop           nop
                nop

                add     _T, _I              ' update total cycles count

                mul     _I, _I_CLK          ' clock throttling
                addct1  ts, _I              ' |
                jnct1   #$                  ' |

                rdbyte  t1, ptrb++          ' fetch instruction

                rdlut   t1, t1              ' decode instruction

                getnib  _I, t1, #7          ' get cycles count
                setnib  t1, #0, #7          ' |

                execf   t1                  ' execute instruction


'
'
' Instructions
'
i_adc_abs       call    #\_fetch_abs        ' %1_1111110
i_adc_abs_x     call    #\_fetch_abs_x      ' %1_111110
i_adc_abs_y     call    #\_fetch_abs_y      ' %1_11110
i_adc_ind_x     call    #\_fetch_ind_x      ' %1_1110
i_adc_ind_y     call    #\_fetch_ind_y      ' %1_110
i_adc_zpg       call    #\_fetch_zpg        ' %1_10
i_adc_zpg_x     call    #\_fetch_zpg_x      ' %1_0
i_adc_imm       rdbyte  t1, ptrb++          ' %0

_adc            testb   _P, #REGP_C     wc

                testb   _P, #REGP_D     wz
        if_z    jmp     #_adc_dec

                getbyte t3, _A, #0          ' t3 = sum
                addx    t3, t1              ' |
                testb   t3, #7          wz  ' affects N
                bitz    _P, #REGP_N         ' |

                getbyte t2, _A, #0          ' t2 = ~(A ^ operand)
                xor     t2, t1              ' |
                xor     t2, #$FF            ' |
                getbyte t4, _A, #0          ' t4 = A ^ sum
                xor     t4, t3
                and     t2, t4              ' t2 = ~(A ^ operand) & (A ^ sum)
                testb   t2, #7          wz  ' affects V
                bitz    _P, #REGP_V         ' |

                testb   t3, #8          wz  ' affects C
                bitz    _P, #REGP_C         ' |

                getbyte _A, t3, #0

                test    _A, #$FF        wz  ' affects Z
        _ret_   bitz    _P, #REGP_Z         ' |

_adc_dec        mov     t2, _A              ' t2 = lo
                and     t2, #$0F
                mov     t4, t1
                and     t4, #$0F
                addx    t2, t4

                mov     t3, _A              ' t3 = hi
                and     t3, #$F0
                mov     t4, t1
                and     t4, #$F0
                add     t3, t4

                cmp     t2, #$09        wcz
        if_a    add     t2, #$06
        if_a    add     t3, #$10

                testb   t3, #7          wz  ' affects N
                bitz    _P, #REGP_N         ' |

                getbyte t5, _A, #0          ' t5 = ~(A ^ operand)
                xor     t5, t1              ' |
                xor     t5, #$FF            ' |
                getbyte t4, _A, #0          ' t4 = A ^ hi
                xor     t4, t3
                and     t5, t4              ' t5 = ~(A ^ operand) & (A ^ hi)
                testb   t5, #7          wz  ' affects V
                bitz    _P, #REGP_V         ' |

                cmp     t3, #$90        wcz
        if_a    add     t3, #$60

                testb   t3, #8          wz  ' affects C
                bitz    _P, #REGP_C         ' |

                getnib  _A, t2, #0
                add     _A, t3

                and     _A, #$FF        wz  ' affects Z
        _ret_   bitz    _P, #REGP_Z         ' |

i_log_abs       call    #\_fetch_abs        ' %xxx_1_1111110
i_log_zpg       call    #\_fetch_zpg        ' %xxx_1_111110
i_log_abs_x     call    #\_fetch_abs_x      ' %xxx_1_11110
i_log_abs_y     call    #\_fetch_abs_y      ' %xxx_1_1110
i_log_ind_x     call    #\_fetch_ind_x      ' %xxx_1_110
i_log_ind_y     call    #\_fetch_ind_y      ' %xxx_1_10
i_log_zpg_x     call    #\_fetch_zpg_x      ' %xxx_1_0
i_log_imm       rdbyte  t1, ptrb++          ' %xxx_0
                and     t1, _A              '  110 AND
                xor     t1, _A              '  101 EOR
                or      t1, _A              '  011 ORA
                getbyte _A, t1, #0
                jmp     #_flags

i_asl_abs       call    #\_fetch_abs        ' %01_000_1_1110
i_asl_zpg       call    #\_fetch_zpg        ' %01_000_1_110
i_asl_abs_x     call    #\_fetch_abs_x      ' %01_000_1_10
i_asl_zpg_x     call    #\_fetch_zpg_x      ' %01_000_1_0
i_asl           getbyte t1, _A, #0          ' %10_000_0

                testb   t1, #7          wz
                shl     t1, #1
                bitz    _P, #REGP_C

                getbyte _A, t1, #0
                call    #\_write
                jmp     #_flags
                                            '       SC NVZC
i_branch        rdbyte  t1, ptrb++          ' BCC: %10_1110_0
                                            ' BCS: %01_1110_0
                                            ' BNE: %10_1101_0
                                            ' BEQ: %01_1101_0
                testb   _P, #REGP_C     wc  ' BPL: %10_0111_0
                testb   _P, #REGP_Z     wc  ' BMI: %01_0111_0
                testb   _P, #REGP_V     wc  ' BVC: %10_1011_0
                testb   _P, #REGP_N     wc  ' BVS: %01_1011_0
        if_c    ret                         ' Clear
        if_nc   ret                         ' Set

                add     _I, #1
                sub     ptrb, ram_addr
                signx   t1, #7
                add     ptrb, t1
                cmpsub  ptrb, ##$10000
        _ret_   add     ptrb, ram_addr

i_bit_abs       call    #\_fetch_abs
i_bit_zpg       call    #\_fetch_zpg
_bit            test    _A, t1          wz
                bitz    _P, #REGP_Z
                and     t1, #%11000000
                and     _P, #%00111111
        _ret_   or      _P, t1

i_brk           add     ptrb, #1
                sub     ptrb, ram_addr
                getbyte t1, ptrb, #1        ' PCH -> (S)
                call    #_push_t1
                getbyte t1, ptrb, #0        ' PCL -> (S)
                call    #_push_t1
                getbyte t1, _P, #0          ' P -> (S)
                bith    t1, #REGP_B         ' B=1
                call    #_push_t1

                bith    _P, #REGP_I         ' I=1

                mov     t2, ##$FFFE
                add     t2, ram_addr
                rdword  ptrb, t2
        _ret_   add     ptrb, ram_addr

i_clc   _ret_   bitl    _P, #REGP_C
i_cld   _ret_   bitl    _P, #REGP_D
i_cli   _ret_   bitl    _P, #REGP_I
i_clv   _ret_   bitl    _P, #REGP_V

i_cmp_abs       call    #\_fetch_abs        ' %xxx_0_1_1111110
i_cmp_abs_x     call    #\_fetch_abs_x      ' %xxx_0_1_111110
i_cmp_abs_y     call    #\_fetch_abs_y      ' %xxx_0_1_11110
i_cmp_ind_x     call    #\_fetch_ind_x      ' %xxx_0_1_1110
i_cmp_ind_y     call    #\_fetch_ind_y      ' %xxx_0_1_110
i_cmp_zpg       call    #\_fetch_zpg        ' %xxx_0_1_10
i_cmp_zpg_x     call    #\_fetch_zpg_x      ' %xxx_0_1_0
i_cmp_imm       rdbyte  t1, ptrb++          ' %xxx_00
                mov     t2, t1
                getbyte t1, _A, #0          '  110 CMP
                getbyte t1, _X, #0          '  101 CPX
                getbyte t1, _Y, #0          '  011 CPY
                sub     t1, t2
                testb   t1, #8          wz
                bitnz   _P, #REGP_C
                jmp     #_flags

i_dec_zpg       call    #\_fetch_zpg        ' %xx_1110
i_dec_abs_x     call    #\_fetch_abs_x      ' %xx_110
i_dec_zpg_x     call    #\_fetch_zpg_x      ' %xx_10
i_dec_abs       call    #\_fetch_abs        ' %xx_0
                sub     t1, #1              '  10 DEC
                add     t1, #1              '  01 INC
                call    #\_write
                jmp     #_flags

                                            ' INX INY DEX DEY
i_inde_xy       getbyte t1, _X, #0          '  0   1   0   1
                getbyte t1, _Y, #0          '  1   0   1   0
                add     t1, #1              '  0   0   1   1
                sub     t1, #1              '  1   1   0   0
                getbyte _X, t1, #0          '  0   1   0   1
                getbyte _Y, t1, #0          '  1   0   1   0
                jmp     #_flags

i_jmp           rdword  ptrb, ptrb          ' 0 0
                add     ptrb, ram_addr      ' 1 0
                rdword  ptrb, ptrb          ' 1 0
        _ret_   add     ptrb, ram_addr      ' 0 0

i_jsr           rdword  t4, ptrb            ' t4 = new PC
                add     ptrb, #1

                sub     ptrb, ram_addr
                getbyte t1, ptrb, #1        ' PCH -> (S)
                call    #_push_t1
                getbyte t1, ptrb, #0        ' PCL -> (S)
                call    #_push_t1

                mov     ptrb, t4
        _ret_   add     ptrb, ram_addr

i_ld_abs        call    #\_fetch_abs        ' %xxx_1_11111110
i_ld_abs_x      call    #\_fetch_abs_x      ' %xxx_1_1111110
i_ld_abs_y      call    #\_fetch_abs_y      ' %xxx_1_111110
i_ld_zpg        call    #\_fetch_zpg        ' %xxx_1_11110
i_ld_zpg_x      call    #\_fetch_zpg_x      ' %xxx_1_1110
i_ld_zpg_y      call    #\_fetch_zpg_y      ' %xxx_1_110
i_ld_ind_x      call    #\_fetch_ind_x      ' %xxx_1_10
i_ld_ind_y      call    #\_fetch_ind_y      ' %xxx_1_0
i_ld_imm        rdbyte  t1, ptrb++          ' %xxx_0
                mov     _A, t1              '  110 LDA
                mov     _X, t1              '  101 LDX
                mov     _Y, t1              '  011 LDY
                jmp     #_flags

i_lsr_abs       call    #\_fetch_abs        ' %01_00_1_1110
i_lsr_zpg       call    #\_fetch_zpg        ' %01_00_1_110
i_lsr_abs_x     call    #\_fetch_abs_x      ' %01_00_1_10
i_lsr_zpg_x     call    #\_fetch_zpg_x      ' %01_00_1_0
i_lsr           getbyte t1, _A, #0          ' %10_00_0

                shr     t1, #1          wc
                bitc    _P, #REGP_C

                getbyte _A, t1, #0
                call    #\_write
                jmp     #_flags

i_nop_abs       call    #\_fetch_abs        ' %11110
i_nop_abs_x     call    #\_fetch_abs_x      ' %1110
i_nop_zpg       call    #\_fetch_zpg        ' %110
i_nop_zpg_x     call    #\_fetch_zpg_x      ' %10
i_nop_imm       rdbyte  t1, ptrb++          ' %0
i_nop           ret

i_push          getbyte t1, _A, #0
                getbyte t1, _P, #0
                jmp     #_push_t1

i_pla           call    #_pop_t1
                getbyte _A, t1, #0
                jmp     #_flags

i_plp           call    #_pop_t1
                getbyte _P, t1, #0
        _ret_   or      _P, #%00110000      ' always on flags

i_rol_abs       call    #\_fetch_abs        ' %01_00000_1_1110
i_rol_zpg       call    #\_fetch_zpg        ' %01_00000_1_110
i_rol_abs_x     call    #\_fetch_abs_x      ' %01_00000_1_10
i_rol_zpg_x     call    #\_fetch_zpg_x      ' %01_00000_1_0
i_rol           getbyte t1, _A, #0          ' %10_00000_0

                testb   _P, #REGP_C     wc
                testb   t1, #7          wz
                shl     t1, #1
                bitc    t1, #0
                bitz    _P, #REGP_C

                getbyte _A, t1, #0
                call    #\_write

                jmp     #_flags


i_ror_abs       call    #\_fetch_abs        ' %01_00000_1_1110
i_ror_zpg       call    #\_fetch_zpg        ' %01_00000_1_110
i_ror_abs_x     call    #\_fetch_abs_x      ' %01_00000_1_10
i_ror_zpg_x     call    #\_fetch_zpg_x      ' %01_00000_1_0
i_ror           getbyte t1, _A, #0          ' %10_00000_0

                testb   _P, #REGP_C     wc
                testb   t1, #0          wz
                shr     t1, #1
                bitc    t1, #7
                bitz    _P, #REGP_C

                getbyte _A, t1, #0
                call    #\_write

                jmp     #_flags

i_rti           call    #_pop_t1            ' (S) -> P
                mov     _P, t1
                ' fall-through
i_rts           call    #_pop_t1            ' (S) -> PCL
                getbyte ptrb, t1, #0        ' |
                call    #_pop_t1            ' (S) -> PCH
                setbyte ptrb, t1, #1        ' |
                incmod  ptrb, ##$FFFF       ' PC = PC + 1 (skip if RTI)
        _ret_   add     ptrb, ram_addr

i_sbc_abs       call    #\_fetch_abs        ' %1_1111110
i_sbc_abs_x     call    #\_fetch_abs_x      ' %1_111110
i_sbc_abs_y     call    #\_fetch_abs_y      ' %1_11110
i_sbc_ind_x     call    #\_fetch_ind_x      ' %1_1110
i_sbc_ind_y     call    #\_fetch_ind_y      ' %1_110
i_sbc_zpg       call    #\_fetch_zpg        ' %1_10
i_sbc_zpg_x     call    #\_fetch_zpg_x      ' %1_0
i_sbc_imm       rdbyte  t1, ptrb++          ' %0

_sbc            testbn  _P, #REGP_C     wc

                getbyte t3, _A, #0          ' t3 = sum
                subx    t3, t1              ' |
                testb   t3, #7          wz  ' affects N
                bitz    _P, #REGP_N         ' |

                getbyte t2, _A, #0          ' t2 = (A ^ operand)
                xor     t2, t1              ' |
                getbyte t4, _A, #0          ' t4 = A ^ sum
                xor     t4, t3
                and     t2, t4              ' t2 = (A ^ operand) & (A ^ sum)
                testb   t2, #7          wz  ' affects V
                bitz    _P, #REGP_V         ' |

                testb   t3, #8          wz  ' affects C
                bitnz   _P, #REGP_C         ' |

                test    t3, #$FF        wz  ' affects Z
                bitz    _P, #REGP_Z         ' |

                testb   _P, #REGP_D     wz
        if_z    jmp     #_sbc_dec

                getbyte _A, t3, #0

                test    _A, #$FF        wz  ' affects Z
        _ret_   bitz    _P, #REGP_Z         ' |

_sbc_dec        mov     t2, _A              ' t2 = lo
                and     t2, #$0F
                mov     t4, t1
                and     t4, #$0F
                subx    t2, t4

                mov     t3, _A              ' t3 = hi
                and     t3, #$F0
                mov     t4, t1
                and     t4, #$F0
                sub     t3, t4

                test    t2, #$10        wz
        if_nz   sub     t2, #$06
        if_nz   sub     t3, #$01

                test    t3, #$100       wz
        if_nz   sub     t3, #$60

                getbyte _A, t3, #0
                setnib  _A, t2, #0

                test    _A, #$FF        wz  ' affects Z
        _ret_   bitz    _P, #REGP_Z         ' |

i_sec   _ret_   bith    _P, #REGP_C
i_sed   _ret_   bith    _P, #REGP_D
i_sei   _ret_   bith    _P, #REGP_I

i_st_abs        call    #\_fetch_abs        ' %xxx_11111110
i_st_abs_x      call    #\_fetch_abs_x      ' %xxx_1111110
i_st_abs_y      call    #\_fetch_abs_y      ' %xxx_111110
i_st_zpg        call    #\_fetch_zpg        ' %xxx_11110
i_st_zpg_x      call    #\_fetch_zpg_x      ' %xxx_1110
i_st_zpg_y      call    #\_fetch_zpg_y      ' %xxx_110
i_st_ind_x      call    #\_fetch_ind_x      ' %xxx_10
i_st_ind_y      call    #\_fetch_ind_y      ' %xxx_0
_st             mov     t1, _A              '  110 A
                mov     t1, _X              '  101 X
                mov     t1, _Y              '  011 Y
                jmp     #\_write
                                            ' TAX TAY TSX TXA TXS TYA
i_taxya         getbyte t1, _A, #0          '  0   0   1   1   1   1
                getbyte t1, _X, #0          '  1   1   1   0   0   1
                getbyte t1, _Y, #0          '  1   1   1   1   1   0
                getbyte t1, _S, #0          '  1   1   0   1   1   1
                getbyte _A, t1, #0          '  1   1   1   0   1   0
                getbyte _X, t1, #0          '  0   1   0   1   1   1
                getbyte _Y, t1, #0          '  1   0   1   1   1   1
                getbyte _S, t1, #0          '  1   1   1   1   0   1
                jmp     #\_flags            '                  1
                ret

i_alr           push    #.ret
                execf   ##(%110_0 << 10) | i_log_imm
.ret            execf   ##(%10_00_0 << 10) | i_lsr

i_anc           push    #.ret
                execf   ##(%110_0 << 10) | i_log_imm
.ret            testb   _A, #0          wc
        _ret_   bitc    _P, #REGP_C

i_arr           push    #.ret
                execf   ##(%110_0 << 10) | i_log_imm
.ret            execf   ##(%10_00000_0 << 10) | i_ror

'
'
' Common subroutines
'
_flags          test    t1, #$FF       wz   ' affects Z
                bitz    _P, #REGP_Z         ' |
                testb   t1, #7         wz   ' affects N
        _ret_   bitz    _P, #REGP_N         ' |

_fetch_abs      rdword  t2, ptrb++
                jmp     #\_read

_fetch_abs_x    rdword  t2, ptrb++

                getbyte t3, t2, #0
                add     t3, _X
                cmp     t3, #$100       wc  ' page boundary
        if_nc   add     _I, #1              ' add 1 cycle

                add     t2, _X
                jmp     #\_read

_fetch_abs_y    rdword  t2, ptrb++

                getbyte t3, t2, #0
                add     t3, _Y
                cmp     t3, #$100       wc  ' page boundary
        if_nc   add     _I, #1              ' add 1 cycle

                add     t2, _Y
                jmp     #\_read

_fetch_zpg      rdbyte  t2, ptrb++
                jmp     #\_read

_fetch_zpg_x    rdbyte  t2, ptrb++
                add     t2, _X
                and     t2, #$FF
                jmp     #\_read

_fetch_zpg_y    rdbyte  t2, ptrb++
                add     t2, _Y
                and     t2, #$FF
                jmp     #\_read

_fetch_ind_x    rdbyte  t3, ptrb++
                add     t3, _X
                getbyte t4, t3, #0
                add     t4, ram_addr
                rdbyte  t2, t4
                add     t3, #1
                getbyte t4, t3, #0
                add     t4, ram_addr
                rdbyte  t1, t4
                setbyte t2, t1, #1
                jmp     #\_read

_fetch_ind_y    rdbyte  t3, ptrb++

                getbyte t4, t3, #0
                add     t4, ram_addr
                rdbyte  t2, t4              ' t2 = low
                add     t3, #1

                getbyte t4, t3, #0
                add     t4, ram_addr
                rdbyte  t1, t4              ' t1 = high

                add     t2, _Y
                cmp     t2, #$100       wc  ' page boundary
        if_nc   add     _I, #1              ' add 1 cycle

                shl     t1, #8
                add     t2, t1
                and     t2, ##$FFFF
                jmp     #\_read

_push_t1        getbyte t2, _S, #0
                add     t2, #$100
                add     t2, ram_addr
                wrbyte  t1, t2
        _ret_   decmod  _S, #$FF

_pop_t1         incmod  _S, #$FF
                getbyte t2, _S, #0
                add     t2, #$100
                add     t2, ram_addr
        _ret_   rdbyte  t1, t2

' 0000-1FFF RAM
' A000-BFFF BASIC ROM
' D000-D3FF VIDEO RAM
' DC00-DFFF KEYBOARD I/O
' F000-F001 ACIA (CASSETTE)
' F800-FFFF MONITOR ROM

_read           ' t1 = data
                ' t2 = address
                getbyte t5, t2, #1
                cmp     t5, #$F0         wz ' ACIA (serial/cassette) F000-F001       11110000 0000000x
        if_e    jmp     #acia_read
                and     t5, #%111111_00
                cmp     t5, #%110111_00  wz ' Keyboard               DC00-DFFF       110111xx xxxxxxxx
        if_e    jmp     #keyboard_read
                cmp     t5, #%110100_00  wz ' Display RAM (1K)       D000-D3FF       110100xx xxxxxxxx
        if_e    jmp     #.ok
                and     t5, #%11111_000
                cmp     t5, #%11111_000  wz ' Monitor ROM (2K)       F800-FFFF       11111xxx xxxxxxxx
        if_e    jmp     #.ok
                and     t5, #%111_00000
                cmp     t5, #%0000_0000  wz ' Program RAM (8K)       0000-0FFF       000xxxxx xxxxxxxx
        if_e    jmp     #.ok
                cmp     t5, #%101_00000  wz ' BASIC ROM (8K)         A000-BFFF       101xxxxx xxxxxxxx
        if_e    jmp     #.ok
        _ret_   mov     t1, #$FF

.ok             getword t5, t2, #0
                add     t5, ram_addr
        _ret_   rdbyte  t1, t5

_write          ' t1 = data
                ' t2 = address
                getbyte t5, t2, #1
                cmp     t5, #$F0         wz ' ACIA (serial/cassette) F000-F001       11110000 0000000x
        if_e    jmp     #acia_write
                and     t5, #%111111_00
                cmp     t5, #%110111_00  wz ' Keyboard               DC00-DFFF       110111xx xxxxxxxx
        if_e    jmp     #keyboard_write
                cmp     t5, #%110100_00  wz ' Display RAM (1K)       D000-D3FF       110100xx xxxxxxxx
        if_e    jmp     #.ok
                and     t5, #%111_00000
                cmp     t5, #%0000_0000  wz ' Program RAM (8K)       0000-0FFF       000xxxxx xxxxxxxx
        if_e    jmp     #.ok
                ret

.ok             getword t5, t2, #0
                add     t5, ram_addr
        _ret_   wrbyte  t1, t5
                ret

'
'
' Initialized
'
ram_addr        long    ram_6502

'
'
' CPU Registers
'
_A              long    $00     ' 8-bit working registers
_X              long    $00
_Y              long    $00

_S              long    $FF     ' 8-bit stack pointer

_P              long    $20     ' 8-bit flag register
                                '   7 = N - negative
                                '   6 = V - overflow
                                '   5 = ?
                                '   4 = B - break
                                '   3 = D - decimal
                                '   2 = I - interrupt
                                '   1 = Z - zero
                                '   0 = C - carry

_PC             long    $0000   ' 16-bit program counter

_T              long    0       ' total cycles
_I              long    0       ' instruction cycles
_I_CLK          long    _CLKFREQ / 1_000_000 ' effective cycle frequency

'
'
' UK101 Peripherals

keyboard_row    long    $00

acia_rxr        long    $00[2]
acia_txr        long    $00[2]

acia_clk        long    _CLKFREQ / ACIA_BAUD
acia_clk2       long   (_CLKFREQ / ACIA_BAUD) / 2
acia_clk16      long   (_CLKFREQ / ACIA_BAUD) / 16

acia_tx_ct      long    0
acia_rx_ct      long    0

'
'
' Temporaries
'
t1              res     1
t2              res     1
t3              res     1
t4              res     1
t5              res     1

ts              res     1

                fit     $1F0

DAT             ' 6502 LUT resident code
                org     $200, $3F0

lut_6502
'
' instruction         snippet                  skip pattern         cycles    encoding
'--------------------------------------------------------------------------------------------
                long  i_brk       |                      %0 << 10 | 7 << 28 ' 00 BRK
                long  i_log_ind_x |              %011_1_110 << 10 | 2 << 28 ' 01 ORA ($nn,X)
                long  i_jam       |                      %0 << 10 | 2 << 28 ' 02 *JAM
                long  i_aso_ind_x |                   %0_10 << 10 | 8 << 28 ' 03 *ASO ($nn,X)
                long  i_nop_zpg   |                    %110 << 10 | 3 << 28 ' 04 *NOP
                long  i_log_zpg   |           %011_1_111110 << 10 | 3 << 28 ' 05 ORA $nn
                long  i_asl_zpg   |           %01_000_1_110 << 10 | 5 << 28 ' 06 ASL $nn
                long  i_aso_zpg   |                 %0_1110 << 10 | 5 << 28 ' 07 *ASO $nn
                long  i_push      |                     %01 << 10 | 3 << 28 ' 08 PHP
                long  i_log_imm   |                  %011_0 << 10 | 2 << 28 ' 09 ORA #$nn
                long  i_asl       |               %10_000_0 << 10 | 2 << 28 ' 0A ASL
                long  i_anc       |                      %0 << 10 | 2 << 28 ' 0B *ANC #$nn
                long  i_nop_abs   |                  %11110 << 10 | 4 << 28 ' 0C *NOP
                long  i_log_abs   |          %011_1_1111110 << 10 | 4 << 28 ' 0D ORA $nnnn
                long  i_asl_abs   |          %01_000_1_1110 << 10 | 6 << 28 ' 0E ASL $nnnn
                long  i_aso_abs   |              %0_1111110 << 10 | 6 << 28 ' 0F *ASO $nnnn

                long  i_branch    |              %10_0111_0 << 10 | 3 << 28 ' 10 BPL $nn
                long  i_log_ind_y |               %011_1_10 << 10 | 2 << 28 ' 11 ORA ($nn),Y
                long  i_jam       |                      %0 << 10 | 2 << 28 ' 12 *JAM
                long  i_aso_ind_y |                    %0_0 << 10 | 8 << 28 ' 13 *ASO ($nn),Y
                long  i_nop_zpg_x |                     %10 << 10 | 4 << 28 ' 14 *NOP
                long  i_log_zpg_x |                %011_1_0 << 10 | 2 << 28 ' 15 ORA $nn,X
                long  i_asl_zpg_x |             %01_000_1_0 << 10 | 6 << 28 ' 16 ASL $nn,X
                long  i_aso_zpg_x |                  %0_110 << 10 | 6 << 28 ' 17 *ASO $nn,X
                long  i_clc       |                      %0 << 10 | 2 << 28 ' 18 CLC
                long  i_log_abs_y |             %011_1_1110 << 10 | 2 << 28 ' 19 ORA $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' 1A *NOP
                long  i_aso_abs_y |                %0_11110 << 10 | 7 << 28 ' 1B *ASO $nnnn,Y
                long  i_nop_abs_x |                   %1110 << 10 | 4 << 28 ' 1C *NOP
                long  i_log_abs_x |            %011_1_11110 << 10 | 2 << 28 ' 1D ORA $nnnn,X
                long  i_asl_abs_x |            %01_000_1_10 << 10 | 7 << 28 ' 1E ASL $nnnn,X
                long  i_aso_abs_x |               %0_111110 << 10 | 7 << 28 ' 1F *ASO $nnnn,X

                long  i_jsr       |                      %0 << 10 | 6 << 28 ' 20 JSR $nn
                long  i_log_ind_x |              %110_1_110 << 10 | 6 << 28 ' 21 AND ($nn,X)
                long  i_jam       |                      %0 << 10 | 2 << 28 ' 22 *JAM
                long  i_rla_ind_x |                   %0_10 << 10 | 8 << 28 ' 23 *RLA ($nn,X)
                long  i_bit_zpg   |                      %0 << 10 | 3 << 28 ' 24 BIT $nn
                long  i_log_zpg   |           %110_1_111110 << 10 | 3 << 28 ' 25 AND $nn
                long  i_rol_zpg   |         %01_00000_1_110 << 10 | 5 << 28 ' 26 ROL $nn
                long  i_rla_zpg   |                 %0_1110 << 10 | 5 << 28 ' 27 *RLA $nn
                long  i_plp       |                      %0 << 10 | 4 << 28 ' 28 PLP
                long  i_log_imm   |                  %110_0 << 10 | 2 << 28 ' 29 AND #$nn
                long  i_rol       |             %10_00000_0 << 10 | 2 << 28 ' 2A ROL
                long  i_anc       |                      %0 << 10 | 2 << 28 ' 2B *ANC #$nn
                long  i_bit_abs   |                     %10 << 10 | 4 << 28 ' 2C BIT $nnnn
                long  i_log_abs   |          %110_1_1111110 << 10 | 4 << 28 ' 2D AND $nnnn
                long  i_rol_abs   |        %01_00000_1_1110 << 10 | 4 << 28 ' 2E ROL $nnnn
                long  i_rla_abs   |              %0_1111110 << 10 | 6 << 28 ' 2F *RLA $nnnn

                long  i_branch    |              %01_0111_0 << 10 | 3 << 28 ' 30 BMI $nn
                long  i_log_ind_y |               %110_1_10 << 10 | 5 << 28 ' 31 AND ($nn),Y
                long  i_jam       |                      %0 << 10 | 2 << 28 ' 32 *JAM
                long  i_rla_ind_y |                    %0_0 << 10 | 8 << 28 ' 33 *RLA ($nn),Y
                long  i_nop_zpg_x |                     %10 << 10 | 4 << 28 ' 34 *NOP
                long  i_log_zpg_x |                %110_1_0 << 10 | 4 << 28 ' 35 AND $nn,X
                long  i_rol_zpg_x |           %01_00000_1_0 << 10 | 6 << 28 ' 36 ROL $nn,X
                long  i_rla_zpg_x |                  %0_110 << 10 | 6 << 28 ' 37 *RLA $nn,X
                long  i_sec       |                      %0 << 10 | 2 << 28 ' 38 SEC
                long  i_log_abs_y |             %110_1_1110 << 10 | 4 << 28 ' 39 AND $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' 3A *NOP
                long  i_rla_abs_y |                %0_11110 << 10 | 7 << 28 ' 3B *RLA $nnnn,Y
                long  i_nop_abs_x |                   %1110 << 10 | 4 << 28 ' 3C *NOP
                long  i_log_abs_x |            %110_1_11110 << 10 | 4 << 28 ' 3D AND $nnnn,X
                long  i_rol_abs_x |          %01_00000_1_10 << 10 | 7 << 28 ' 3E ROL $nnnn,X
                long  i_rla_abs_x |               %0_111110 << 10 | 7 << 28 ' 3F *RLA $nnnn,X

                long  i_rti       |               %11000000 << 10 | 6 << 28 ' 40 RTI
                long  i_log_ind_x |              %101_1_110 << 10 | 2 << 28 ' 41 EOR ($nn,X)
                long  i_jam       |                      %0 << 10 | 2 << 28 ' 42 *JAM
                long  i_sre_ind_x |                   %0_10 << 10 | 8 << 28 ' 43 *SRE ($nn,X)
                long  i_nop_zpg   |                    %110 << 10 | 3 << 28 ' 44 *NOP
                long  i_log_zpg   |           %101_1_111110 << 10 | 3 << 28 ' 45 EOR $nn
                long  i_lsr_zpg   |            %01_00_1_110 << 10 | 2 << 28 ' 46 LSR $nn
                long  i_sre_zpg   |                 %0_1110 << 10 | 5 << 28 ' 47 *SRE $nn
                long  i_push      |                     %10 << 10 | 3 << 28 ' 48 PHA
                long  i_log_imm   |                  %101_0 << 10 | 2 << 28 ' 49 EOR #$nn
                long  i_lsr       |                %10_00_0 << 10 | 2 << 28 ' 4A LSR
                long  i_alr       |                      %0 << 10 | 2 << 28 ' 4B *ALR #$nn
                long  i_jmp       |                   %0110 << 10 | 3 << 28 ' 4C JMP $nnnn
                long  i_log_abs   |          %101_1_1111110 << 10 | 4 << 28 ' 4D EOR $nnnn
                long  i_lsr_abs   |           %01_00_1_1110 << 10 | 6 << 28 ' 4E LSR $nnnn
                long  i_sre_abs   |              %0_1111110 << 10 | 6 << 28 ' 4F *SRE $nnnn

                long  i_branch    |              %10_1011_0 << 10 | 3 << 28 ' 50 BVC $nn
                long  i_log_ind_y |               %101_1_10 << 10 | 2 << 28 ' 51 EOR ($nn),Y
                long  i_jam       |                      %0 << 10 | 2 << 28 ' 52 *JAM
                long  i_sre_ind_y |                    %0_0 << 10 | 8 << 28 ' 53 *SRE ($nn),Y
                long  i_nop_zpg_x |                     %10 << 10 | 4 << 28 ' 54 *NOP
                long  i_log_zpg_x |                %101_1_0 << 10 | 2 << 28 ' 55 EOR $nn,X
                long  i_lsr_zpg_x |              %01_00_1_0 << 10 | 6 << 28 ' 56 LSR $nn,X
                long  i_sre_zpg_x |                  %0_110 << 10 | 6 << 28 ' 57 *SRE $nn,X
                long  i_cli       |                      %0 << 10 | 2 << 28 ' 58 CLI
                long  i_log_abs_y |             %101_1_1110 << 10 | 2 << 28 ' 59 EOR $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' 5A *NOP
                long  i_sre_abs_y |                %0_11110 << 10 | 7 << 28 ' 5B *SRE $nnnn,Y
                long  i_nop_abs_x |                   %1110 << 10 | 4 << 28 ' 5C *NOP
                long  i_log_abs_x |            %101_1_11110 << 10 | 2 << 28 ' 5D EOR $nnnn,X
                long  i_lsr_abs_x |             %01_00_1_10 << 10 | 7 << 28 ' 5E LSR $nnnn,X
                long  i_sre_abs_x |               %0_111110 << 10 | 7 << 28 ' 5F *SRE $nnnn,X

                long  i_rts       |                      %0 << 10 | 6 << 28 ' 60 RTS
                long  i_adc_ind_x |                 %1_1110 << 10 | 6 << 28 ' 61 ADC ($nn,X)
                long  i_jam       |                      %0 << 10 | 2 << 28 ' 62 *JAM
                long  i_rra_ind_x |                   %0_10 << 10 | 8 << 28 ' 63 *RRA ($nn,X)
                long  i_nop_zpg   |                    %110 << 10 | 3 << 28 ' 64 *NOP
                long  i_adc_zpg   |                   %1_10 << 10 | 3 << 28 ' 65 ADC $nn
                long  i_ror_zpg   |         %01_00000_1_110 << 10 | 5 << 28 ' 66 ROR $nn
                long  i_rra_zpg   |                 %0_1110 << 10 | 5 << 28 ' 67 *RRA $nn
                long  i_pla       |                      %0 << 10 | 4 << 28 ' 68 PLA
                long  i_adc_imm   |                      %0 << 10 | 2 << 28 ' 69 ADC #$nn
                long  i_ror       |             %10_00000_0 << 10 | 2 << 28 ' 6A ROR
                long  i_arr       |                      %0 << 10 | 2 << 28 ' 6B *ARR #$nn
                long  i_jmp       |                   %0000 << 10 | 5 << 28 ' 6C JMP ($nnnn)
                long  i_adc_abs   |              %1_1111110 << 10 | 4 << 28 ' 6D ADC $nnnn
                long  i_ror_abs   |        %01_00000_1_1110 << 10 | 6 << 28 ' 6E ROR $nnnn
                long  i_rra_abs   |              %0_1111110 << 10 | 6 << 28 ' 6F *RRA $nnnn

                long  i_branch    |              %01_1011_0 << 10 | 3 << 28 ' 70 BVS $nn
                long  i_adc_ind_y |                  %1_110 << 10 | 5 << 28 ' 71 ADC ($nn),Y
                long  i_jam       |                      %0 << 10 | 2 << 28 ' 72 *JAM
                long  i_rra_ind_y |                    %0_0 << 10 | 8 << 28 ' 73 *RRA ($nn),Y
                long  i_nop_zpg_x |                     %10 << 10 | 4 << 28 ' 74 *NOP
                long  i_adc_zpg_x |                    %1_0 << 10 | 4 << 28 ' 75 ADC $nn,X
                long  i_ror_zpg_x |           %01_00000_1_0 << 10 | 6 << 28 ' 76 ROR $nn,X
                long  i_rra_zpg_x |                  %0_110 << 10 | 6 << 28 ' 77 *RRA $nn,X
                long  i_sei       |                      %0 << 10 | 2 << 28 ' 78 SEI
                long  i_adc_abs_y |                %1_11110 << 10 | 4 << 28 ' 79 AND $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' 7A *NOP
                long  i_rra_abs_y |               %0_111110 << 10 | 7 << 28 ' 7B *RRA $nnnn,Y
                long  i_nop_abs_x |                   %1110 << 10 | 4 << 28 ' 7C *NOP
                long  i_adc_abs_x |               %1_111110 << 10 | 4 << 28 ' 7D ADC $nnnn,X
                long  i_ror_abs_x |          %01_00000_1_10 << 10 | 7 << 28 ' 7E ROR $nnnn,X
                long  i_rra_abs_x |               %0_111110 << 10 | 7 << 28 ' 7F *RRA $nnnn,X

                long  i_nop_imm   |                      %0 << 10 | 2 << 28 ' 80 *NOP
                long  i_st_ind_x  |                 %110_10 << 10 | 6 << 28 ' 81 STA ($nn,X)
                long  i_nop_imm   |                      %0 << 10 | 2 << 28 ' 82 *NOP
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 83
                long  i_st_zpg    |              %011_11110 << 10 | 3 << 28 ' 84 STY $nn
                long  i_st_zpg    |              %110_11110 << 10 | 3 << 28 ' 85 STA $nn
                long  i_st_zpg    |              %101_11110 << 10 | 3 << 28 ' 86 STX $nn
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 87
                long  i_inde_xy   |               %01_01_01 << 10 | 2 << 28 ' 88 DEY
                long  i_nop_imm   |                      %0 << 10 | 2 << 28 ' 89 *NOP
                long  i_taxya     |              %1110_1101 << 10 | 2 << 28 ' 8A TXA
                long  i_ane       |                      %0 << 10 | 2 << 28 ' 8B *ANE #$nn
                long  i_st_abs    |           %011_11111110 << 10 | 4 << 28 ' 8C STY $nnnn
                long  i_st_abs    |           %110_11111110 << 10 | 4 << 28 ' 8D STA $nnnn
                long  i_st_abs    |           %101_11111110 << 10 | 4 << 28 ' 8E STX $nnnn
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 8F

                long  i_branch    |              %10_1110_0 << 10 | 3 << 28 ' 90 BCC $nn
                long  i_st_ind_y  |                  %110_0 << 10 | 6 << 28 ' 91 STA ($nn),Y
                long  i_jam       |                      %0 << 10 | 2 << 28 ' 92 *JAM
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 93
                long  i_st_zpg_x  |               %011_1110 << 10 | 4 << 28 ' 94 STY $nn,X
                long  i_st_zpg_x  |               %110_1110 << 10 | 4 << 28 ' 95 STA $nn,X
                long  i_st_zpg_y  |                %101_110 << 10 | 4 << 28 ' 96 STX $nn,Y
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 97
                long  i_taxya     |              %1110_1011 << 10 | 2 << 28 ' 98 TYA
                long  i_st_abs_y  |             %110_111110 << 10 | 5 << 28 ' 99 STA $nnnn,Y
                long  i_taxya     |            %1_0111_1101 << 10 | 2 << 28 ' 9A TXS
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 9B
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 9C
                long  i_st_abs_x  |            %110_1111110 << 10 | 5 << 28 ' 9D STA $nnnn,X
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 9E
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 9F

                long  i_ld_imm    |                  %011_0 << 10 | 2 << 28 ' A0 LDY #nn
                long  i_ld_ind_x  |               %110_1_10 << 10 | 6 << 28 ' A1 LDA ($nn,X)
                long  i_ld_imm    |                  %101_0 << 10 | 2 << 28 ' A2 LDX #nn
                long  i_ld_ind_x  |               %100_1_10 << 10 | 2 << 28 ' A3 *LAX ($nn,X)
                long  i_ld_zpg    |            %011_1_11110 << 10 | 3 << 28 ' A4 LDY zpg
                long  i_ld_zpg    |            %110_1_11110 << 10 | 3 << 28 ' A5 LDA zpg
                long  i_ld_zpg    |            %101_1_11110 << 10 | 3 << 28 ' A6 LDX zpg
                long  i_ld_zpg    |            %100_1_11110 << 10 | 2 << 28 ' A7 *LAX zpg
                long  i_taxya     |              %1011_1110 << 10 | 2 << 28 ' A8 TAY
                long  i_ld_imm    |                  %110_0 << 10 | 2 << 28 ' A9 LDA #nn
                long  i_taxya     |              %1101_1110 << 10 | 2 << 28 ' AA TAX
                long  i_ld_imm    |                  %100_0 << 10 | 2 << 28 ' AB *LXA #nn
                long  i_ld_abs    |         %011_1_11111110 << 10 | 4 << 28 ' AC LDY nnnn
                long  i_ld_abs    |         %110_1_11111110 << 10 | 4 << 28 ' AD LDA nnnn
                long  i_ld_abs    |         %101_1_11111110 << 10 | 4 << 28 ' AE LDX nnnn
                long  i_ld_abs    |         %100_1_11111110 << 10 | 2 << 28 ' AF *LAX nnnn

                long  i_branch    |              %01_1110_0 << 10 | 3 << 28 ' B0 BCS $nn
                long  i_ld_ind_y  |                %110_1_0 << 10 | 5 << 28 ' B1 LDA ($nn),Y
                long  i_jam       |                      %0 << 10 | 2 << 28 ' B2 *JAM
                long  i_ld_ind_y  |                %100_1_0 << 10 | 2 << 28 ' B3 *LAX ($nn),Y
                long  i_ld_zpg_x  |             %011_1_1110 << 10 | 4 << 28 ' B4 LDY $nn,Y
                long  i_ld_zpg_x  |             %110_1_1110 << 10 | 4 << 28 ' B5 LDA $nn,X
                long  i_ld_zpg_y  |              %101_1_110 << 10 | 4 << 28 ' B6 LDX $nn,Y
                long  i_ld_zpg_x  |             %100_1_1110 << 10 | 2 << 28 ' B7 *LAX $nn,X
                long  i_clv       |                      %0 << 10 | 2 << 28 ' B8 CLV
                long  i_ld_abs_y  |           %110_1_111110 << 10 | 4 << 28 ' B9 LDA $nnnn,Y
                long  i_taxya     |              %1101_0111 << 10 | 2 << 28 ' BA TSX
                long  i_halt      |                      %0 << 10 | 2 << 28 ' BB
                long  i_ld_abs_x  |          %011_1_1111110 << 10 | 4 << 28 ' BC LDY $nnnn,X
                long  i_ld_abs_x  |          %110_1_1111110 << 10 | 4 << 28 ' BD LDA $nnnn,X
                long  i_ld_abs_y  |           %101_1_111110 << 10 | 4 << 28 ' BE LDX $nnnn,Y
                long  i_ld_abs_x  |          %100_1_1111110 << 10 | 2 << 28 ' BF *LAX $nnnn,X

                long  i_cmp_imm   |                 %011_00 << 10 | 2 << 28 ' C0 CPY #$nn
                long  i_cmp_ind_x |           %110_0_1_1110 << 10 | 6 << 28 ' C1 CMP ($nn,X)
                long  i_nop_imm   |                      %0 << 10 | 2 << 28 ' C2 *NOP
                long  i_halt      |                      %0 << 10 | 2 << 28 ' C3
                long  i_cmp_zpg   |             %011_0_1_10 << 10 | 3 << 28 ' C4 CPY $nn
                long  i_cmp_zpg   |             %110_0_1_10 << 10 | 3 << 28 ' C5 CMP $nn
                long  i_dec_zpg   |                %10_1110 << 10 | 5 << 28 ' C6 DEC $nn
                long  i_halt      |                      %0 << 10 | 2 << 28 ' C7
                long  i_inde_xy   |               %01_10_01 << 10 | 2 << 28 ' C8 INY
                long  i_cmp_imm   |                 %110_00 << 10 | 2 << 28 ' C9 CMP #$nn
                long  i_inde_xy   |               %10_01_10 << 10 | 2 << 28 ' CA DEX
                long  i_axs       |                      %0 << 10 | 2 << 28 ' CB *AXS #$nn
                long  i_cmp_abs   |        %011_0_1_1111110 << 10 | 4 << 28 ' CC CPY $nnnn
                long  i_cmp_abs   |        %110_0_1_1111110 << 10 | 4 << 28 ' CD CMP $nnnn
                long  i_dec_abs   |                   %10_0 << 10 | 6 << 28 ' CE DEC $nnnn
                long  i_halt      |                      %0 << 10 | 2 << 28 ' CF

                long  i_branch    |              %10_1101_0 << 10 | 3 << 28 ' D0 BNE $mm
                long  i_cmp_ind_y |            %110_0_1_110 << 10 | 2 << 28 ' D1 CMP ($nn),Y
                long  i_jam       |                      %0 << 10 | 2 << 28 ' D2 *JAM
                long  i_halt      |                      %0 << 10 | 2 << 28 ' D3
                long  i_nop_zpg_x |                     %10 << 10 | 4 << 28 ' D4 *NOP
                long  i_cmp_zpg_x |              %110_0_1_0 << 10 | 2 << 28 ' D5 CMP $nn,X
                long  i_dec_zpg_x |                  %10_10 << 10 | 6 << 28 ' D6 DEC $nn,X
                long  i_halt      |                      %0 << 10 | 2 << 28 ' D7
                long  i_cld       |                      %0 << 10 | 2 << 28 ' D8 CLD
                long  i_cmp_abs_y |          %110_0_1_11110 << 10 | 4 << 28 ' D9 CMP $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' DA *NOP
                long  i_halt      |                      %0 << 10 | 2 << 28 ' DB
                long  i_nop_abs_x |                   %1110 << 10 | 4 << 28 ' DC *NOP
                long  i_cmp_abs_x |         %110_0_1_111110 << 10 | 4 << 28 ' DD CMP $nnnn,X
                long  i_dec_abs_x |                 %10_110 << 10 | 7 << 28 ' DE DEC $nnnn,X
                long  i_halt      |                      %0 << 10 | 2 << 28 ' DF

                long  i_cmp_imm   |                 %101_00 << 10 | 2 << 28 ' E0 CPX #$nn
                long  i_sbc_ind_x |                 %1_1110 << 10 | 6 << 28 ' E1 SBC ($nn,X)
                long  i_nop_imm   |                      %0 << 10 | 2 << 28 ' E2 *NOP
                long  i_halt      |                      %0 << 10 | 2 << 28 ' E3
                long  i_cmp_zpg   |             %101_0_1_10 << 10 | 3 << 28 ' E4 CPX $nn
                long  i_sbc_zpg   |                   %1_10 << 10 | 3 << 28 ' E5 SBC #$nn
                long  i_dec_zpg   |                %01_1110 << 10 | 5 << 28 ' E6 INC $nn
                long  i_halt      |                      %0 << 10 | 2 << 28 ' E7
                long  i_inde_xy   |               %10_10_10 << 10 | 2 << 28 ' E8 INX
                long  i_sbc_imm   |                      %0 << 10 | 2 << 28 ' E9 SBC #$nn
                long  i_nop       |                      %0 << 10 | 2 << 28 ' EA NOP
                long  i_sbc_imm   |                      %0 << 10 | 2 << 28 ' EB *SBC #$nn
                long  i_cmp_abs   |        %101_0_1_1111110 << 10 | 2 << 28 ' EC CPX $nnnn
                long  i_sbc_abs   |              %1_1111110 << 10 | 4 << 28 ' ED SBC $nnnn
                long  i_dec_abs   |                   %01_0 << 10 | 6 << 28 ' EE INC $nnnn
                long  i_halt      |                      %0 << 10 | 2 << 28 ' EF

                long  i_branch    |              %01_1101_0 << 10 | 3 << 28 ' F0 BEQ $nn
                long  i_sbc_ind_y |                  %1_110 << 10 | 5 << 28 ' F1 SBC ($nn),Y
                long  i_jam       |                      %0 << 10 | 2 << 28 ' F2 *JAM
                long  i_halt      |                      %0 << 10 | 2 << 28 ' F3
                long  i_nop_zpg_x |                     %10 << 10 | 4 << 28 ' F4 *NOP
                long  i_sbc_zpg_x |                    %1_0 << 10 | 4 << 28 ' F5 SBC $nn,X
                long  i_dec_zpg_x |                  %01_10 << 10 | 6 << 28 ' F6 INC $nn,X
                long  i_halt      |                      %0 << 10 | 2 << 28 ' F7
                long  i_sed       |                      %0 << 10 | 2 << 28 ' F8 SED
                long  i_sbc_abs_y |                %1_11110 << 10 | 4 << 28 ' F9 SBC $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' FA *NOP
                long  i_halt      |                      %0 << 10 | 2 << 28 ' FB
                long  i_nop_abs_x |                   %1110 << 10 | 4 << 28 ' FC *NOP
                long  i_sbc_abs_x |               %1_111110 << 10 | 4 << 28 ' FD SBC $nnnn,X
                long  i_dec_abs_x |                 %01_110 << 10 | 7 << 28 ' FE INC $nnnn
                long  i_halt      |                      %0 << 10 | 2 << 28 ' FF

i_jam
i_halt          cogid   t1
                cogstop t1

i_ane           rdbyte  t1, ptrb++
                getbyte t2, _A, #0
                or      t2, #$EF ' Magic constant
                and     t2, _X
                and     t1, t2          wz
        _ret_   bitz    _P, #REGP_Z         ' |

i_sre_abs       call    #\_fetch_abs        ' %0_1111110
i_sre_abs_x     call    #\_fetch_abs_x      ' %0_111110
i_sre_abs_y     call    #\_fetch_abs_y      ' %0_11110
i_sre_zpg       call    #\_fetch_zpg        ' %0_1110
i_sre_zpg_x     call    #\_fetch_zpg_x      ' %0_110
i_sre_ind_x     call    #\_fetch_ind_x      ' %0_10
i_sre_ind_y     call    #\_fetch_ind_y      ' %0_0
                shr     t1, #1          wc
                bitc    _P, #REGP_C
                xor     _A, t1
                call    #\_write
                jmp     #\_flags

i_rla_abs       call    #\_fetch_abs        ' %0_1111110
i_rla_abs_x     call    #\_fetch_abs_x      ' %0_111110
i_rla_abs_y     call    #\_fetch_abs_y      ' %0_11110
i_rla_zpg       call    #\_fetch_zpg        ' %0_1110
i_rla_zpg_x     call    #\_fetch_zpg_x      ' %0_110
i_rla_ind_x     call    #\_fetch_ind_x      ' %0_10
i_rla_ind_y     call    #\_fetch_ind_y      ' %0_0
                testb   _P, #REGP_C     wc
                testb   t1, #7          wz
                shl     t1, #1
                bitc    t1, #0
                bitz    _P, #REGP_C
                and     _A, t1
                call    #\_write
                jmp     #\_flags

i_rra_abs       call    #\_fetch_abs        ' %0_1111110
i_rra_abs_x     call    #\_fetch_abs_x      ' %0_111110
i_rra_abs_y     call    #\_fetch_abs_y      ' %0_11110
i_rra_zpg       call    #\_fetch_zpg        ' %0_1110
i_rra_zpg_x     call    #\_fetch_zpg_x      ' %0_110
i_rra_ind_x     call    #\_fetch_ind_x      ' %0_10
i_rra_ind_y     call    #\_fetch_ind_y      ' %0_0
                testb   _P, #REGP_C     wc
                testb   t1, #0          wz
                shr     t1, #1
                bitc    t1, #7
                bitz    _P, #REGP_C
                call    #\_write
                jmp     #\_adc

i_axs           getbyte t1, _A, #0
                getbyte t2, _X, #0
                and     t1, t2
                rdbyte  t2, ptrb++
                sub     t1, t2
                setbyte _X, t1, #0
                testb   t1, #8          wz
                bitnz   _P, #REGP_C
                jmp     #_flags

i_aso_abs       call    #\_fetch_abs        ' %0_1111110
i_aso_abs_x     call    #\_fetch_abs_x      ' %0_111110
i_aso_abs_y     call    #\_fetch_abs_y      ' %0_11110
i_aso_zpg       call    #\_fetch_zpg        ' %0_1110
i_aso_zpg_x     call    #\_fetch_zpg_x      ' %0_110
i_aso_ind_x     call    #\_fetch_ind_x      ' %0_10
i_aso_ind_y     call    #\_fetch_ind_y      ' %0_0
                testb   t1, #7          wz
                shl     t1, #1
                bitz    _P, #REGP_C
                getbyte t1, t1, #0
                or      _A, t1
                call    #\_write
                jmp     #_flags

'
'
' I/O Routines

io_init
                flth    #ACIA_RX_PIN
                drvh    #ACIA_TX_PIN

                getct   acia_rx_ct
                mov     ijmp2, ##acia_rx_isr
                setint2 #EVENT_CT2
                addct2  acia_rx_ct, acia_clk16

                getct   acia_tx_ct
                mov     ijmp3, ##acia_tx_isr
                setint3 #EVENT_CT3
                addct3  acia_tx_ct, acia_clk

                ret

keyboard_read
                mov     t1, #$FF

                rdlong  t4, #@uk101_keyboard
                testbn  keyboard_row, #0    wz
        if_z    getbyte t3, t4, #0
        if_z    and     t1, t3
                testbn  keyboard_row, #1    wz
        if_z    getbyte t3, t4, #1
        if_z    and     t1, t3
                testbn  keyboard_row, #2    wz
        if_z    getbyte t3, t4, #2
        if_z    and     t1, t3
                testbn  keyboard_row, #3    wz
        if_z    getbyte t3, t4, #3
        if_z    and     t1, t3

                rdlong  t4, #@uk101_keyboard+4
                testbn  keyboard_row, #4    wz
        if_z    getbyte t3, t4, #0
        if_z    and     t1, t3
                testbn  keyboard_row, #5    wz
        if_z    getbyte t3, t4, #1
        if_z    and     t1, t3
                testbn  keyboard_row, #6    wz
        if_z    getbyte t3, t4, #2
        if_z    and     t1, t3
                testbn  keyboard_row, #7    wz
        if_z    getbyte t3, t4, #3
        if_z    and     t1, t3

                ret

keyboard_write
        _ret_   getbyte keyboard_row, t1, #0

acia_rx_isr
                testp   #ACIA_RX_PIN        wc  ' test start bit
        if_c    addct2  acia_rx_ct, acia_clk16  ' no start bit, wait again
        if_nc   addct2  acia_rx_ct, acia_clk2   ' start bit, set half clock timer
        if_nc   mov     ijmp2, ##acia_rx_isr1   '   next stage
                reti2

acia_rx_isr1
                testp   #ACIA_RX_PIN        wc  ' still testing start bit
        if_c    addct2  acia_rx_ct, acia_clk16  ' no start bit
        if_c    mov     ijmp2, ##acia_rx_isr    '   wait again
        if_nc   mov     acia_rxr+1, #%1_00000000 ' still start bit, set shift end flag
        if_nc   addct2  acia_rx_ct, acia_clk    '   set full clock timer
        if_nc   mov     ijmp2, ##acia_rx_isr2   '   bit receive stage
                reti2

acia_rx_isr2
                testp   #ACIA_RX_PIN        wc  ' shift in bit
                rcr     acia_rxr+1, #1      wc  ' | C=1 no more bits
        if_c    shr     acia_rxr+1, #23         ' no more bits, shift byte into position
        if_c    mov     acia_rxr, acia_rxr+1    ' | advance receive register
        if_c    mov     ijmp2, ##acia_rx_isr    ' | reset receive stage
        if_c    addct2  acia_rx_ct, acia_clk16  ' | set clock/16 timer
        if_nc   addct2  acia_rx_ct, acia_clk    ' more bits, set clock timer
                reti2

acia_tx_isr
                cmp     acia_txr+1, #0      wz  ' more bits to send ?
        if_nz   shr     acia_txr+1, #1      wc  ' | shift next bit to C
        if_nz   drvc    #ACIA_TX_PIN            ' | output C
        if_z    mov     acia_txr+1, acia_txr    ' get byte from tx register
        if_z    mov     acia_txr, #0            ' | clear tx register
                addct3  acia_tx_ct, acia_clk    ' set next timer interrupt
                reti3

acia_read
                getbyte t5, t2, #0
                cmp     t5, #$00            wz
        if_z    jmp     #\acia_ctl_rd
                cmp     t5, #$01            wz
        if_z    getbyte t1, acia_rxr, #0
        if_z    mov     acia_rxr, #0
                ret

acia_write
                getbyte t5, t2, #0
                cmp     t5, #$00            wz
        if_z    jmp     #\acia_ctl_wr
                cmp     t5, #$01            wz
        if_z    getbyte t5, t1, #0              ' get byte to shift out
        if_z    or      t5, #%1_00000000        ' insert stop bit
        if_z    shl     t5, #1                  ' insert start bit
        if_z    mov     acia_txr, t5            ' set shift register
                ret

acia_ctl_rd
                mov     t1, #$00
                testb   acia_rxr, #8        wz
                bitz    t1, #0
                testb   acia_txr, #8        wz
                bitnz   t1, #1
                ret

acia_ctl_wr
                ' Ignore ctl write
                ret

                fit     $3FF

CON             ' 6502 constants

    REGP_N = 7
    REGP_V = 6
    REGP_B = 4
    REGP_D = 3
    REGP_I = 2
    REGP_Z = 1
    REGP_C = 0

DAT             ' 6502 Memory Space
                orgh

ram_6502
                orgh    ram_6502 + $A000

basic_rom       file    "BASUK101.ROM"

                orgh    ram_6502 + $D000

video_ram       byte    $00[1024]

                orgh    ram_6502 + $F800

                ' Choose one
monitor_rom     'file    "MONUK01.ROM"
                file    "MONUK02.ROM"
                'file    "CEGMON.ROM"

