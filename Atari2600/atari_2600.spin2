{
    Atari 2600 Emulator
    Copyright (c) 2024 by Marco Maccaferri <macca@maccasoft.com>

    TERMS OF USE: MIT License
}
CON

    _CLKFREQ = 320_000_000
    _NTSC

    VGA_BASE_PIN = 48
    AUDIO_BASE_PIN = 38

    USB_BASE_PIN  = 40
    ACTIVITY_LED  = 57
    ERROR_LED     = 56

    RESET_PIN  = 8
    SELECT_PIN = 9
    LEFT_DIFF  = 10
    RIGHT_DIFF = 11

    VSYNC_LINES   = 3 + 32
    VISIBLE_LINES = 210

    REGP_N = 7
    REGP_V = 6
    REGP_B = 4
    REGP_D = 3
    REGP_I = 2
    REGP_Z = 1
    REGP_C = 0

    UART_RX     = 63 '8  { I }
    UART_TX     = 62 '9  { O }
    UART_BAUD   = 2_000_000

DAT             ' Startup
                org     $000

                asmclk

                wrlong  ##@framebuffer, #@fb_ptr

                coginit #3, ##@usb_host_start ' start USB driver on cog #3
                coginit #2, ##@video_driver   ' start video driver on cog #2
                coginit #1, ##@audio_driver   ' start audio driver on cog #1
                coginit #0, ##@m6507          ' start M6507 on cog #0 (this)

                orgh

fb_ptr          long    0           ' display framebuffer pointer

m6532_ram       byte    $00[128]
m6532_io        long    %00000000_00111111_00000000_11111111
                '        |||||||| |||||||| |||||||| ++++-++++-- (B0) SWCHA
                '        |||||||| |||||||| |||||||| |||| |||+--      (#0) P1 UP
                '        |||||||| |||||||| |||||||| |||| ||+---      (#1) P1 DOWN
                '        |||||||| |||||||| |||||||| |||| |+----      (#2) P1 LEFT
                '        |||||||| |||||||| |||||||| |||| +-----      (#3) P1 RIGHT
                '        |||||||| |||||||| |||||||| |||+-------      (#4) P0 UP
                '        |||||||| |||||||| |||||||| ||+--------      (#5) P0 DOWN
                '        |||||||| |||||||| |||||||| |+---------      (#6) P0 LEFT
                '        |||||||| |||||||| |||||||| +----------      (#7) P0 RIGHT
                '        |||||||| |||||||| ++++++++------------ (B1) SWACNT
                '        |||||||| ++++++++--------------------- (B2) SWCHB
                '        ++++++++------------------------------ (B3) SWBCNT
tia_inpt        long    %00000000_00000000_00000000_00110000
                '                                     |||||+--- (#0) INPT0
                '                                     ||||+---- (#1) INPT1
                '                                     |||+----- (#2) INPT2
                '                                     ||+------ (#3) INPT3
                '                                     |+------- (#4) INPT4 P0 BUTTON
                '                                     +-------- (#5) INPT5 P1 BUTTON
tia_aud0        long    $00_00_00_00
tia_aud1        long    $00_00_00_00
                '           || || ++ (B0) AUDCx
                '           || ++--- (B1) AUDFx
                '           ++------ (B2) AUDVx

DAT             ' M6507
                org     $000

m6507
                add     ptrb, ##@m6507_lut - @m6507
                setq2   #(@m6507_lut_end - @m6507_lut) / 4 -1
                rdlong  0, ptrb

                mov     ea, ##$0FFC         ' read reset vector (atari rom)
                add     ea, rom_addr        ' |
                rdword  _PC, ea             ' |

                wrfast  #0, tia_fb0

.loop           'getct   ct                  ' start counter (debug)

                'mov     _I, #0              ' reset instruction timing (debug)
                call    #\_fetch            ' fetch instruction

                shl     t1, #2              ' decode instruction
                add     t1, i_table         ' |
                rdlong  t1, t1              ' |

                getnib  t2, t1, #7          ' process cycles
.l2             callpa  #3, #_inc_cycles    ' |
                djnz    t2, #.l2            ' |

                setnib  t1, #0, #7

                push    #.resume
                execf   t1                  ' execute instruction

.resume
                bitl    _SYSF, #2       wcz
        if_1x   call    #\i_wsync

                jmp     #.loop

'
'
' System Tasks
'

_inc_cycles
'                add     _I, #1              ' update instruction and total cycles count

                ' M6532
m6532_timer     skipf   m6532_normal    ' ------------+-+

                getbyte r0, _TIMER, #0              ' a b
                decmod  r0, #$FF                    ' | b
                setbyte _TIMER, r0, #0              ' | b

                getword r1, _TIMER, #1              ' a |
                cmpsub  _TC, r1             wc      ' a |
        if_nc   jmp     #_no_timint                 ' a |
                decmod  r0, #$FF            wc      ' a |
                setbyte _TIMER, r0, #0              ' a |
        if_c    bith    _TIMER, #14 addbits 1       ' a | TIMINT
        if_c    setd    m6532_timer, #m6532_timint  ' a |
_no_timint

                ' TIA
tia_clock       skipf   #%0         ' ----------------+
                add     _TC, #1                     ' a

                add     _HC, #3                     ' |
                cmpsub  _HC, #228       wc          ' |
        if_c    add     _VC, #1                     ' |

                cmp     _VC, #VSYNC_LINES    wcz    ' |
        if_ae   cmpr    _VC, #(VSYNC_LINES + VISIBLE_LINES) -1 wcz ' |
        if_ae   setd    tia_clock, #%1111111_0      ' | scanline
                ret     wcz                         ' |

                ' loop counter set to pa
_loop           cmp     _HC, #68        wc      ' horizontal blank
                testb   _SYSF, #1       wz      ' VBLANK
  if_nc_and_z   wfbyte  #$00                    ' |
    if_c_or_z   jmp     #_skip                  ' |

                ' Playfield

tia_pfbl        skipf   tia_pfbl_0  ' ------------+-+-+-+
_colubk         mov     t_pixel, #0-0           ' a b c d   COLUBK (S/B0)

_pfs            testb   t_pf, t_cnt20       wc  ' a b c |
        if_1x   setbyte t_pixel, t_pf_colu, #0  ' a b c |
        if_1x   bith    t_pixel, #29            ' a b c |   signal playfield active

                ' Ball

_bl_res         cmp     _HC, #0-0       wz      ' a | | d   RESBL (S/B0)
        if_nz   jmp     #_no_ball               ' a | | d
                getbyte t_cntb, _SYSF, #1       ' a | | d   BALL SIZE
                setd    tia_pfbl, #tia_bl_draw  ' a | | d

_colubl         setbyte t_pixel, #0-0, #0       ' a b | d
                bith    t_pixel, #24            ' a b | d   signal ball active
                decmod  t_cntb, #0      wc      ' a b | d
        if_c    setd    tia_pfbl, #tia_pfbl_0   ' a b | d
_no_ball

                ' Player 1

tia_p1          skipf   tia_px_a    ' --------------+-+---+

_p1_res_alt     cmp     _HC, #0-0           wz    ' a |   |
        if_e    skipf   #%01_1111_0 ' c ----------- a |-+ |
_p1_size_alt    mov     t_cnt1, #0-0              ' a | c |

_p1_res         cmp     _HC, #0-0           wz    ' a | | e
        if_ne   cmp     _HC, #0-0           wz    ' | | | e
        if_ne   cmp     _HC, #0-0           wz    ' | | | e
        if_ne   jmp     #\_no_p1                  ' a | | e

                mov     t_cnt1, #0                ' a | | e
                mov     t_mask1, t_mask1+1        ' a | c e
                setd    tia_p1, #tia_px_b         ' a | c e

                testb   t_mask1, t_cnt1     wc    ' a b c e
_colup1 if_1x   setbyte t_pixel, #0-0, #0         ' a b c e  COLUP1 (S/B0)
        if_1x   bith    t_pixel, #27              ' a b c e  signal player1 active
                incmod  t_cnt1, t_size1     wc    ' a b c e
        if_c    setd    tia_p1, #tia_px_e         ' a b c e
_no_p1

                ' Missile 1

tia_m1          skipf   #%0         ' ------------+

_m1_res         cmp     _HC, #0-0       wz      ' | RESM1 (S/B0)
                testb   _SYSF, #7       andz    ' | M1 ENABLED
        if_nz   jmp     #_no_m1                 ' |
_m1_size        mov     t_cntm1, #0             ' | MISSILE SIZE (S/B0)
                setd    tia_m1, #%11111         ' |

                setbyte t_pixel, _colup1, #0    ' COLUP1 (S/B0)
                bith    t_pixel, #25            ' signal m1 active
                decmod  t_cntm1, #0     wc      '
        if_c    setd    tia_m1, #0              '
_no_m1

                ' Player 0

tia_p0          skipf   tia_px_a    ' --------------+-+---+

_p0_res_alt     cmp     _HC, #0-0           wz    ' a |   |
        if_e    skipf   #%01_1111_0 ' c ----------- a |-+ |
_p0_size_alt    mov     t_cnt0, #0-0              ' a | c |

_p0_res         cmp     _HC, #0-0           wz    ' a | | e
        if_ne   cmp     _HC, #0-0           wz    ' | | | e
        if_ne   cmp     _HC, #0-0           wz    ' | | | e
        if_ne   jmp     #\_no_p0                  ' a | | e

                mov     t_cnt0, #0                ' a | | e
                mov     t_mask0, t_mask0+1        ' a | c e
                setd    tia_p0, #tia_px_b         ' a | c e

                testb   t_mask0, t_cnt0     wc    ' a b c e
_colup0 if_1x   setbyte t_pixel, #0-0, #0         ' a b c e  COLUP0 (S/B0)
        if_1x   bith    t_pixel, #28              ' a b c e  signal player0 active
                incmod  t_cnt0, t_size0     wc    ' a b c e
        if_c    setd    tia_p0, #tia_px_e         ' a b c e
_no_p0

                ' Missile 0

tia_m0          skipf   #%0         ' ------------+

_m0_res         cmp     _HC, #0-0       wz      ' | RESM0 (S/B0)
                testb   _SYSF, #6       andz    ' | M0 ENABLED
        if_nz   jmp     #_no_m0                 ' |
_m0_size        mov     t_cntm0, #0             ' | MISSILE SIZE (S/B0)
                setd    tia_m0, #%11111         ' |

                setbyte t_pixel, _colup0, #0    ' COLUP0 (S/B0)
                bith    t_pixel, #26            ' signal m0 active
                decmod  t_cntm0, #0     wc      '
        if_c    setd    tia_m0, #0              '
_no_m0

                ' Collisions

                getbyte r0, t_pixel, #3         ' update collision latches
                altgw   r0, #_COLL_TBL          ' |
                getword r0                      ' |
                or      _COLL, r0               ' |

                ' Output

                testb   _PF, #26        wc      ' PFP
                testb   t_pixel, #29    andc    ' playfield active
        if_c    alts    _pfs+1                  ' |
        if_c    setbyte t_pixel, 0-0, #0        ' |

                cmp     _HC, #68 + 8    wc
                testb   _SYSF, #16      andc    ' HMOVE hit blank
        if_c    wfbyte  #$00
        if_nc   wfbyte  t_pixel

                incmod  t_cnt4, #4-1        wc
        if_c    incmod  t_cnt20, #20-1      wc
        if_c    bitnot  _pfs, #9                ' toggle left(0)/right(1) playfields
        if_c    bitnot  _pfs+1, #0              ' toggle left(0)/right(1) colors

_skip           incmod  _HC, #228-1     wc
                djnz    pa, #_loop
        if_nc   ret     wcz

                bitl    _SYSF, #17      wcz
                bitc    _SYSF, #16

                mov     t_cnt4, #0
                mov     t_cnt20, #0
                bitl    _pfs, #9                ' toggle left(0)/right(1) playfields
                bitl    _pfs+1, #0              ' toggle left(0)/right(1) colors
                setd    tia_p0, #tia_px_a
                setd    tia_m0, #0
                setd    tia_p1, #tia_px_a
                setd    tia_m1, #0
                setd    tia_pfbl, #tia_pfbl_0

                add     _VC, #1
                cmp     _VC, #(VSYNC_LINES + VISIBLE_LINES)  wcz
        if_ae   setd    tia_clock, #0

                ret     wcz

                orgf    ($ + 1) & !1   ' must be aligned on even address
t_pf            long    %00000000000000000000, %00000000000000000000 ' |
t_pf_colu       long    $00, $00                                     ' |
t_cnt4          long    0
t_cnt20         long    0

t_cntb          long    0
t_cntm1         long    0
t_cntm0         long    0

tia_pfbl_0      long    %1111_1111_000_0 ' a/c (default ball disabled)
tia_bl_draw     long    %0000_1111_000_0 ' b
tia_bl_disable  long    %1111_1111_000_0 ' c (will be muxed to tia_pfbl_0)
tia_pf_disable  long    %0000_0000_111_0 ' d (will be muxed to tia_pfbl_0 and tia_bl_draw)

tia_px_a        long    %00000_000_0110_000
tia_px_b        long    %00000_111_1111_111
tia_px_e        long    %00000_000_0000_111

t_pixel         long    %00000000_0000000000000000_00000000
                '          ||||||                  ++++++++-- COLU
                '          |||||+---------------------------- BL (#24)
                '          ||||+----------------------------- M1 (#25)
                '          |||+------------------------------ M0 (#26)
                '          ||+------------------------------- P1 (#27)
                '          |+-------------------------------- P0 (#28)
                '          +--------------------------------- PF (#29)

t_mask0         long    0[2]
t_mask1         long    0[2]
t_size0         long    0
t_size1         long    0
t_cnt0          long    0
t_cnt1          long    0

m6532_normal    long    %0000000_110 ' a -> 14 clk (no timint) 20 clk (timint)
m6532_timint    long    %1111111_000 ' b -> 10 clk

'
'
' Instructions
'

i_wsync         callpa  #3, #_inc_cycles
                cmp     _HC, #0         wz
        if_nz   jmp     #i_wsync
                ret
                                            '       C NVZC
i_branch        call    #\_fetch            ' BCC: %0_1110_0
                                            ' BCS: %1_1110_0
                                            ' BNE: %0_1101_0
                                            ' BEQ: %1_1101_0
                testb   _P, #REGP_C     wc  ' BPL: %0_0111_0
                testb   _P, #REGP_Z     wc  ' BMI: %1_0111_0
                testb   _P, #REGP_V     wc  ' BVC: %0_1011_0
                testb   _P, #REGP_N     wc  ' BVS: %1_1011_0

                modc    _nc             wc  ' Negate condition

        if_1x   signx   t1, #7
        if_1x   add     _PC, t1
        if_1x   callpa  #3, #_inc_cycles
        _ret_   and     _PC, i_ffff

t_update_p0     testb   _P0, #25        wc  ' VDEL
        if_1x   getbyte t_mask0+1, _P0, #0  ' GRP
        if_0x   getbyte t_mask0+1, _P0, #1  ' GRPd

                testb   _P0, #24        wz  ' REFP
        if_x0   rev     t_mask0+1
        if_x0   shr     t_mask0+1, #24

                getnib  r0, _P0, #4         ' NUSIZ (D2-D0)
                and     r0, #%111

                sets    _p0_res+1, #$FF
                sets    _p0_res+2, #$FF
                sets    _p0_res_alt, #$FF

                setd    .dst, #_p0_res
                altgn   r0, #i_tia_copies
                getnib  r1
                sets    .cnt, r1
                altgb   r0, #i_tia_width
                getbyte r1
                sets    .step, r1

                mov     t_size0, #8

                mov     r1, #5
                cmp     r0, #%101       wz  ' double size player
        if_ne   cmp     r0, #%111       wz  ' quad sized player
        if_e    setword t_mask0+1, t_mask0+1, #1
        if_e    mergew  t_mask0+1
        if_e    mov     t_size0, #16
        if_e    mov     r1, #5+1            ' delayed one extra pixel
                cmp     r0, #%111       wz  ' quad sized player
        if_e    setword t_mask0+1, t_mask0+1, #1
        if_e    mergew  t_mask0+1
        if_e    mov     t_size0, #32

                getbyte r2, t_res_p0o, #0   ' adjust position based on player size
                cmp     r1, r2          wcz ' |
        if_a    add     tia_resp0, #1       ' |
        if_b    sub     tia_resp0, #1       ' |
                setbyte t_res_p0o, r1, #0   ' |

                mov     pa, tia_resp0

.cnt            rep     @.l1, #0-0
.dst            sets    0-0, pa
                add     .dst, i_d1s0
                add     pa, t_size0
                cmpsub  pa, #228        wcz
 if_c_and_nz    sets    _p0_res_alt, #68    ' alt trigger always first pixel
 if_c_and_nz    sets    _p0_size_alt, t_size0
 if_c_and_nz    sub     _p0_size_alt, pa
        if_c    add     pa, #68
.step           add     pa, #0-0
                cmpsub  pa, #228        wc
        if_c    add     pa, #68
.l1

                getbyte r1, _p0_res+1, #0
                getbyte r2, _p0_res+2, #0
                cmp     r2, r1          wcz
        if_b    setbyte _p0_res+1, r2, #0
        if_b    setbyte _p0_res+2, r1, #0

                getbyte r0, _p0_res+0, #0
                getbyte r1, _p0_res+1, #0
                cmp     r1, r0          wcz
        if_b    setbyte _p0_res+0, r1, #0
        if_b    setbyte _p0_res+1, r0, #0

        _ret_   sub     t_size0, #1

t_update_p1     testb   _P1, #25        wc  ' VDEL
        if_1x   getbyte t_mask1+1, _P1, #0  ' GRP
        if_0x   getbyte t_mask1+1, _P1, #1  ' GRPd

                testb   _P1, #24        wz  ' REFP
        if_x0   rev     t_mask1+1
        if_x0   shr     t_mask1+1, #24

                getnib  r0, _P1, #4         ' NUSIZ (D2-D0)
                and     r0, #%111

                sets    _p1_res+1, #$FF
                sets    _p1_res+2, #$FF
                sets    _p1_res_alt, #$FF

                setd    .dst, #_p1_res
                altgn   r0, #i_tia_copies
                getnib  r1
                sets    .cnt, r1
                altgb   r0, #i_tia_width
                getbyte r1
                sets    .step, r1

                mov     t_size1, #8

                mov     r1, #5
                cmp     r0, #%101       wz  ' double size player
        if_ne   cmp     r0, #%111       wz  ' quad sized player
        if_e    setword t_mask1+1, t_mask1+1, #1
        if_e    mergew  t_mask1+1
        if_e    mov     t_size1, #16
        if_e    mov     r1, #5+1            ' delayed one extra pixel
                cmp     r0, #%111       wz  ' quad sized player
        if_e    setword t_mask1+1, t_mask1+1, #1
        if_e    mergew  t_mask1+1
        if_e    mov     t_size1, #32

                getbyte r2, t_res_p1o, #0   ' adjust position based on player size
                cmp     r1, r2          wcz ' |
        if_a    add     tia_resp1, #1       ' |
        if_b    sub     tia_resp1, #1       ' |
                setbyte t_res_p1o, r1, #0   ' |

                mov     pa, tia_resp1

.cnt            rep     @.l1, #0-0
.dst            sets    0-0, pa
                add     .dst, i_d1s0
                add     pa, t_size1
                cmpsub  pa, #228        wcz
 if_c_and_nz    sets    _p1_res_alt, #68    ' alt trigger always first pixel
 if_c_and_nz    sets    _p1_size_alt, t_size1
 if_c_and_nz    sub     _p1_size_alt, pa
        if_c    add     pa, #68
.step           add     pa, #0-0
                cmpsub  pa, #228        wc
        if_c    add     pa, #68
.l1

                getbyte r1, _p1_res+1, #0
                getbyte r2, _p1_res+2, #0
                cmp     r2, r1          wcz
        if_b    setbyte _p1_res+1, r2, #0
        if_b    setbyte _p1_res+2, r1, #0

                getbyte r0, _p1_res+0, #0
                getbyte r1, _p1_res+1, #0
                cmp     r1, r0          wcz
        if_b    setbyte _p1_res+0, r1, #0
        if_b    setbyte _p1_res+1, r0, #0

        _ret_   sub     t_size1, #1

tia_resp0       long    0
tia_resp1       long    0

t_res           getbyte r0, _HC, #0         ' a b c d e
                cmp     r0, #68         wcz ' a b c d e
        if_b    mov     r0, #68 - 2         ' a b c d e
t_res_p0o       add     r0, #5              ' a | | | |
t_res_p1o       add     r0, #5              ' | b | | |
                add     r0, #4              ' | | c d e
                                            '
        _ret_   mov     tia_resp0, r0       ' a | | | |  RESP0:     %0_1100
        _ret_   mov     tia_resp1, r0       '   b | | |  RESP1:    %01_1010
        _ret_   setbyte _m0_res, r0, #0     '     c | |  RESM0:   %011_0110
        _ret_   setbyte _m1_res, r0, #0     '       d |  RESM1:  %0111_0110
        _ret_   setbyte _bl_res, r0, #0     '         e  RESBL: %01111_0110

i_brk           incmod  _PC, i_ffff
                getbyte t1, _PC, #1         ' PCH -> (S)
                call    #_push_t1
                getbyte t1, _PC, #0         ' PCL -> (S)
                call    #_push_t1
                getbyte t1, _P, #0          ' P -> (S)
                bith    t1, #REGP_B         ' B=1
                call    #_push_t1

                bith    _P, #REGP_I         ' I=1

                mov     _PC, ##$FFFE        ' read interrupt vector
                call    #\_fetch2           ' |
        _ret_   getword _PC, t4, #0         ' |

i_cmp_abs       call    #\_fetch_abs        ' %xxx_0_1_1111110
i_cmp_abs_x     call    #\_fetch_abs_x      ' %xxx_0_1_111110
i_cmp_abs_y     call    #\_fetch_abs_y      ' %xxx_0_1_11110
i_cmp_ind_x     call    #\_fetch_ind_x      ' %xxx_0_1_1110
i_cmp_ind_y     call    #\_fetch_ind_y      ' %xxx_0_1_110
i_cmp_zpg       call    #\_fetch_zpg        ' %xxx_0_1_10
i_cmp_zpg_x     call    #\_fetch_zpg_x      ' %xxx_0_1_0
i_cmp_imm       call    #\_fetch            ' %xxx_00
                mov     t2, t1
                getbyte t1, _A, #0          '  110 CMP
                getbyte t1, _X, #0          '  101 CPX
                getbyte t1, _Y, #0          '  011 CPY
                sub     t1, t2
                testb   t1, #8          wz
                bitnz   _P, #REGP_C
                jmp     #_flags

i_dec_zpg       call    #\_fetch_zpg        ' %xx_1110
i_dec_abs_x     call    #\_fetch_abs_x      ' %xx_110
i_dec_zpg_x     call    #\_fetch_zpg_x      ' %xx_10
i_dec_abs       call    #\_fetch_abs        ' %xx_0
                sub     t1, #1              '  10 DEC
                add     t1, #1              '  01 INC
                call    #\_write
                jmp     #_flags

                                            ' INX INY DEX DEY
i_inde_xy       getbyte t1, _X, #0          '  0   1   0   1
                getbyte t1, _Y, #0          '  1   0   1   0
                add     t1, #1              '  0   0   1   1
                sub     t1, #1              '  1   1   0   0
                getbyte _X, t1, #0          '  0   1   0   1
                getbyte _Y, t1, #0          '  1   0   1   0
                jmp     #_flags

i_jmp_imm       call    #\_fetch2
        _ret_   getword _PC, t4, #0

i_jmp_ind       call    #\_fetch2
                getword ea, t4, #0
                call    #\_read
                getbyte _PC, t1, #0
                incmod  ea, i_ffff
                call    #\_read
        _ret_   setbyte _PC, t1, #1

i_jsr           call    #\_fetch2           ' t4 = new PC

                decmod  _PC, i_ffff
                getbyte t1, _PC, #1         ' PCH -> (S)
                call    #_push_t1
                getbyte t1, _PC, #0         ' PCL -> (S)
                call    #_push_t1

        _ret_   getword _PC, t4, #0

i_ld_abs        call    #\_fetch_abs        ' %xxx_1_11111110
i_ld_abs_x      call    #\_fetch_abs_x      ' %xxx_1_1111110
i_ld_abs_y      call    #\_fetch_abs_y      ' %xxx_1_111110
i_ld_zpg        call    #\_fetch_zpg        ' %xxx_1_11110
i_ld_zpg_x      call    #\_fetch_zpg_x      ' %xxx_1_1110
i_ld_zpg_y      call    #\_fetch_zpg_y      ' %xxx_1_110
i_ld_ind_x      call    #\_fetch_ind_x      ' %xxx_1_10
i_ld_ind_y      call    #\_fetch_ind_y      ' %xxx_1_0
i_ld_imm        call    #\_fetch            ' %xxx_0
                mov     _A, t1              '  110 LDA
                mov     _X, t1              '  101 LDX
                mov     _Y, t1              '  011 LDY
                jmp     #_flags

i_lsr_abs       call    #\_fetch_abs        ' %01_00_1_1110
i_lsr_zpg       call    #\_fetch_zpg        ' %01_00_1_110
i_lsr_abs_x     call    #\_fetch_abs_x      ' %01_00_1_10
i_lsr_zpg_x     call    #\_fetch_zpg_x      ' %01_00_1_0
i_lsr           getbyte t1, _A, #0          ' %10_00_0

                shr     t1, #1      wc
                bitc    _P, #REGP_C

                getbyte _A, t1, #0
                call    #\_write
                jmp     #_flags

i_pha           getbyte t1, _A, #0          ' a         PHA: %010
i_php           getbyte t1, _P, #0          ' - b       PHP:  %00
                jmp     #_push_t1           ' a b

i_pop           call    #\_pop_t1           ' a b       PLA: %001100
                getbyte _A, t1, #0          ' a -       PLP: %100010
                getbyte _P, t1, #0          ' - b
                or      _P, #%00110000      ' - b
                nop                         ' a b
                jmp     #_flags             ' a -
                ret

i_jam
i_halt          jmp     #\@i_trap

'
'
' Parameters
'

ram_addr        long    @m6532_ram
rom_addr        long    @cartridge_rom
ppa_addr        long    @m6532_io
aud_addr        long    @tia_aud0

tia_fbp         long    @fb_ptr
tia_fb0         long    @framebuffer
tia_fb1         long    @framebuffer + (160 * VISIBLE_LINES)
tia_inptp       long    @tia_inpt

'
'
' CPU Registers
'
_A              long    $00         ' 8-bit working registers
_X              long    $00
_Y              long    $00

_S              long    $FF         ' 8-bit stack pointer

_P              long    %00110000   ' 8-bit flag register
                        '|||||||+---- 0 = C - carry
                        '||||||+----- 1 = Z - zero
                        '|||||+------ 2 = I - interrupt
                        '||||+------- 3 = D - decimal
                        '|||+-------- 4 = B - break
                        '||+--------- 5 = 1
                        '|+---------- 6 = V - overflow
                        '+----------- 7 = N - negative

_PC             long    $FFFC       ' 16-bit program counter

_I              long    %000000000000000000000000_00000000
                '        |||||||||||||||||||||||| ++++++++-- instruction cycles
                '        ++++++++++++++++++++++++----------- instruction time

_PF             long    %00000000_00000000_00000000_00000000
                '          || ||| |||||||| |||||||| ++++------ (N1) PF0
                '          || ||| |||||||| ++++++++----------- (B1) PF1
                '          || ||| ++++++++-------------------- (B2) PF2
                '          || ||+----------------------------- (#24) CTRLPF REF (D0)
                '          || |+------------------------------ (#25) CTRLPF SCORE (D1)
                '          || +------------------------------- (#26) CTRLPF PFP (D2)
                '          ++--------------------------------- (N7)  CTRLPF BALL SIZE (D5-4) 00=1 01=2 10=4 11=8 (#29,#28)
_P0             long    %00000000_00000000_00000000_00000000
_P1             long    %00000000_00000000_00000000_00000000
                '              ||   || ||| |||||||| ++++++++-- (B0)  GRP: graphics player (D7-0)
                '              ||   || ||| ++++++++----------- (B1)  GRPd
                '              ||   ++-+++-------------------- (B2)  NUSIZ: number-size player-missle (D5-0)
                '              |+----------------------------- (#24) REFP: reflect player (D3)
                '              +------------------------------ (#25) VDELP: vertical delay player (D0)
_HM             long    %00000000_0000_0000_0000_0000_0000_0000
                '                      |||| |||| |||| |||| ++++-- (N0)  HMP0
                '                      |||| |||| |||| ++++------- (N1)  HMP1
                '                      |||| |||| ++++------------ (N2)  HMM0
                '                      |||| ++++----------------- (N3)  HMM1
                '                      ++++---------------------- (N4)  HMBL
_MB             long    %00000000_00000000_00000000_00000000
                '         ||||||| |||||||| |||||||| ++++++++-- (B0)  RESM0
                '         ||||||| |||||||| ++++++++----------- (B1)  RESM1
                '         ||||||| ++++++++-------------------- (B2)  RESBL
                '         ||||||+----------------------------- (#24) ENAM0 (D1)
                '         |||||+------------------------------ (#25) ENAM1 (D1)
                '         ||||+------------------------------- (#26) ENABL (D1)
                '         |||+-------------------------------- (#27) RESMP0 (D1)
                '         ||+--------------------------------- (#28) RESMP1 (D1)
                '         |+---------------------------------- (#29) VDELBL (D0)
                '         +----------------------------------- (#30) ENABLd

_HC             long    0           ' horizontal counter
_VC             long    0           ' vertical (scanline) counter

_COLL           long    %00_00_00_00_00_00_00_00
                '        || || || || || || || ++ D7=(P0,P1); D6=(M0,M1)
                '        || || || || || || ++--- D7=(BL,PF); D6=(unused)
                '        || || || || || ++------ D7=(M1,PF); D6=(M1,BL)
                '        || || || || ++--------- D7=(M0,PF); D6=(M0,BL)
                '        || || || ++------------ D7=(P1,PF); D6=(P1,BL)
                '        || || ++--------------- D7=(P0,PF); D6=(P0,BL)
                '        || ++------------------ D7=(M1,P0); D6=(M1,P1)
                '        ++--------------------- D7=(M0,P1); D6=(M0,P0)

_COLL_TBL
                '        ++--------------------- D7=(M0,P1); D6=(M0,P0)
                '        || ++------------------ D7=(M1,P0); D6=(M1,P1)
                '        || || ++--------------- D7=(P0,PF); D6=(P0,BL)
                '        || || || ++------------ D7=(P1,PF); D6=(P1,BL)
                '        || || || || ++--------- D7=(M0,PF); D6=(M0,BL)
                '        || || || || || ++------ D7=(M1,PF); D6=(M1,BL)
                '        || || || || || || ++--- D7=(BL,PF); D6=(unused)
                '        || || || || || || || ++ D7=(P0,P1); D6=(M0,M1)
                '        || || || || || || || ||        ' PF P0 P1 M0 M1 BL
                word    %00_00_00_00_00_00_00_00        '  0  0  0  0  0  0
                word    %00_00_00_00_00_00_00_00        '  0  0  0  0  0  1
                word    %00_00_00_00_00_00_00_00        '  0  0  0  0  1  0
                word    %00_00_00_00_00_01_00_00        '  0  0  0  0  1  1
                word    %00_00_00_00_00_00_00_00        '  0  0  0  1  0  0
                word    %00_00_00_00_01_00_00_00        '  0  0  0  1  0  1
                word    %00_00_00_00_00_00_00_01        '  0  0  0  1  1  0
                word    %00_00_00_00_01_01_00_01        '  0  0  0  1  1  1
                word    %00_00_00_00_00_00_00_00        '  0  0  1  0  0  0
                word    %00_00_00_01_00_00_00_00        '  0  0  1  0  0  1
                word    %00_01_00_00_00_00_00_00        '  0  0  1  0  1  0
                word    %00_01_00_01_00_01_00_00        '  0  0  1  0  1  1
                word    %10_00_00_00_00_00_00_00        '  0  0  1  1  0  0
                word    %10_00_00_01_01_00_00_00        '  0  0  1  1  0  1
                word    %10_01_00_00_00_00_00_01        '  0  0  1  1  1  0
                word    %10_01_00_01_01_01_00_01        '  0  0  1  1  1  1
                word    %00_00_00_00_00_00_00_00        '  0  1  0  0  0  0
                word    %00_00_01_00_00_00_00_00        '  0  1  0  0  0  1
                word    %00_10_00_00_00_00_00_00        '  0  1  0  0  1  0
                word    %00_10_01_00_00_01_00_00        '  0  1  0  0  1  1
                word    %01_00_00_00_00_00_00_00        '  0  1  0  1  0  0
                word    %01_00_01_00_01_00_00_00        '  0  1  0  1  0  1
                word    %01_10_00_00_00_00_00_01        '  0  1  0  1  1  0
                word    %01_10_01_00_01_01_00_01        '  0  1  0  1  1  1
                word    %00_00_00_00_00_00_00_10        '  0  1  1  0  0  0
                word    %00_00_01_01_00_00_00_10        '  0  1  1  0  0  1
                word    %00_11_00_00_00_00_00_10        '  0  1  1  0  1  0
                word    %00_11_01_01_00_01_00_10        '  0  1  1  0  1  1
                word    %11_00_00_00_00_00_00_10        '  0  1  1  1  0  0
                word    %11_00_01_01_01_00_00_10        '  0  1  1  1  0  1
                word    %11_11_00_00_00_00_00_11        '  0  1  1  1  1  0
                word    %11_11_01_01_01_01_00_11        '  0  1  1  1  1  1
                word    %00_00_00_00_00_00_00_00        '  1  0  0  0  0  0
                word    %00_00_00_00_00_00_10_00        '  1  0  0  0  0  1
                word    %00_00_00_00_00_10_00_00        '  1  0  0  0  1  0
                word    %00_00_00_00_00_11_10_00        '  1  0  0  0  1  1
                word    %00_00_00_00_10_00_00_00        '  1  0  0  1  0  0
                word    %00_00_00_00_11_00_10_00        '  1  0  0  1  0  1
                word    %00_00_00_00_10_10_00_01        '  1  0  0  1  1  0
                word    %00_00_00_00_11_11_10_01        '  1  0  0  1  1  1
                word    %00_00_00_10_00_00_00_00        '  1  0  1  0  0  0
                word    %00_00_00_11_00_00_10_00        '  1  0  1  0  0  1
                word    %00_01_00_10_00_10_00_00        '  1  0  1  0  1  0
                word    %00_01_00_11_00_11_10_00        '  1  0  1  0  1  1
                word    %10_00_00_10_10_00_00_00        '  1  0  1  1  0  0
                word    %10_00_00_11_11_00_10_00        '  1  0  1  1  0  1
                word    %10_01_00_10_10_10_00_01        '  1  0  1  1  1  0
                word    %10_01_00_11_11_11_10_01        '  1  0  1  1  1  1
                word    %00_00_10_00_00_00_00_00        '  1  1  0  0  0  0
                word    %00_00_11_00_00_00_10_00        '  1  1  0  0  0  1
                word    %00_10_10_00_00_10_00_00        '  1  1  0  0  1  0
                word    %00_10_11_00_00_11_10_00        '  1  1  0  0  1  1
                word    %01_00_10_00_10_00_00_00        '  1  1  0  1  0  0
                word    %01_00_11_00_11_00_10_00        '  1  1  0  1  0  1
                word    %01_10_10_00_10_10_00_01        '  1  1  0  1  1  0
                word    %01_10_11_00_11_11_10_01        '  1  1  0  1  1  1
                word    %00_00_10_10_00_00_00_10        '  1  1  1  0  0  0
                word    %00_00_11_11_00_00_10_10        '  1  1  1  0  0  1
                word    %00_11_10_10_00_10_00_10        '  1  1  1  0  1  0
                word    %00_11_11_11_00_11_10_10        '  1  1  1  0  1  1
                word    %11_00_10_10_10_00_00_10        '  1  1  1  1  0  0
                word    %11_00_11_11_11_00_10_10        '  1  1  1  1  0  1
                word    %11_11_10_10_10_10_00_11        '  1  1  1  1  1  0
                word    %11_11_11_11_11_11_10_11        '  1  1  1  1  1  1

_AUD0           long    $00_00_00_00
_AUD1           long    $00_00_00_00
                '           || || ++ (B0) AUDCx
                '           || ++--- (B1) AUDFx
                '           ++------ (B2) AUDVx

'
'
' M6532 Registers
'
_SW             long    %00000000_00111111_00000000_11111111
                '        |||||||| |||||||| |||||||| ++++++++-- (B0) SWCHA
                '        |||||||| |||||||| ++++++++----------- (B1) SWACNT
                '        |||||||| ++++++++-------------------- (B2) SWCHB
                '        ++++++++----------------------------- (B3) SWBCNT
_INPT           long    %00000000_00000000_00000000_00111111
_TIMER          long    %0000000000000000_00000000_00000000 | $0400_00_40
                '        |||||||||||||||| ||       ++++++++--- (B0) INTIM
                '        |||||||||||||||| |+------------------ (#14) INSTAT (TIMINT)
                '        |||||||||||||||| +------------------- (#15) INSTAT (???)
                '        ++++++++++++++++--------------------- (W1)  DIVIDER
_TC             long    0

'
'
' System flags
'
_SYSF           long    %00000000_00000000_00000000_00000000
                '        |                 |||||||| ||   ||+-- (#0)  VSYNC
                '        |                 |||||||| ||   |+--- (#1)  VBLANK
                '        |                 |||||||| ||   +---- (#2)  WSYNC
                '        |                 |||||||| |+-------- (#6)  M0 ENABLED
                '        |                 |||||||| +--------- (#7)  M1 ENABLED
                '        |                 ++++++++----------- (B1)  MISSILE/BALL SIZE
                '        +------------------------------------ (#31) frambuffer toggle

'
'
' Initialized
'
i_table         long    @m6507_ins_table     ' instructions table pointer
i_ffff          long    $FFFF
i_d1s0          long    1 << 9
i_tia_wr        long    @tia_write_table
i_tia_width     byte    0, 16-8, 32-8, 16-8, 64-8, 0, 32-8, 0
i_tia_copies    long    %%01_03_01_02_03_02_02_01 ' getnib

i_rom_mask      long    $0FFF
i_rom_bs_base   long    $0FF8
i_rom_bs_top    long    $0FF9

'
'
' Temporaries
'
t1              res     1       ' used for flags processing
t2              res     1
t3              res     1
t4              res     1
t5              res     1
ea              res     1       ' external address
ct              res     1       ' counter (debug)

r0              res     1
r1              res     1
r2              res     1

                                ' 4 longs unused
                fit     $1F6    ' ($1F0) ijmp/iret registers not used

DAT             ' M6507 LUT
                org     $200

m6507_lut

'
'
' Instructions
'

i_bit_abs       call    #\_fetch_abs
i_bit_zpg       call    #\_fetch_zpg
_bit            test    _A, t1          wz
                bitz    _P, #REGP_Z
                and     t1, #%11000000
                and     _P, #%00111111
        _ret_   or      _P, t1

i_log_abs       call    #\_fetch_abs        ' %xxx_1_1111110
i_log_zpg       call    #\_fetch_zpg        ' %xxx_1_111110
i_log_abs_x     call    #\_fetch_abs_x      ' %xxx_1_11110
i_log_abs_y     call    #\_fetch_abs_y      ' %xxx_1_1110
i_log_ind_x     call    #\_fetch_ind_x      ' %xxx_1_110
i_log_ind_y     call    #\_fetch_ind_y      ' %xxx_1_10
i_log_zpg_x     call    #\_fetch_zpg_x      ' %xxx_1_0
i_log_imm       call    #\_fetch            ' %xxx_0
                and     t1, _A              '  110 AND
                xor     t1, _A              '  101 EOR
                or      t1, _A              '  011 ORA
                getbyte _A, t1, #0
                jmp     #_flags

i_asl_abs       call    #\_fetch_abs        ' %01_000_1_1110
i_asl_zpg       call    #\_fetch_zpg        ' %01_000_1_110
i_asl_abs_x     call    #\_fetch_abs_x      ' %01_000_1_10
i_asl_zpg_x     call    #\_fetch_zpg_x      ' %01_000_1_0
i_asl           getbyte t1, _A, #0          ' %10_000_0

                testb   t1, #7          wz
                shl     t1, #1
                bitz    _P, #REGP_C

                getbyte _A, t1, #0
                call    #\_write
                jmp     #_flags

i_adc_abs       call    #\_fetch_abs        ' %1_1111110
i_adc_abs_x     call    #\_fetch_abs_x      ' %1_111110
i_adc_abs_y     call    #\_fetch_abs_y      ' %1_11110
i_adc_ind_x     call    #\_fetch_ind_x      ' %1_1110
i_adc_ind_y     call    #\_fetch_ind_y      ' %1_110
i_adc_zpg       call    #\_fetch_zpg        ' %1_10
i_adc_zpg_x     call    #\_fetch_zpg_x      ' %1_0
i_adc_imm       call    #\_fetch            ' %0

_adc            testb   _P, #REGP_C     wc

                testb   _P, #REGP_D     wz
        if_z    jmp     #_adc_dec

                getbyte t3, _A, #0          ' t3 = sum
                addx    t3, t1              ' |
                testb   t3, #7          wz  ' affects N
                bitz    _P, #REGP_N         ' |

                getbyte t2, _A, #0          ' t2 = ~(A ^ operand)
                xor     t2, t1              ' |
                xor     t2, #$FF            ' |
                getbyte t4, _A, #0          ' t4 = A ^ sum
                xor     t4, t3
                and     t2, t4              ' t2 = ~(A ^ operand) & (A ^ sum)
                testb   t2, #7          wz  ' affects V
                bitz    _P, #REGP_V         ' |

                testb   t3, #8          wz  ' affects C
                bitz    _P, #REGP_C         ' |

                getbyte _A, t3, #0

                test    _A, #$FF        wz  ' affects Z
        _ret_   bitz    _P, #REGP_Z         ' |

_adc_dec        mov     t2, _A              ' t2 = lo
                and     t2, #$0F
                mov     t4, t1
                and     t4, #$0F
                addx    t2, t4

                mov     t3, _A              ' t3 = hi
                and     t3, #$F0
                mov     t4, t1
                and     t4, #$F0
                add     t3, t4

                cmp     t2, #$09        wcz
        if_a    add     t2, #$06
        if_a    add     t3, #$10

                testb   t3, #7          wz  ' affects N
                bitz    _P, #REGP_N         ' |

                getbyte t5, _A, #0          ' t5 = ~(A ^ operand)
                xor     t5, t1              ' |
                xor     t5, #$FF            ' |
                getbyte t4, _A, #0          ' t4 = A ^ hi
                xor     t4, t3
                and     t5, t4              ' t5 = ~(A ^ operand) & (A ^ hi)
                testb   t5, #7          wz  ' affects V
                bitz    _P, #REGP_V         ' |

                cmp     t3, #$90        wcz
        if_a    add     t3, #$60

                testb   t3, #8          wz  ' affects C
                bitz    _P, #REGP_C         ' |

                getnib  _A, t2, #0
                add     _A, t3

                and     _A, #$FF        wz  ' affects Z
        _ret_   bitz    _P, #REGP_Z         ' |

i_sbc_abs       call    #\_fetch_abs        ' %1_1111110
i_sbc_abs_x     call    #\_fetch_abs_x      ' %1_111110
i_sbc_abs_y     call    #\_fetch_abs_y      ' %1_11110
i_sbc_ind_x     call    #\_fetch_ind_x      ' %1_1110
i_sbc_ind_y     call    #\_fetch_ind_y      ' %1_110
i_sbc_zpg       call    #\_fetch_zpg        ' %1_10
i_sbc_zpg_x     call    #\_fetch_zpg_x      ' %1_0
i_sbc_imm       call    #\_fetch            ' %0

_sbc            testbn  _P, #REGP_C     wc

                getbyte t3, _A, #0          ' t3 = sum
                subx    t3, t1              ' |
                testb   t3, #7          wz  ' affects N
                bitz    _P, #REGP_N         ' |

                getbyte t2, _A, #0          ' t2 = (A ^ operand)
                xor     t2, t1              ' |
                getbyte t4, _A, #0          ' t4 = A ^ sum
                xor     t4, t3
                and     t2, t4              ' t2 = (A ^ operand) & (A ^ sum)
                testb   t2, #7          wz  ' affects V
                bitz    _P, #REGP_V         ' |

                testb   t3, #8          wz  ' affects C
                bitnz   _P, #REGP_C         ' |

                test    t3, #$FF        wz  ' affects Z
                bitz    _P, #REGP_Z         ' |

                testb   _P, #REGP_D     wz
        if_z    jmp     #_sbc_dec

                getbyte _A, t3, #0

                test    _A, #$FF        wz  ' affects Z
        _ret_   bitz    _P, #REGP_Z         ' |

_sbc_dec        mov     t2, _A              ' t2 = lo
                and     t2, #$0F
                mov     t4, t1
                and     t4, #$0F
                subx    t2, t4

                mov     t3, _A              ' t3 = hi
                and     t3, #$F0
                mov     t4, t1
                and     t4, #$F0
                sub     t3, t4

                test    t2, #$10        wz
        if_nz   sub     t2, #$06
        if_nz   sub     t3, #$01

                test    t3, #$100       wz
        if_nz   sub     t3, #$60

                getbyte _A, t3, #0
                setnib  _A, t2, #0

                test    _A, #$FF        wz  ' affects Z
        _ret_   bitz    _P, #REGP_Z         ' |

i_sec   _ret_   bith    _P, #REGP_C
i_sed   _ret_   bith    _P, #REGP_D
i_sei   _ret_   bith    _P, #REGP_I
i_clc   _ret_   bitl    _P, #REGP_C
i_cld   _ret_   bitl    _P, #REGP_D
i_cli   _ret_   bitl    _P, #REGP_I
i_clv   _ret_   bitl    _P, #REGP_V
i_nop           ret

i_st_abs        call    #\_setup_abs        ' %xxx_11111110
i_st_abs_x      call    #\_setup_abs_x      ' %xxx_1111110
i_st_abs_y      call    #\_setup_abs_y      ' %xxx_111110
i_st_zpg        call    #\_setup_zpg        ' %xxx_11110
i_st_zpg_x      call    #\_setup_zpg_x      ' %xxx_1110
i_st_zpg_y      call    #\_setup_zpg_y      ' %xxx_110
i_st_ind_x      call    #\_setup_ind_x      ' %xxx_10
i_st_ind_y      call    #\_setup_ind_y      ' %xxx_0
_st             mov     t1, _A              '  110 A
                mov     t1, _X              '  101 X
                mov     t1, _Y              '  011 Y
                jmp     #\_write
                                            ' TAX TAY TSX TXA TXS TYA
i_taxya         getbyte t1, _A, #0          '  0   0   1   1   1   1
                getbyte t1, _X, #0          '  1   1   1   0   0   1
                getbyte t1, _Y, #0          '  1   1   1   1   1   0
                getbyte t1, _S, #0          '  1   1   0   1   1   1
                getbyte _A, t1, #0          '  1   1   1   0   1   0
                getbyte _X, t1, #0          '  0   1   0   1   1   1
                getbyte _Y, t1, #0          '  1   0   1   1   1   1
                getbyte _S, t1, #0          '  1   1   1   1   0   1
                call    #\_flags            '                  1
                ret

i_rti           call    #\_pop_t1           ' (S) -> P
                mov     _P, t1
                ' fall-through
i_rts           call    #\_pop_t1           ' (S) -> PCL
                getbyte _PC, t1, #0         ' |
                call    #\_pop_t1           ' (S) -> PCH
                setbyte _PC, t1, #1         ' |
                incmod  _PC, i_ffff         ' PC = PC + 1 (skip if RTI)
                ret

i_rol_abs       call    #\_fetch_abs        ' %01_00000_1_1110
i_rol_zpg       call    #\_fetch_zpg        ' %01_00000_1_110
i_rol_abs_x     call    #\_fetch_abs_x      ' %01_00000_1_10
i_rol_zpg_x     call    #\_fetch_zpg_x      ' %01_00000_1_0
i_rol           getbyte t1, _A, #0          ' %10_00000_0

                testb   _P, #REGP_C     wc
                testb   t1, #7          wz
                shl     t1, #1
                bitc    t1, #0
                bitz    _P, #REGP_C

                getbyte _A, t1, #0
                call    #\_write

                jmp     #_flags


i_ror_abs       call    #\_fetch_abs        ' %01_00000_1_1110
i_ror_zpg       call    #\_fetch_zpg        ' %01_00000_1_110
i_ror_abs_x     call    #\_fetch_abs_x      ' %01_00000_1_10
i_ror_zpg_x     call    #\_fetch_zpg_x      ' %01_00000_1_0
i_ror           getbyte t1, _A, #0          ' %10_00000_0

                testb   _P, #REGP_C     wc
                testb   t1, #0          wz
                shr     t1, #1
                bitc    t1, #7
                bitz    _P, #REGP_C

                getbyte _A, t1, #0
                call    #\_write

                jmp     #_flags

'
'
' Common subroutines
'
_fetch          getword ea, _PC, #0
                incmod  _PC, i_ffff
                jmp     #\_read             ' return byte in t1

_fetch2         call     #\_fetch
                getbyte t4, t1, #0
                call     #\_fetch
        _ret_   setbyte t4, t1, #1          ' return word in t4

_fetch_abs      call    #\_fetch2
                getword ea, t4, #0
                jmp     #\_read

_setup_abs      call    #\_fetch2
        _ret_   getword ea, t4, #0

_fetch_abs_x    call    #\_setup_abs_x
                jmp     #\_read

_setup_abs_x    call    #\_fetch2
                getword ea, t4, #0
'                testb   ea, #8          wz
        _ret_   add     ea, _X
'                testb   ea, #8          wc
'    if_z_ne_c   jmp     #\_inc_cycles       ' page boundary, add 1 cycle
'                ret

_fetch_abs_y    call    #\_setup_abs_y
                jmp     #\_read

_setup_abs_y    call    #\_fetch2
                getword ea, t4, #0
'                testb   ea, #8          wz
        _ret_   add     ea, _Y
'                testb   ea, #8          wc
'    if_z_ne_c   jmp     #\_inc_cycles       ' page boundary, add 1 cycle
'                ret

_fetch_zpg      call    #\_setup_zpg
                getbyte ea, t1, #0
                jmp     #\_read

_setup_zpg      call    #\_fetch
        _ret_   getbyte ea, t1, #0

_fetch_zpg_x    call    #\_setup_zpg_x
                jmp     #\_read

_setup_zpg_x    call    #\_fetch
                getbyte ea, t1, #0
                add     ea, _X
        _ret_   and     ea, #$FF

_fetch_zpg_y    call    #\_setup_zpg_y
                jmp     #\_read

_setup_zpg_y    call    #\_fetch
                getbyte ea, t1, #0
                add     ea, _Y
        _ret_   and     ea, #$FF

_fetch_ind_x    call    #\_setup_ind_x
                jmp     #\_read

_setup_ind_x    call    #\_fetch
                add     t1, _X              ' add index

                getbyte ea, t1, #0          ' | low byte
                call    #\_read             ' |
                getbyte t4, t1, #0          ' |

                incmod  ea, #$FF
                call    #\_read             ' high byte
                setbyte t4, t1, #1          ' |

        _ret_   getword ea, t4, #0

_fetch_ind_y    call    #\_setup_ind_y
                jmp     #\_read

_setup_ind_y    call    #\_fetch

                getbyte ea, t1, #0
                call    #\_read
                getbyte t4, t1, #0          ' t4 = low

                incmod  ea, #$FF
                call    #\_read             ' t1 = high

                add     t4, _Y
'                cmp     t4, #$100       wc  ' page boundary
'        if_nc   call    #\_inc_cycles       ' add 1 cycle

                shl     t1, #8
                add     t4, t1
        _ret_   getword ea, t4, #0

_push_t1        getbyte ea, _S, #0
                add     ea, #$100
                decmod  _S, #$FF
                jmp     #\_write

_pop_t1         incmod  _S, #$FF
                getbyte ea, _S, #0
                add     ea, #$100
                jmp     #\_read

_flags          test    t1, #$FF        wz  ' affects Z
                bitz    _P, #REGP_Z         ' |
                testb   t1, #7          wz  ' affects N
        _ret_   bitz    _P, #REGP_N         ' |

'
'
' I/O Routines
'

_read           ' ea = address
                ' t1 = data
                getword t5, ea, #0
                testb   t5, #12     wz
        if_x1   jmp     #.rom               ' A12 = 1 is read from ROM
                testb   t5, #8      wz
        if_x1   jmp     #.ram               ' A8 = 1 is read from stack RAM
                testb   t5, #7      wc
        if_0x   jmp     #.tia               ' A7 = 0 is read from TIA
                testb   t5, #9      wz
        if_10   jmp     #.ram               ' A9 = 0 is read from RAM
        if_11   jmp     #.m6532             ' A9 = 1 is read from RIOT

                ret

.ram            and     t5, #$7F
                add     t5, ram_addr
        _ret_   rdbyte  t1, t5

.tia            and     t5, #$0F
                getptr  ptrb
                jmp     #\@tia_read

.m6532          and     t5, #$07

                cmp     t5, #SWCHA      wz
        if_e    getbyte t1, _SW, #0
                cmp     t5, #SWCHB      wz
        if_e    getbyte t1, _SW, #2

                cmp     t5, #INTIM      wz
        if_ne   cmp     t5, #INTIM+2    wz
        if_e    getbyte t1, _TIMER, #0
        if_e    bitl    _TIMER, #14
        if_e    setd    m6532_timer, #m6532_normal

                cmp     t5, #TIMINT     wz
        if_ne   cmp     t5, #TIMINT+2   wz
        if_e    getbyte t1, _TIMER, #1
        if_e    bitl    _TIMER, #14
        if_e    setd    m6532_timer, #m6532_normal

                ret     wcz

.rom            and     t5, i_rom_mask
'                cmp     t5, i_rom_bs_base   wz
'        if_ne   cmp     t5, i_rom_bs_top    wz
'        if_e    testb   t5, #0              wc
'        if_e    bitc    rom_addr, #12
                add     t5, rom_addr
        _ret_   rdbyte  t1, t5




_write          ' ea = address
                ' t1 = data
                getword t5, ea, #0
                testb   t5, #12     wz
        if_x1   jmp     #.rom               ' A12 = 1 is write to ROM
'                testb   t5, #8      wz
'        if_x1   jmp     #.ram               ' A8 = 1 is write to stack RAM
                testb   t5, #7      wc
        if_0x   jmp     #.tia               ' A7 = 0 is write to TIA
                testb   t5, #9      wz
        if_10   jmp     #.ram               ' A9 = 0 is write to RAM
        if_11   getptr  ptrb
        if_11   jmp     #\@m6532_write      ' A9 = 1 is write to M6532
                ret     wcz

.ram            and     t5, #$7F
                add     t5, ram_addr
                wrbyte  t1, t5
                ret     wcz

.tia            and     t5, #$3F

                cmp     t5, #HMOVE      wz
        if_e    getptr  ptrb
        if_e    jmp     #\@t_hmove

                shl     t5, #2
                add     t5, i_tia_wr
                rdlong  t5, t5
                execf   t5

.rom            and     t5, i_rom_mask
                cmp     t5, i_rom_bs_base   wz
        if_ne   cmp     t5, i_rom_bs_top    wz
        if_e    testb   t5, #0              wc
        if_e    bitc    rom_addr, #12
                ret

'
'
' TIA Port Write
'

t_vsync         testb   t1, #1          wc
                bitc    _SYSF, #0       wcz
        if_nc   ret     wcz

                rdlong  _SW, ppa_addr
                rdlong  _INPT, tia_inptp
                'testp   #RESET_PIN      wc
                'bitc    _SW, #16+0
                'testp   #SELECT_PIN     wc
                'bitc    _SW, #16+1

#ifdef _DEBUGGER
                wrfast  #0, tia_fb0
#else
                bitnot  _SYSF, #31      wcz ' c=old display buffer
        if_0x   wrlong  tia_fb0, tia_fbp    ' old is fb1, display fb0
        if_0x   wrfast  #0, tia_fb1         ' write to fb1
        if_1x   wrlong  tia_fb1, tia_fbp    ' old is fb0, display fb1
        if_1x   wrfast  #0, tia_fb0         ' write to fb0
#endif
.w              rdlong  r0, tia_fbp     wz  ' wait buffer ack
        if_nz   jmp     #.w                 ' |

                mov     _VC, #0
        _ret_   setd    tia_clock, #0

t_vblank        testb   t1, #1          wc
        _ret_   bitc    _SYSF, #1

t_wsync         cmp     _HC, #0         wz
        _ret_   bitnz   _SYSF, #2

t_colu          getbyte r0, t1, #0          ' a b c d
                shr     r0, #1              ' a b c d
                testb   _PF, #24 + 1    wz  ' a b c |   SCORE

        if_x1   setbyte t_pf_colu+0, r0, #0 ' a | | |
        _ret_   setbyte _colup0, r0, #0     ' a | | |   a=COLUP0:

        if_x1   setbyte t_pf_colu+1, r0, #0 '   b | |
        _ret_   setbyte _colup1, r0, #0     '   b | |   b=COLUP1:

        if_x0   setbyte t_pf_colu+0, r0, #0 '     c |
        if_x0   setbyte t_pf_colu+1, r0, #0 '     c |
        _ret_   setbyte _colubl, r0, #0     '     c |   c=COLUPF:

        _ret_   setbyte _colubk, r0, #0     '       d   d=COLUBK:

t_ctrlpf        testb   t1, #5          wc  '       d   d=CTRLPF
                testb   t1, #4          wz  '       d
        if_00   setbyte _SYSF, #1-1, #1     '       d   BALL SIZE
        if_01   setbyte _SYSF, #2-1, #1     '       d   |
        if_10   setbyte _SYSF, #4-1, #1     '       d   |
        if_11   setbyte _SYSF, #8-1, #1     '       d   |
                testb   t1, #1          wz  '       d   SCORE
        if_x0   getbyte t_pf_colu+0, _colubl, #0 '  d   | COLUPF
        if_x0   getbyte t_pf_colu+1, _colubl, #0 '  d   | COLUPF
        if_x1   getbyte t_pf_colu+0, _colup0, #0 '  d   | COLUP0
        if_x1   getbyte t_pf_colu+1, _colup1, #0 '  d   | COLUP1
                setbyte _PF, t1, #3         '       d
                ' fall-through
t_pf0           setbyte _PF, t1, #0         ' a     |   a=PF0
t_pf1           setbyte _PF, t1, #1         ' | b   |   b=PF1
t_pf2           setbyte _PF, t1, #2         ' | | c |   c=PF2

                getnib  r0, _PF, #1         ' PF0
                getbyte r1, _PF, #1         ' PF1
                rev     r1                  ' |
                shr     r1, #20             ' |
                or      r0, r1              ' PF1+PF0
                getbyte r1, _PF, #2         ' PF2
                shl     r1, #12             ' |
                or      r0, r1              ' PF2+PF1+PF0
                mov     t_pf+0, r0      wz

                muxz    tia_pfbl_0, tia_pf_disable    ' disable pf (with skipf) if all zero
                muxz    tia_bl_draw, tia_pf_disable ' |

                testb   _PF, #24        wc  ' REF
        if_1x   rev     r0                  ' |
        if_1x   shr     r0, #12             ' |
        _ret_   mov     t_pf+1, r0

t_grp0          setbyte _P0, t1, #1         ' GRP0d
                getbyte r0, _P1, #1         ' GRP1d
                setbyte _P1, r0, #0         ' GRP1

                testb   _P0, #25        wc  ' VDELP0
        if_0x   call     #\t_update_p0
                testb   _P1, #25        wc  ' VDELP1
        if_1x   jmp      #\t_update_p1
                ret

t_grp1          setbyte _P1, t1, #1         ' GRP1d
                getbyte r0, _P0, #1         ' GRP0d
                setbyte _P0, r0, #0         ' GRP0

                testb   _P1, #25        wc  ' VDELP1
        if_0x   call     #\t_update_p1
                testb   _P0, #25        wc  ' VDELP0
        if_1x   jmp      #\t_update_p0
                ret


t_nusiz0        setbyte _P0, t1, #2         '     c     c=NUSIZ0:  %01110
t_nusiz1        setbyte _P1, t1, #2         '     | d   d=NUSIZ1: %011110

                testb   t1, #5          wc  '     c d   ' missile size
                testb   t1, #4          wz  '     c d
        if_00   mov     r0, #1-1            '     c d
        if_01   mov     r0, #2-1            '     c d
        if_10   mov     r0, #4-1            '     c d
        if_11   mov     r0, #8-1            '     c d
                setbyte _m0_size, r0, #0    '     c |
                setbyte _m1_size, r0, #0    '     | d

t_refp          testb   t1, #3          wz  ' a b | |
                bitz    _P0, #24            ' a | | |
                jmp     #\t_update_p0       ' a | c |   a=REFP0:     %000
                bitz    _P1, #24            '   b   |
                jmp     #\t_update_p1       '   b   d   b=REFP1:   %00110

t_vdelp0        testb   t1, #0          wz
        _ret_   bitz    _P0, #25

t_vdelp1        testb   t1, #0          wz
        _ret_   bitz    _P1, #25


t_enam0         testb   t1, #1          wz
                testb   _MB, #27        wc  ' RESMP0
        if_0x   bitz    _SYSF, #6           ' M0 ENABLED
        _ret_   bitz    _MB, #24            ' ENAM0

t_enam1         testb   t1, #1          wz
                testb   _MB, #28        wc  ' RESMP1
        if_0x   bitz    _SYSF, #7           ' M1 ENABLED
        _ret_   bitz    _MB, #25            ' ENAM1

t_resmp0        testb   t1, #1          wz
                testb   _MB, #24        wc  ' ENAM0
        if_1x   bitnz   _SYSF, #6           ' M0 ENABLED
        if_0x   bitz    _MB, #27            ' RESMP0
        if_x0   getbyte r0, _p0_res, #0     ' RESP0
        if_x0   setbyte _m0_res, r0, #0     ' RESM0
                ret

t_resmp1        testb   t1, #1          wz
                testb   _MB, #25        wc  ' ENAM1
        if_1x   bitnz   _SYSF, #7           ' M1 ENABLED
        if_0x   bitz    _MB, #28            ' RESMP1
        if_x0   getbyte r0, _p1_res, #0     ' RESP1
        if_x0   setbyte _m1_res, r0, #0     ' RESM1
                ret


t_enabl         testb   t1, #1          wz
                testb   _MB, #29        wc  ' VDELBL
        if_0x   muxnz   tia_pfbl_0, tia_bl_disable ' BALL ENABLED
        _ret_   bitz    _MB, #30            ' ENABLd

t_vdelbl        testb   t1, #0          wz
                bitz    _MB, #29
        if_x1   testb   _MB, #26        wc  ' ENABL
        if_x0   testb   _MB, #30        wc  ' ENABLd
        _ret_   muxnc   tia_pfbl_0, tia_bl_disable ' BALL ENABLED

t_cxclr
        _ret_   mov     _COLL, #0

t_hm            getnib  r0, t1, #1          ' a b c d e
                                            '
        _ret_   setnib  _HM, r0, #0         ' a | | | |   a=HMP0:     %0_0
        _ret_   setnib  _HM, r0, #1         '   b | | |   b=HMP1:    %01_0
        _ret_   setnib  _HM, r0, #2         '     c | |   c=HMM0:  %0111_0
        _ret_   setnib  _HM, r0, #3         '       d |   d=HMM1: %01111_0
        _ret_   setnib  _HM, r0, #4         '         e   e=HMBL:   %011_0

t_hmclr _ret_   mov     _HM, #0

t_aud0          mov     ptrb, aud_addr      ' a b c
                setbyte _AUD0, t1, #0       ' a | |
                setbyte _AUD0, t1, #1       ' | b |
                setbyte _AUD0, t1, #2       ' | | c
        _ret_   wrlong  _AUD0, ptrb[0]      ' a b c

t_aud1          mov     ptrb, aud_addr      ' a b c
                setbyte _AUD1, t1, #0       ' a | |
                setbyte _AUD1, t1, #1       ' | b |
                setbyte _AUD1, t1, #2       ' | | c
        _ret_   wrlong  _AUD1, ptrb[1]      ' a b c

                fit     $400                ' 41 longs unused

m6507_lut_end

DAT             ' M6507 HUB
                orgh

m6507_ins_table
'
' instruction         snippet                  skip pattern         +cycles   encoding
'--------------------------------------------------------------------------------------------
                long  i_brk       |                      %0 << 10 | 7 << 28 ' 00 BRK
                long  i_log_ind_x |              %011_1_110 << 10 | 6 << 28 ' 01 ORA ($nn,X)
                long  i_jam       |                      %0 << 10 | 1 << 28 ' 02 *JAM
                long  i_halt      |                   %0_10 << 10 | 8 << 28 ' 03 *ASO ($nn,X)
                long  i_halt      |                    %110 << 10 | 3 << 28 ' 04 *NOP
                long  i_log_zpg   |           %011_1_111110 << 10 | 3 << 28 ' 05 ORA $nn
                long  i_asl_zpg   |           %01_000_1_110 << 10 | 5 << 28 ' 06 ASL $nn
                long  i_halt      |                 %0_1110 << 10 | 5 << 28 ' 07 *ASO $nn
                long  i_php       |                     %00 << 10 | 3 << 28 ' 08 PHP
                long  i_log_imm   |                  %011_0 << 10 | 2 << 28 ' 09 ORA #$nn
                long  i_asl       |               %10_000_0 << 10 | 2 << 28 ' 0A ASL
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 0B *ANC #$nn
                long  i_halt      |                  %11110 << 10 | 4 << 28 ' 0C *NOP
                long  i_log_abs   |          %011_1_1111110 << 10 | 4 << 28 ' 0D ORA $nnnn
                long  i_asl_abs   |          %01_000_1_1110 << 10 | 6 << 28 ' 0E ASL $nnnn
                long  i_halt      |              %0_1111110 << 10 | 6 << 28 ' 0F *ASO $nnnn

                long  i_branch    |               %0_0111_0 << 10 | 2 << 28 ' 10 BPL $nn
                long  i_log_ind_y |               %011_1_10 << 10 | 5 << 28 ' 11 ORA ($nn),Y
                long  i_jam       |                      %0 << 10 | 1 << 28 ' 12 *JAM
                long  i_halt      |                    %0_0 << 10 | 8 << 28 ' 13 *ASO ($nn),Y
                long  i_halt      |                     %10 << 10 | 4 << 28 ' 14 *NOP
                long  i_log_zpg_x |                %011_1_0 << 10 | 4 << 28 ' 15 ORA $nn,X
                long  i_asl_zpg_x |             %01_000_1_0 << 10 | 6 << 28 ' 16 ASL $nn,X
                long  i_halt      |                  %0_110 << 10 | 6 << 28 ' 17 *ASO $nn,X
                long  i_clc       |                  %01110 << 10 | 2 << 28 ' 18 CLC
                long  i_log_abs_y |             %011_1_1110 << 10 | 4 << 28 ' 19 ORA $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' 1A *NOP
                long  i_halt      |                %0_11110 << 10 | 7 << 28 ' 1B *ASO $nnnn,Y
                long  i_halt      |                   %1110 << 10 | 4 << 28 ' 1C *NOP
                long  i_log_abs_x |            %011_1_11110 << 10 | 4 << 28 ' 1D ORA $nnnn,X
                long  i_asl_abs_x |            %01_000_1_10 << 10 | 7 << 28 ' 1E ASL $nnnn,X
                long  i_halt      |               %0_111110 << 10 | 7 << 28 ' 1F *ASO $nnnn,X

                long  i_jsr       |                      %0 << 10 | 6 << 28 ' 20 JSR $nn
                long  i_log_ind_x |              %110_1_110 << 10 | 6 << 28 ' 21 AND ($nn,X)
                long  i_jam       |                      %0 << 10 | 1 << 28 ' 22 *JAM
                long  i_halt      |                   %0_10 << 10 | 8 << 28 ' 23 *RLA ($nn,X)
                long  i_bit_zpg   |                      %0 << 10 | 3 << 28 ' 24 BIT $nn
                long  i_log_zpg   |           %110_1_111110 << 10 | 3 << 28 ' 25 AND $nn
                long  i_rol_zpg   |         %01_00000_1_110 << 10 | 5 << 28 ' 26 ROL $nn
                long  i_halt      |                 %0_1110 << 10 | 5 << 28 ' 27 *RLA $nn
                long  i_pop       |                 %100010 << 10 | 4 << 28 ' 28 PLP
                long  i_log_imm   |                  %110_0 << 10 | 2 << 28 ' 29 AND #$nn
                long  i_rol       |             %10_00000_0 << 10 | 2 << 28 ' 2A ROL
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 2B *ANC #$nn
                long  i_bit_abs   |                     %10 << 10 | 4 << 28 ' 2C BIT $nnnn
                long  i_log_abs   |          %110_1_1111110 << 10 | 4 << 28 ' 2D AND $nnnn
                long  i_rol_abs   |        %01_00000_1_1110 << 10 | 6 << 28 ' 2E ROL $nnnn
                long  i_halt      |              %0_1111110 << 10 | 6 << 28 ' 2F *RLA $nnnn

                long  i_branch    |               %1_0111_0 << 10 | 2 << 28 ' 30 BMI $nn
                long  i_log_ind_y |               %110_1_10 << 10 | 5 << 28 ' 31 AND ($nn),Y
                long  i_jam       |                      %0 << 10 | 1 << 28 ' 32 *JAM
                long  i_halt      |                    %0_0 << 10 | 8 << 28 ' 33 *RLA ($nn),Y
                long  i_halt      |                     %10 << 10 | 4 << 28 ' 34 *NOP
                long  i_log_zpg_x |                %110_1_0 << 10 | 4 << 28 ' 35 AND $nn,X
                long  i_rol_zpg_x |           %01_00000_1_0 << 10 | 6 << 28 ' 36 ROL $nn,X
                long  i_halt      |                  %0_110 << 10 | 6 << 28 ' 37 *RLA $nn,X
                long  i_sec       |                     %00 << 10 | 2 << 28 ' 38 SEC
                long  i_log_abs_y |             %110_1_1110 << 10 | 4 << 28 ' 39 AND $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' 3A *NOP
                long  i_halt      |                %0_11110 << 10 | 7 << 28 ' 3B *RLA $nnnn,Y
                long  i_halt      |                   %1110 << 10 | 4 << 28 ' 3C *NOP
                long  i_log_abs_x |            %110_1_11110 << 10 | 4 << 28 ' 3D AND $nnnn,X
                long  i_rol_abs_x |          %01_00000_1_10 << 10 | 7 << 28 ' 3E ROL $nnnn,X
                long  i_halt      |               %0_111110 << 10 | 7 << 28 ' 3F *RLA $nnnn,X

                long  i_rti       |              %010000_00 << 10 | 6 << 28 ' 40 RTI
                long  i_log_ind_x |              %101_1_110 << 10 | 6 << 28 ' 41 EOR ($nn,X)
                long  i_jam       |                      %0 << 10 | 1 << 28 ' 42 *JAM
                long  i_halt      |                   %0_10 << 10 | 8 << 28 ' 43 *SRE ($nn,X)
                long  i_halt      |                    %110 << 10 | 3 << 28 ' 44 *NOP
                long  i_log_zpg   |           %101_1_111110 << 10 | 3 << 28 ' 45 EOR $nn
                long  i_lsr_zpg   |            %01_00_1_110 << 10 | 5 << 28 ' 46 LSR $nn
                long  i_halt      |                 %0_1110 << 10 | 5 << 28 ' 47 *SRE $nn
                long  i_pha       |                    %010 << 10 | 3 << 28 ' 48 PHA
                long  i_log_imm   |                  %101_0 << 10 | 2 << 28 ' 49 EOR #$nn
                long  i_lsr       |                %10_00_0 << 10 | 2 << 28 ' 4A LSR
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 4B *ALR #$nn
                long  i_jmp_imm   |                      %0 << 10 | 3 << 28 ' 4C JMP $nnnn
                long  i_log_abs   |          %101_1_1111110 << 10 | 4 << 28 ' 4D EOR $nnnn
                long  i_lsr_abs   |           %01_00_1_1110 << 10 | 6 << 28 ' 4E LSR $nnnn
                long  i_halt      |              %0_1111110 << 10 | 6 << 28 ' 4F *SRE $nnnn

                long  i_branch    |               %0_1011_0 << 10 | 2 << 28 ' 50 BVC $nn
                long  i_log_ind_y |               %101_1_10 << 10 | 5 << 28 ' 51 EOR ($nn),Y
                long  i_jam       |                      %0 << 10 | 1 << 28 ' 52 *JAM
                long  i_halt      |                    %0_0 << 10 | 8 << 28 ' 53 *SRE ($nn),Y
                long  i_halt      |                     %10 << 10 | 4 << 28 ' 54 *NOP
                long  i_log_zpg_x |                %101_1_0 << 10 | 4 << 28 ' 55 EOR $nn,X
                long  i_lsr_zpg_x |              %01_00_1_0 << 10 | 6 << 28 ' 56 LSR $nn,X
                long  i_halt      |                  %0_110 << 10 | 6 << 28 ' 57 *SRE $nn,X
                long  i_cli       |                %0111110 << 10 | 2 << 28 ' 58 CLI
                long  i_log_abs_y |             %101_1_1110 << 10 | 4 << 28 ' 59 EOR $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' 5A *NOP
                long  i_halt      |                %0_11110 << 10 | 7 << 28 ' 5B *SRE $nnnn,Y
                long  i_halt      |                   %1110 << 10 | 4 << 28 ' 5C *NOP
                long  i_log_abs_x |            %101_1_11110 << 10 | 4 << 28 ' 5D EOR $nnnn,X
                long  i_lsr_abs_x |             %01_00_1_10 << 10 | 7 << 28 ' 5E LSR $nnnn,X
                long  i_halt      |               %0_111110 << 10 | 7 << 28 ' 5F *SRE $nnnn,X

                long  i_rts       |                      %0 << 10 | 6 << 28 ' 60 RTS
                long  i_adc_ind_x |                 %1_1110 << 10 | 6 << 28 ' 61 ADC ($nn,X)
                long  i_jam       |                      %0 << 10 | 1 << 28 ' 62 *JAM
                long  i_halt      |                   %0_10 << 10 | 8 << 28 ' 63 *RRA ($nn,X)
                long  i_halt      |                    %110 << 10 | 3 << 28 ' 64 *NOP
                long  i_adc_zpg   |                   %1_10 << 10 | 3 << 28 ' 65 ADC $nn
                long  i_ror_zpg   |         %01_00000_1_110 << 10 | 5 << 28 ' 66 ROR $nn
                long  i_halt      |                 %0_1110 << 10 | 5 << 28 ' 67 *RRA $nn
                long  i_pop       |                 %001100 << 10 | 4 << 28 ' 68 PLA
                long  i_adc_imm   |                      %0 << 10 | 2 << 28 ' 69 ADC #$nn
                long  i_ror       |             %10_00000_0 << 10 | 2 << 28 ' 6A ROR
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 6B *ARR #$nn
                long  i_jmp_ind   |                      %0 << 10 | 5 << 28 ' 6C JMP ($nnnn)
                long  i_adc_abs   |              %1_1111110 << 10 | 4 << 28 ' 6D ADC $nnnn
                long  i_ror_abs   |        %01_00000_1_1110 << 10 | 6 << 28 ' 6E ROR $nnnn
                long  i_halt      |              %0_1111110 << 10 | 6 << 28 ' 6F *RRA $nnnn

                long  i_branch    |               %1_1011_0 << 10 | 2 << 28 ' 70 BVS $nn
                long  i_adc_ind_y |                  %1_110 << 10 | 5 << 28 ' 71 ADC ($nn),Y
                long  i_jam       |                      %0 << 10 | 1 << 28 ' 72 *JAM
                long  i_halt      |                    %0_0 << 10 | 8 << 28 ' 73 *RRA ($nn),Y
                long  i_halt      |                     %10 << 10 | 4 << 28 ' 74 *NOP
                long  i_adc_zpg_x |                    %1_0 << 10 | 4 << 28 ' 75 ADC $nn,X
                long  i_ror_zpg_x |           %01_00000_1_0 << 10 | 6 << 28 ' 76 ROR $nn,X
                long  i_halt      |                  %0_110 << 10 | 6 << 28 ' 77 *RRA $nn,X
                long  i_sei       |                   %0110 << 10 | 2 << 28 ' 78 SEI
                long  i_adc_abs_y |                %1_11110 << 10 | 4 << 28 ' 79 AND $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' 7A *NOP
                long  i_halt      |               %0_111110 << 10 | 7 << 28 ' 7B *RRA $nnnn,Y (7-2 ???)
                long  i_halt      |                   %1110 << 10 | 4 << 28 ' 7C *NOP
                long  i_adc_abs_x |               %1_111110 << 10 | 4 << 28 ' 7D ADC $nnnn,X
                long  i_ror_abs_x |          %01_00000_1_10 << 10 | 7 << 28 ' 7E ROR $nnnn,X
                long  i_halt      |               %0_111110 << 10 | 7 << 28 ' 7F *RRA $nnnn,X

                long  i_halt      |                      %0 << 10 | 2 << 28 ' 80 *NOP
                long  i_st_ind_x  |                 %110_10 << 10 | 6 << 28 ' 81 STA ($nn,X)
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 82 *NOP
                long  i_halt      |                      %0 << 10 | 6 << 28 ' 83
                long  i_st_zpg    |              %011_11110 << 10 | 3 << 28 ' 84 STY $nn
                long  i_st_zpg    |              %110_11110 << 10 | 3 << 28 ' 85 STA $nn
                long  i_st_zpg    |              %101_11110 << 10 | 3 << 28 ' 86 STX $nn
                long  i_halt      |                      %0 << 10 | 3 << 28 ' 87
                long  i_inde_xy   |               %01_01_01 << 10 | 2 << 28 ' 88 DEY
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 89 *NOP
                long  i_taxya     |              %1110_1101 << 10 | 2 << 28 ' 8A TXA
                long  i_halt      |                      %0 << 10 | 2 << 28 ' 8B *ANE #$nn
                long  i_st_abs    |           %011_11111110 << 10 | 4 << 28 ' 8C STY $nnnn
                long  i_st_abs    |           %110_11111110 << 10 | 4 << 28 ' 8D STA $nnnn
                long  i_st_abs    |           %101_11111110 << 10 | 4 << 28 ' 8E STX $nnnn
                long  i_halt      |                      %0 << 10 | 4 << 28 ' 8F

                long  i_branch    |               %0_1110_0 << 10 | 2 << 28 ' 90 BCC $nn
                long  i_st_ind_y  |                  %110_0 << 10 | 6 << 28 ' 91 STA ($nn),Y
                long  i_jam       |                      %0 << 10 | 1 << 28 ' 92 *JAM
                long  i_halt      |                      %0 << 10 | 6 << 28 ' 93
                long  i_st_zpg_x  |               %011_1110 << 10 | 4 << 28 ' 94 STY $nn,X
                long  i_st_zpg_x  |               %110_1110 << 10 | 4 << 28 ' 95 STA $nn,X
                long  i_st_zpg_y  |                %101_110 << 10 | 4 << 28 ' 96 STX $nn,Y
                long  i_halt      |                      %0 << 10 | 4 << 28 ' 97
                long  i_taxya     |              %1110_1011 << 10 | 2 << 28 ' 98 TYA
                long  i_st_abs_y  |             %110_111110 << 10 | 5 << 28 ' 99 STA $nnnn,Y
                long  i_taxya     |            %1_0111_1101 << 10 | 2 << 28 ' 9A TXS
                long  i_halt      |                      %0 << 10 | 5 << 28 ' 9B
                long  i_halt      |                      %0 << 10 | 5 << 28 ' 9C
                long  i_st_abs_x  |            %110_1111110 << 10 | 5 << 28 ' 9D STA $nnnn,X
                long  i_halt      |                      %0 << 10 | 5 << 28 ' 9E
                long  i_halt      |                      %0 << 10 | 5 << 28 ' 9F

                long  i_ld_imm    |                  %011_0 << 10 | 2 << 28 ' A0 LDY #nn
                long  i_ld_ind_x  |               %110_1_10 << 10 | 6 << 28 ' A1 LDA ($nn,X)
                long  i_ld_imm    |                  %101_0 << 10 | 2 << 28 ' A2 LDX #nn
                long  i_ld_ind_x  |               %100_1_10 << 10 | 6 << 28 ' A3 *LAX ($nn,X)
                long  i_ld_zpg    |            %011_1_11110 << 10 | 3 << 28 ' A4 LDY zpg
                long  i_ld_zpg    |            %110_1_11110 << 10 | 3 << 28 ' A5 LDA zpg
                long  i_ld_zpg    |            %101_1_11110 << 10 | 3 << 28 ' A6 LDX zpg
                long  i_ld_zpg    |            %100_1_11110 << 10 | 3 << 28 ' A7 *LAX zpg
                long  i_taxya     |              %1011_1110 << 10 | 2 << 28 ' A8 TAY
                long  i_ld_imm    |                  %110_0 << 10 | 2 << 28 ' A9 LDA #nn
                long  i_taxya     |              %1101_1110 << 10 | 2 << 28 ' AA TAX
                long  i_ld_imm    |                  %100_0 << 10 | 2 << 28 ' AB *LXA #nn
                long  i_ld_abs    |         %011_1_11111110 << 10 | 4 << 28 ' AC LDY nnnn
                long  i_ld_abs    |         %110_1_11111110 << 10 | 4 << 28 ' AD LDA nnnn
                long  i_ld_abs    |         %101_1_11111110 << 10 | 4 << 28 ' AE LDX nnnn
                long  i_ld_abs    |         %100_1_11111110 << 10 | 4 << 28 ' AF *LAX nnnn

                long  i_branch    |               %1_1110_0 << 10 | 2 << 28 ' B0 BCS $nn
                long  i_ld_ind_y  |                %110_1_0 << 10 | 5 << 28 ' B1 LDA ($nn),Y
                long  i_jam       |                      %0 << 10 | 1 << 28 ' B2 *JAM
                long  i_ld_ind_y  |                %100_1_0 << 10 | 5 << 28 ' B3 *LAX ($nn),Y
                long  i_ld_zpg_x  |             %011_1_1110 << 10 | 4 << 28 ' B4 LDY $nn,Y
                long  i_ld_zpg_x  |             %110_1_1110 << 10 | 4 << 28 ' B5 LDA $nn,X
                long  i_ld_zpg_y  |              %101_1_110 << 10 | 4 << 28 ' B6 LDX $nn,Y
                long  i_ld_zpg_x  |             %100_1_1110 << 10 | 4 << 28 ' B7 *LAX $nn,X
                long  i_clv       |               %01111110 << 10 | 2 << 28 ' B8 CLV
                long  i_ld_abs_y  |           %110_1_111110 << 10 | 4 << 28 ' B9 LDA $nnnn,Y
                long  i_taxya     |              %1101_0111 << 10 | 2 << 28 ' BA TSX
                long  i_halt      |                      %0 << 10 | 4 << 28 ' BB
                long  i_ld_abs_x  |          %011_1_1111110 << 10 | 4 << 28 ' BC LDY $nnnn,X
                long  i_ld_abs_x  |          %110_1_1111110 << 10 | 4 << 28 ' BD LDA $nnnn,X
                long  i_ld_abs_y  |           %101_1_111110 << 10 | 4 << 28 ' BE LDX $nnnn,Y
                long  i_ld_abs_x  |          %100_1_1111110 << 10 | 4 << 28 ' BF *LAX $nnnn,X

                long  i_cmp_imm   |                 %011_00 << 10 | 2 << 28 ' C0 CPY #$nn
                long  i_cmp_ind_x |           %110_0_1_1110 << 10 | 6 << 28 ' C1 CMP ($nn,X)
                long  i_halt      |                      %0 << 10 | 2 << 28 ' C2 *NOP
                long  i_halt      |                      %0 << 10 | 8 << 28 ' C3
                long  i_cmp_zpg   |             %011_0_1_10 << 10 | 3 << 28 ' C4 CPY $nn
                long  i_cmp_zpg   |             %110_0_1_10 << 10 | 3 << 28 ' C5 CMP $nn
                long  i_dec_zpg   |                %10_1110 << 10 | 5 << 28 ' C6 DEC $nn
                long  i_halt      |                      %0 << 10 | 5 << 28 ' C7
                long  i_inde_xy   |               %01_10_01 << 10 | 2 << 28 ' C8 INY
                long  i_cmp_imm   |                 %110_00 << 10 | 2 << 28 ' C9 CMP #$nn
                long  i_inde_xy   |               %10_01_10 << 10 | 2 << 28 ' CA DEX
                long  i_halt      |                      %0 << 10 | 2 << 28 ' CB *AXS #$nn
                long  i_cmp_abs   |        %011_0_1_1111110 << 10 | 4 << 28 ' CC CPY $nnnn
                long  i_cmp_abs   |        %110_0_1_1111110 << 10 | 4 << 28 ' CD CMP $nnnn
                long  i_dec_abs   |                   %10_0 << 10 | 6 << 28 ' CE DEC $nnnn
                long  i_halt      |                      %0 << 10 | 6 << 28 ' CF

                long  i_branch    |               %0_1101_0 << 10 | 2 << 28 ' D0 BNE $mm
                long  i_cmp_ind_y |            %110_0_1_110 << 10 | 5 << 28 ' D1 CMP ($nn),Y
                long  i_jam       |                      %0 << 10 | 1 << 28 ' D2 *JAM
                long  i_halt      |                      %0 << 10 | 8 << 28 ' D3
                long  i_halt      |                     %10 << 10 | 4 << 28 ' D4 *NOP
                long  i_cmp_zpg_x |              %110_0_1_0 << 10 | 4 << 28 ' D5 CMP $nn,X
                long  i_dec_zpg_x |                  %10_10 << 10 | 6 << 28 ' D6 DEC $nn,X
                long  i_halt      |                      %0 << 10 | 6 << 28 ' D7
                long  i_cld       |                 %011110 << 10 | 2 << 28 ' D8 CLD
                long  i_cmp_abs_y |          %110_0_1_11110 << 10 | 4 << 28 ' D9 CMP $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' DA *NOP
                long  i_halt      |                      %0 << 10 | 7 << 28 ' DB
                long  i_halt      |                   %1110 << 10 | 4 << 28 ' DC *NOP
                long  i_cmp_abs_x |         %110_0_1_111110 << 10 | 4 << 28 ' DD CMP $nnnn,X
                long  i_dec_abs_x |                 %10_110 << 10 | 7 << 28 ' DE DEC $nnnn,X
                long  i_halt      |                      %0 << 10 | 7 << 28 ' DF

                long  i_cmp_imm   |                 %101_00 << 10 | 2 << 28 ' E0 CPX #$nn
                long  i_sbc_ind_x |                 %1_1110 << 10 | 6 << 28 ' E1 SBC ($nn,X)
                long  i_halt      |                      %0 << 10 | 2 << 28 ' E2 *NOP
                long  i_halt      |                      %0 << 10 | 8 << 28 ' E3
                long  i_cmp_zpg   |             %101_0_1_10 << 10 | 3 << 28 ' E4 CPX $nn
                long  i_sbc_zpg   |                   %1_10 << 10 | 3 << 28 ' E5 SBC #$nn
                long  i_dec_zpg   |                %01_1110 << 10 | 5 << 28 ' E6 INC $nn
                long  i_halt      |                      %0 << 10 | 5 << 28 ' E7
                long  i_inde_xy   |               %10_10_10 << 10 | 2 << 28 ' E8 INX
                long  i_sbc_imm   |                      %0 << 10 | 2 << 28 ' E9 SBC #$nn
                long  i_nop       |                      %0 << 10 | 2 << 28 ' EA NOP
                long  i_sbc_imm   |                      %0 << 10 | 2 << 28 ' EB *SBC #$nn
                long  i_cmp_abs   |        %101_0_1_1111110 << 10 | 4 << 28 ' EC CPX $nnnn
                long  i_sbc_abs   |              %1_1111110 << 10 | 4 << 28 ' ED SBC $nnnn
                long  i_dec_abs   |                   %01_0 << 10 | 6 << 28 ' EE INC $nnnn
                long  i_halt      |                      %0 << 10 | 6 << 28 ' EF

                long  i_branch    |               %1_1101_0 << 10 | 2 << 28 ' F0 BEQ $nn
                long  i_sbc_ind_y |                  %1_110 << 10 | 5 << 28 ' F1 SBC ($nn),Y
                long  i_jam       |                      %0 << 10 | 1 << 28 ' F2 *JAM
                long  i_halt      |                      %0 << 10 | 8 << 28 ' F3
                long  i_halt      |                     %10 << 10 | 4 << 28 ' F4 *NOP
                long  i_sbc_zpg_x |                    %1_0 << 10 | 4 << 28 ' F5 SBC $nn,X
                long  i_dec_zpg_x |                  %01_10 << 10 | 6 << 28 ' F6 INC $nn,X
                long  i_halt      |                      %0 << 10 | 6 << 28 ' F7
                long  i_sed       |                    %010 << 10 | 2 << 28 ' F8 SED
                long  i_sbc_abs_y |                %1_11110 << 10 | 4 << 28 ' F9 SBC $nnnn,Y
                long  i_nop       |                      %0 << 10 | 2 << 28 ' FA *NOP
                long  i_halt      |                      %0 << 10 | 7 << 28 ' FB
                long  i_halt      |                   %1110 << 10 | 4 << 28 ' FC *NOP
                long  i_sbc_abs_x |               %1_111110 << 10 | 4 << 28 ' FD SBC $nnnn,X
                long  i_dec_abs_x |                 %01_110 << 10 | 7 << 28 ' FE INC $nnnn
                long  i_halt      |                      %0 << 10 | 7 << 28 ' FF

i_trap
                rdlong  r0, #$44
                qmul    r0, ##$1_0000           ' calculate bit timing
                getqx   r0                      ' |
                getqy   r1                      ' |
                setq    r1                      ' |
                qdiv    r0, ##UART_BAUD         ' |
                getqx   r0                      ' |
                and     r0, ##$FFFFFC00         ' |
                or      r0, #8 - 1              ' set bits

                fltl    #UART_TX                ' configure tx smart pin
                wrpin   ##(P_ASYNC_TX | P_OE), #UART_TX
                wxpin   r0, #UART_TX
                drvl    #UART_TX

                waitx   ##(_CLKFREQ / 1_000) * 200
                wypin   #$0D, #UART_TX

                callpa  #"*", #tx
                callpa  #"*", #tx
                callpa  #"*", #tx
                callpa  #" ", #tx
                callpa  #"T", #tx
                callpa  #"R", #tx
                callpa  #"A", #tx
                callpa  #"P", #tx
                callpa  #" ", #tx
                callpa  #"*", #tx
                callpa  #"*", #tx
                callpa  #"*", #tx
                callpa  #" ", #tx
                callpa  #"P", #tx
                callpa  #"C", #tx
                callpa  #":", #tx

                mov     ea, _PC
                sub     ea, #1
                call    #\_read

                getnib  r0, ea, #3
                callpa  r0, #tx_hex
                getnib  r0, ea, #2
                callpa  r0, #tx_hex
                getnib  r0, ea, #1
                callpa  r0, #tx_hex
                getnib  r0, ea, #0
                callpa  r0, #tx_hex

                callpa  #" ", #tx
                callpa  #":", #tx
                callpa  #" ", #tx

                getnib  r0, t1, #1
                callpa  r0, #tx_hex
                getnib  r0, t1, #0
                callpa  r0, #tx_hex

                callpa  #" ", #tx
                jmp     #$

tx_hex          add     pa, #$30
                cmp     pa, #$3A            wcz
        if_ae   add     pa, #$07
                ' fall-through
tx              testp   #UART_TX            wc
        if_nc   jmp     #tx
                wypin   pa, #UART_TX
                ret                         wcz

DAT             ' TIA HUB
                orgh

tia_read
                cmp     t5, #CXM0P      wz  ' D7=(M0,P1); D6=(M0,P0)
        if_e    mov     t1, _COLL
        if_e    shr     t1, #8
                cmp     t5, #CXM1P      wz  ' D7=(M1,P0); D6=(M1,P1)
        if_e    mov     t1, _COLL
        if_e    shr     t1, #6
                cmp     t5, #CXP0FB     wz  ' D7=(P0,PF); D6=(P0,BL)
        if_e    mov     t1, _COLL
        if_e    shr     t1, #4
                cmp     t5, #CXP1FB     wz  ' D7=(P1,PF); D6=(P1,BL)
        if_e    mov     t1, _COLL
        if_e    shr     t1, #2
                cmp     t5, #CXM0FB     wz  ' D7=(M0,PF); D6=(M0,BL)
        if_e    mov     t1, _COLL
                cmp     t5, #CXM1FB     wz  ' D7=(M1,PF); D6=(M1,BL)
        if_e    mov     t1, _COLL
        if_e    shl     t1, #2
                cmp     t5, #CXBLPF     wz  ' D7=(BL,PF); D6=(unused)
        if_e    mov     t1, _COLL
        if_e    shl     t1, #4
                cmp     t5, #CXPPMM     wz  ' D7=(P0,P1); D6=(M0,M1)
        if_e    mov     t1, _COLL
        if_e    shl     t1, #6

                cmp     t5, #INPT0      wz  ' pot port: D7
        if_ne   cmp     t5, #INPT1      wz  ' pot port: D7
        if_ne   cmp     t5, #INPT2      wz  ' pot port: D7
        if_ne   cmp     t5, #INPT3      wz  ' pot port: D7
        if_e    mov     t1, #$00

                cmp     t5, #INPT4      wz  ' P0 joystick trigger: D7
        if_e    testb   _INPT, #4       wc
        if_e    bitc    t1, #7
                cmp     t5, #INPT5      wz  ' P1 joystick trigger: D7
        if_e    testb   _INPT, #5       wc
        if_e    bitc    t1, #7

        _ret_   wrfast  #0, ptrb

t_hmove         getnib  r1, _HM, #0         ' HMP0
                signx   r1, #3          wz
                sub     tia_resp0, r1
                cmp     tia_resp0, #228 wc
        if_ae   sub     tia_resp0, #160
                cmp     tia_resp0, #68  wc
        if_b    add     tia_resp0, #160
        if_nz   call    #t_update_p0

                getnib  r1, _HM, #1         ' HMP1
                signx   r1, #3          wz
                sub     tia_resp1, r1
                cmp     tia_resp1, #228 wc
        if_ae   sub     tia_resp1, #160
                cmp     tia_resp1, #68  wc
        if_b    add     tia_resp1, #160
        if_nz   call    #t_update_p0

                getbyte r0, _m0_res, #0     ' RESM0
                getnib  r1, _HM, #2         ' HMM0
                signx   r1, #3
                sub     r0, r1
'                cmp     r0, #228        wcz
'        if_ae   sub     r0, #160
'                cmp     r0, #68         wcz
'        if_b    add     r0, #160
                setbyte _m0_res, r0, #0

                getbyte r0, _m1_res, #0     ' RESM1
                getnib  r1, _HM, #3         ' HMM1
                signx   r1, #3
                sub     r0, r1
'                cmp     r0, #228        wcz
'        if_ae   sub     r0, #160
'                cmp     r0, #68         wcz
'        if_b    add     r0, #160
                setbyte _m1_res, r0, #0

                getbyte r0, _bl_res, #0     ' RESBL
                getnib  r1, _HM, #4         ' HMBL
                signx   r1, #3
                sub     r0, r1
'                cmp     r0, #228        wcz
'        if_ae   sub     r0, #160
'                cmp     r0, #68         wcz
'        if_b    add     r0, #160
                setbyte _bl_res, r0, #0

                cmp     _HC, #68        wcz
        if_b    bith    _SYSF, #16
                cmp     _HC, #219       wcz
        if_ae   bith    _SYSF, #17

        _ret_   wrfast  #0, ptrb

m6532_write     and     t5, #$1F
                cmp     t5, #SWACNT     wz
        if_e    setbyte _SW, t1, #1
                cmp     t5, #SWBCNT     wz
        if_e    setbyte _SW, t1, #3
                cmp     t5, #TIM1T      wz
        if_e    mov     r1, #1
        if_e    jmp     #.timer
                cmp     t5, #TIM8T      wz
        if_e    mov     r1, #8
        if_e    jmp     #.timer
                cmp     t5, #TIM64T     wz
        if_e    mov     r1, #64
        if_e    skip    #%11111
                cmp     t5, #TIM1024T   wz
        if_e    mov     r1, ##1024
        if_e    skip    #%1

        _ret_   wrfast  #0, ptrb

.timer          getbyte r0, t1, #0
                sub     r0, #1
                getbyte _TIMER, r0, #0      ' INTIM (clear TIMINT)
                setword _TIMER, r1, #1
                mov     _TC, #0
                setd    m6532_timer, #m6532_normal
        _ret_   wrfast  #0, ptrb

tia_write_table
{00}            long    t_vsync   |                 %0 << 10 ' VSYNC  : vertical sync set-clear (D1)
{01}            long    t_vblank  |                 %0 << 10 ' VBLANK : vertical blank set-clear (D7-6,D1)
{02}            long    t_wsync   |                 %0 << 10 ' WSYNC  : wait for leading edge of hrz. blank (strobe)
{03}            long    i_nop                                ' RSYNC  : reset hrz. sync counter (strobe)
{04}            long    t_nusiz0  |   %011_10000000_10 << 10 ' NUSIZ0 : number-size player-missle 0 (D5-0)
{05}            long    t_nusiz1  |  %01111_01000000_0 << 10 ' NUSIZ1 : number-size player-missle 1 (D5-0)
{06}            long    t_colu    |            %00_000 << 10 ' COLUP0 : color-lum player 0 (D7-1)
{07}            long    t_colu    |         %00_11_000 << 10 ' COLUP1 : color-lum player 1 (D7-1)

{08}            long    t_colu    |     %000_11_11_000 << 10 ' COLUPF : color-lum playfield (D7-1)
{09}            long    t_colu    |   %0_111_11_11_100 << 10 ' COLUBK : color-lum background (D7-1)
{0A}            long    t_ctrlpf  |  %111_000000000000 << 10 ' CTRLPF : cntrl playfield ballsize & coll. (D5-4,D2-0)
{0B}            long    t_refp    |               %000 << 10 ' REFP0  : reflect player 0 (D3)
{0C}            long    t_refp    |             %00110 << 10 ' REFP1  : reflect player 1 (D3)
{0D}            long    t_pf0     |               %110 << 10 ' PF0    : playfield register byte 0 (D7-4)
{0E}            long    t_pf1     |                %10 << 10 ' PF1    : playfield register byte 1 (D7-0)
{0F}            long    t_pf2     |                 %0 << 10 ' PF2    : playfield register byte 2 (D7-0)

{10}            long    t_res     |          %0_110000 << 10 ' RESP0  : reset player 0 (strobe)
{11}            long    t_res     |         %01_101000 << 10 ' RESP1  : reset player 1 (strobe)
{12}            long    t_res     |        %011_011000 << 10 ' RESM0  : reset missle 0 (strobe)
{13}            long    t_res     |       %0111_011000 << 10 ' RESM1  : reset missle 1 (strobe)
{14}            long    t_res     |      %01111_011000 << 10 ' RESBL  : reset ball (strobe)
{15}            long    t_aud0    |           %0_110_0 << 10 ' AUDC0  : audio control 0 (D3-0)
{16}            long    t_aud1    |           %0_110_0 << 10 ' AUDC1  : audio control 1 (D4-0)
{17}            long    t_aud0    |           %0_101_0 << 10 ' AUDF0  : audio frequency 0 (D4-0)

{18}            long    t_aud1    |           %0_101_0 << 10 ' AUDF1  : audio frequency 1 (D3-0)
{19}            long    t_aud0    |           %0_011_0 << 10 ' AUDV0  : audio volume 0 (D3-0)
{1A}            long    t_aud1    |           %0_011_0 << 10 ' AUDV1  : audio volume 1 (D3-0)
{1B}            long    t_grp0    |                 %0 << 10 ' GRP0   : graphics player 0 (D7-0)
{1C}            long    t_grp1    |                 %0 << 10 ' GRP1   : graphics player 1 (D7-0)
{1D}            long    t_enam0   |                 %0 << 10 ' ENAM0  : graphics (enable) missle 0 (D1)
{1E}            long    t_enam1   |                 %0 << 10 ' ENAM1  : graphics (enable) missle 1 (D1)
{1F}            long    t_enabl   |                 %0 << 10 ' ENABL  : graphics (enable) ball (D1)

{20}            long    t_hm      |               %0_0 << 10 ' HMP0   : horizontal motion player 0 (D7-4)
{21}            long    t_hm      |              %01_0 << 10 ' HMP1   : horizontal motion player 1 (D7-4)
{22}            long    t_hm      |             %011_0 << 10 ' HMM0   : horizontal motion missle 0 (D7-4)
{23}            long    t_hm      |            %0111_0 << 10 ' HMM1   : horizontal motion missle 1 (D7-4)
{24}            long    t_hm      |           %01111_0 << 10 ' HMBL   : horizontal motion ball (D7-4)
{25}            long    t_vdelp0  |                 %0 << 10 ' VDELP0 : vertical delay player 0 (D0)
{26}            long    t_vdelp1  |                 %0 << 10 ' VDELP1 : vertical delay player 1 (D0)
{27}            long    t_vdelbl  |                 %0 << 10 ' VDELBL : vertical delay ball (D0)

{28}            long    t_resmp0  |                 %0 << 10 ' RESMP0 : reset missle 0 to player 0 (D1)
{29}            long    t_resmp1  |                 %0 << 10 ' RESMP1 : reset missle 1 to player 1 (D1)
{2A}            long    t_hmove   |                 %0 << 10 ' HMOVE  : apply horizontal motion (strobe)
{2B}            long    t_hmclr   |                 %0 << 10 ' HMCLR  : clear horizontal motion registers (strobe)
{2C}            long    t_cxclr   |                 %0 << 10 ' CXCLR  : clear collision latches (strobe)
{2D}            long    i_nop
{2E}            long    i_nop
{2F}            long    i_nop

{30}            long    i_nop
{31}            long    i_nop
{32}            long    i_nop
{33}            long    i_nop
{34}            long    i_nop
{35}            long    i_nop
{36}            long    i_nop
{37}            long    i_nop

{38}            long    i_nop
{39}            long    i_nop
{3A}            long    i_nop
{3B}            long    i_nop
{3C}            long    i_nop
{3D}            long    i_nop
{3E}            long    i_nop
{3F}            long    i_nop

CON ' M6532 Register names

    SWCHA    = $00
    SWACNT   = $01
    SWCHB    = $02
    SWBCNT   = $03
    INTIM    = $04
    TIMINT   = $05
    TIM1T    = $14
    TIM8T    = $15
    TIM64T   = $16
    TIM1024T = $17

CON ' TIA Register names

    VSYNC    = $00    ' Write: vertical sync set-clear (D1)
    VBLANK   = $01    ' Write: vertical blank set-clear (D7-6,D1)
    WSYNC    = $02    ' Write: wait for leading edge of hrz. blank (strobe)
    RSYNC    = $03    ' Write: reset hrz. sync counter (strobe)
    NUSIZ0   = $04    ' Write: number-size player-missle 0 (D5-0)
    NUSIZ1   = $05    ' Write: number-size player-missle 1 (D5-0)
    COLUP0   = $06    ' Write: color-lum player 0 (D7-1)
    COLUP1   = $07    ' Write: color-lum player 1 (D7-1)
    COLUPF   = $08    ' Write: color-lum playfield (D7-1)
    COLUBK   = $09    ' Write: color-lum background (D7-1)
    CTRLPF   = $0A    ' Write: cntrl playfield ballsize & coll. (D5-4,D2-0)
    REFP0    = $0B    ' Write: reflect player 0 (D3)
    REFP1    = $0C    ' Write: reflect player 1 (D3)
    PF0      = $0D    ' Write: playfield register byte 0 (D7-4)
    PF1      = $0E    ' Write: playfield register byte 1 (D7-0)
    PF2      = $0F    ' Write: playfield register byte 2 (D7-0)
    RESP0    = $10    ' Write: reset player 0 (strobe)
    RESP1    = $11    ' Write: reset player 1 (strobe)
    RESM0    = $12    ' Write: reset missle 0 (strobe)
    RESM1    = $13    ' Write: reset missle 1 (strobe)
    RESBL    = $14    ' Write: reset ball (strobe)
    AUDC0    = $15    ' Write: audio control 0 (D3-0)
    AUDC1    = $16    ' Write: audio control 1 (D4-0)
    AUDF0    = $17    ' Write: audio frequency 0 (D4-0)
    AUDF1    = $18    ' Write: audio frequency 1 (D3-0)
    AUDV0    = $19    ' Write: audio volume 0 (D3-0)
    AUDV1    = $1A    ' Write: audio volume 1 (D3-0)
    GRP0     = $1B    ' Write: graphics player 0 (D7-0)
    GRP1     = $1C    ' Write: graphics player 1 (D7-0)
    ENAM0    = $1D    ' Write: graphics (enable) missle 0 (D1)
    ENAM1    = $1E    ' Write: graphics (enable) missle 1 (D1)
    ENABL    = $1F    ' Write: graphics (enable) ball (D1)
    HMP0     = $20    ' Write: horizontal motion player 0 (D7-4)
    HMP1     = $21    ' Write: horizontal motion player 1 (D7-4)
    HMM0     = $22    ' Write: horizontal motion missle 0 (D7-4)
    HMM1     = $23    ' Write: horizontal motion missle 1 (D7-4)
    HMBL     = $24    ' Write: horizontal motion ball (D7-4)
    VDELP0   = $25    ' Write: vertical delay player 0 (D0)
    VDELP1   = $26    ' Write: vertical delay player 1 (D0)
    VDELBL   = $27    ' Write: vertical delay ball (D0)
    RESMP0   = $28    ' Write: reset missle 0 to player 0 (D1)
    RESMP1   = $29    ' Write: reset missle 1 to player 1 (D1)
    HMOVE    = $2A    ' Write: apply horizontal motion (strobe)
    HMCLR    = $2B    ' Write: clear horizontal motion registers (strobe)
    CXCLR    = $2C    ' Write: clear collision latches (strobe)

    CXM0P    = $00    ' Read collision: D7=(M0,P1); D6=(M0,P0)
    CXM1P    = $01    ' Read collision: D7=(M1,P0); D6=(M1,P1)
    CXP0FB   = $02    ' Read collision: D7=(P0,PF); D6=(P0,BL)
    CXP1FB   = $03    ' Read collision: D7=(P1,PF); D6=(P1,BL)
    CXM0FB   = $04    ' Read collision: D7=(M0,PF); D6=(M0,BL)
    CXM1FB   = $05    ' Read collision: D7=(M1,PF); D6=(M1,BL)
    CXBLPF   = $06    ' Read collision: D7=(BL,PF); D6=(unused)
    CXPPMM   = $07    ' Read collision: D7=(P0,P1); D6=(M0,M1)
    INPT0    = $08    ' Read pot port: D7
    INPT1    = $09    ' Read pot port: D7
    INPT2    = $0A    ' Read pot port: D7
    INPT3    = $0B    ' Read pot port: D7
    INPT4    = $0C    ' Read P0 joystick trigger: D7
    INPT5    = $0D    ' Read P1 joystick trigger: D7

DAT             ' Audio Driver
                org     $000

audio_driver
                fltl    basePin
                wrpin   arg1, basePin
                wxpin   sampleRate, basePin
                wypin   dac_center, basePin
                drvh    basePin

                mov     ptra, #@tia_aud0

                mov     currentSample, #0
                mov     dividerCnt0, #1
                mov     dividerCnt1, #1

mainLoop
                rdlong  aud0, ptra[0]
                rdlong  aud1, ptra[1]

                mov     mixOut, dac_center

                ' Channel 0

                sub     dividerCnt0, #1     wcz
        if_a    jmp     #.mix

                getbyte arg1, aud0, #1          ' AUDF0
                and     arg1, #$1F
                add     arg1, #1
                add     dividerCnt0, arg1

                getnib  arg1, aud0, #0          ' AUDC0
                cmp     arg1, #$01          wz
        if_e    jmp     #.poly4
                cmp     arg1, #$02          wz
        if_e    jmp     #.div15poly4
                cmp     arg1, #$03          wz
        if_e    jmp     #.div5poly4
                cmp     arg1, #$04          wz
        if_ne   cmp     arg1, #$05          wz
        if_e    jmp     #.tone2
                cmp     arg1, #$06          wz
        if_ne   cmp     arg1, #$0A          wz
        if_e    jmp     #.tone31
                cmp     arg1, #$07          wz
        if_ne   cmp     arg1, #$09          wz
        if_e    jmp     #.poly5
                cmp     arg1, #$08          wz
        if_e    jmp     #.poly9
                cmp     arg1, #$0C          wz
        if_ne   cmp     arg1, #$0D          wz
        if_e    jmp     #.tone6
                cmp     arg1, #$0E          wz
        if_e    jmp     #.div93
                cmp     arg1, #$0F          wz
        if_e    jmp     #.poly5div6
                ' default
.silence        bith    currentSample, #0
                jmp     #.mix

.poly4          incmod  .poly4cnt, #15
.poly4cur       testb   .poly4str, .poly4cnt    wz
                bitz    currentSample, #0
                jmp     #.mix

.poly4cnt       long    14
.poly4str       long    %111100010011010

.div15poly4     testb   .tone31stream, .tone31cnt   wc
                incmod  .tone31cnt, #30
                testb   .tone31stream, .tone31cnt   wz
    if_c_ne_z   jmp     #.poly4
                jmp     #.poly4cur

.div5poly4      incmod  .poly5cnt, #31
                testb   .poly5str, .poly5cnt    wc
        if_1x   jmp     #.poly4
                jmp     #.poly4cur

.tone2          bitnot  currentSample, #0
                jmp     #.mix

.tone31         incmod  .tone31cnt, #30
                testb   .tone31stream, .tone31cnt   wz
                bitz    currentSample, #0
                jmp     #.mix

.tone31cnt      long    30
.tone31stream   long    %1111111111111111110000000000000

.poly5          incmod  .poly5cnt, #31
                testb   .poly5str, .poly5cnt    wz
                bitz    currentSample, #0
                jmp     #.mix

.poly5cnt       long    30
.poly5str       long    %1111100011011101010000100101100

.poly9          testb   .p9, #0         wz
                testb   .p9, #0         wc
                testb   .p9, #4         xorc
                shr     .p9, #1
        if_0x   and     .p9, #$0FF
        if_1x   or      .p9, #$100
                bitz    currentSample, #0
                jmp     #.mix
.p9             long    $1FF


.poly5div6      incmod  .poly5cnt, #31
                testb   .poly5str, .poly5cnt    wc
        if_nc   jmp     #.tone6cur
                ' fall-through
.tone6          decmod  .tone6cnt, #3-1     wc
        if_c    bitnot  .tonecur, #6
.tone6cur       testb   .tonecur, #6        wz
                bitz    currentSample, #0
                jmp     #.mix

.tone6cnt       long    0

.div93          testb   .tone31stream, .tone31cnt   wc
                incmod  .tone31cnt, #30
                testb   .tone31stream, .tone31cnt   wz
    if_c_ne_z   jmp     #.tone6
                jmp     #.tone6cur

.tonecur        long    0

.mix            testb   currentSample, #0   wz
                getbyte arg1, aud0, #2          ' AUDV0
                alts    arg1, #amplitudeTable
                sumz    mixOut, 0-0

                ' Channel 1
_ch1
                sub     dividerCnt1, #1     wcz
        if_a    jmp     #.mix

                getbyte arg1, aud1, #1          ' AUDF1
                and     arg1, #$1F
                add     arg1, #1
                add     dividerCnt1, arg1

                getnib  arg1, aud1, #0          ' AUDC1
                cmp     arg1, #$01          wz
        if_e    jmp     #.poly4
                cmp     arg1, #$02          wz
        if_e    jmp     #.div15poly4
                cmp     arg1, #$03          wz
        if_e    jmp     #.div5poly4
                cmp     arg1, #$04          wz
        if_ne   cmp     arg1, #$05          wz
        if_e    jmp     #.tone2
                cmp     arg1, #$06          wz
        if_ne   cmp     arg1, #$0A          wz
        if_e    jmp     #.tone31
                cmp     arg1, #$07          wz
        if_ne   cmp     arg1, #$09          wz
        if_e    jmp     #.poly5
                cmp     arg1, #$08          wz
        if_e    jmp     #.poly9
                cmp     arg1, #$0C          wz
        if_ne   cmp     arg1, #$0D          wz
        if_e    jmp     #.tone6
                cmp     arg1, #$0E          wz
        if_e    jmp     #.div93
                cmp     arg1, #$0F          wz
        if_e    jmp     #.poly5div6
                ' default
.silence        bith    currentSample, #1
                jmp     #.mix

.poly4          incmod  .poly4cnt, #15
.poly4cur       testb   .poly4str, .poly4cnt    wz
                bitz    currentSample, #1
                jmp     #.mix

.poly4cnt       long    14
.poly4str       long    %111100010011010

.div15poly4     testb   .tone31stream, .tone31cnt   wc
                incmod  .tone31cnt, #30
                testb   .tone31stream, .tone31cnt   wz
    if_c_ne_z   jmp     #.poly4
                jmp     #.poly4cur

.div5poly4      incmod  .poly5cnt, #31
                testb   .poly5str, .poly5cnt    wc
        if_1x   jmp     #.poly4
                jmp     #.poly4cur

.tone2          bitnot  currentSample, #1
                jmp     #.mix

.tone31         incmod  .tone31cnt, #30
                testb   .tone31stream, .tone31cnt   wz
                bitz    currentSample, #1
                jmp     #.mix

.tone31cnt      long    30
.tone31stream   long    %1111111111111111110000000000000

.poly5          incmod  .poly5cnt, #31
                testb   .poly5str, .poly5cnt    wz
                bitz    currentSample, #1
                jmp     #.mix

.poly5cnt       long    30
.poly5str       long    %1111100011011101010000100101100

.poly9          testb   .p9, #0         wz
                testb   .p9, #0         wc
                testb   .p9, #4         xorc
                shr     .p9, #1
        if_0x   and     .p9, #$0FF
        if_1x   or      .p9, #$100
                bitz    currentSample, #1
                jmp     #.mix
.p9             long    $1FF


.poly5div6      incmod  .poly5cnt, #31
                testb   .poly5str, .poly5cnt    wc
        if_nc   jmp     #.tone6cur
                ' fall-through
.tone6          decmod  .tone6cnt, #3-1     wc
        if_c    bitnot  .tonecur, #6
.tone6cur       testb   .tonecur, #6        wz
                bitz    currentSample, #1
                jmp     #.mix

.tone6cnt       long    0

.div93          testb   .tone31stream, .tone31cnt   wc
                incmod  .tone31cnt, #30
                testb   .tone31stream, .tone31cnt   wz
    if_c_ne_z   jmp     #.tone6
                jmp     #.tone6cur

.tonecur        long    0

.mix            testb   currentSample, #1   wz
                getbyte arg1, aud1, #2          ' AUDV1
                alts    arg1, #amplitudeTable
                sumz    mixOut, 0-0

                cmp     mixOut, prevMixOut  wz
        if_ne   mul     mixOut, #7
        if_ne   add     mixOut, prevMixOut
        if_ne   shr     mixOut, #3
                mov     prevMixOut, mixOut

                testp   basePin             wc
        if_nc   jmp     #$ - 1
                wypin   mixOut, basePin
                jmp     #mainLoop

amplitudeTable  long    trunc(AMPLITUDE_LEVEL_0)
                long    trunc(AMPLITUDE_LEVEL_1)
                long    trunc(AMPLITUDE_LEVEL_2)
                long    trunc(AMPLITUDE_LEVEL_3)
                long    trunc(AMPLITUDE_LEVEL_4)
                long    trunc(AMPLITUDE_LEVEL_5)
                long    trunc(AMPLITUDE_LEVEL_6)
                long    trunc(AMPLITUDE_LEVEL_7)
                long    trunc(AMPLITUDE_LEVEL_8)
                long    trunc(AMPLITUDE_LEVEL_9)
                long    trunc(AMPLITUDE_LEVEL_A)
                long    trunc(AMPLITUDE_LEVEL_B)
                long    trunc(AMPLITUDE_LEVEL_C)
                long    trunc(AMPLITUDE_LEVEL_D)
                long    trunc(AMPLITUDE_LEVEL_E)
                long    trunc(AMPLITUDE_LEVEL_F)

basePin         long    AUDIO_BASE_PIN addpins 1
sampleRate      long    _CLKFREQ / SAMPLE_RATE
dac_center      long    $7F80

arg1            long    P_DAC_75R_2V | P_OE | P_DAC_DITHER_PWM

aud0            long    $00_00_00_00
aud1            long    $00_00_00_00
                '           || || ++ (B0) AUDCx
                '           || ++--- (B1) AUDFx
                '           ++------ (B2) AUDVx

dividerCnt0     res     1
dividerCnt1     res     1

currentSample   res     1
mixOut          res     1
prevMixOut      res     1

CON

    PSG_FREQ    = 3_579_545.0               ' Clock frequency input on the emulated chip
    SAMPLE_RATE = round(PSG_FREQ / 114.0)   ' Sample rate (PSG_FREQ / 114.0)

    VOLUME_CORRECTION = 0.7                 ' Volume correction value
    MAX_AMPLITUDE     = float($7F7F / 2)    ' maxDACvalue / numberOfChannels (this makes room for maximum "swing" on all channels)
    AMPLITUDE_DAMP_FACTOR = MAX_AMPLITUDE / 15 ' The damp factor between each volume step

    AMPLITUDE_LEVEL_F = MAX_AMPLITUDE'     * VOLUME_CORRECTION
    AMPLITUDE_LEVEL_E = AMPLITUDE_LEVEL_F - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_D = AMPLITUDE_LEVEL_E - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_C = AMPLITUDE_LEVEL_D - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_B = AMPLITUDE_LEVEL_C - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_A = AMPLITUDE_LEVEL_B - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_9 = AMPLITUDE_LEVEL_A - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_8 = AMPLITUDE_LEVEL_9 - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_7 = AMPLITUDE_LEVEL_8 - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_6 = AMPLITUDE_LEVEL_7 - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_5 = AMPLITUDE_LEVEL_6 - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_4 = AMPLITUDE_LEVEL_5 - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_3 = AMPLITUDE_LEVEL_4 - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_2 = AMPLITUDE_LEVEL_3 - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_1 = AMPLITUDE_LEVEL_2 - AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_0 = 0.0

DAT             ' USB Host driver
                org     $000

usb_host_start
                mov     hcog_base_addr, ptrb

                mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
                shr     htmp, #2                        ' so byte->long for the lut cell count
                loc     pb, #@hlut_start - @usb_host_start
                add     pb, hcog_base_addr
                setq2   htmp
                rdlong  0, pb                           ' Do the hub->lut copy

                loc     pb, #@usb_host_init - @usb_host_start
                add     pb, hcog_base_addr
                jmp     pb                              ' Initialize host and enter main processing loop

'------------------------------------------------------------------------------
' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
' special because the receiving function must not respond with either STALL or
' NAK, and must accept the DATAx packet that follows the SETUP token. If a
' non-control endpoint receives a SETUP token, or the function receives a
' corrupt packet, it must ignore the transaction
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data struct.
' On exit:
'   retval - PID_ACK on success, otherwise error code.
'------------------------------------------------------------------------------
txn_setup
                setbyte ep_addr_pid, #PID_SETUP, #0
                mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
                bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
                mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
                mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
.setup
                call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
                cmp     retval, #PID_ACK        wz
        if_z    ret
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    ret
                mov     ptra, pa                        ' Restore SETUP's DATAx pointer
                jmp     #.setup

'------------------------------------------------------------------------------
' IN/INTERRUPT transaction.
' Possible function response: STALL or NAK handshake, or DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
' On exit:
'------------------------------------------------------------------------------
txn_in
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                setbyte ep_addr_pid, #PID_IN, #0
                call    #utx_token                      ' Put IN request on the bus

                ' Fall through to urx_packet

'------------------------------------------------------------------------------
' Wait for a packet from a device/function. As host, the only two packet types
' received are handshakes and IN DATAx.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'     returned.
'------------------------------------------------------------------------------
urx_packet
                rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
                testb   urx, #SOPB              wc
        if_c    jmp     #urx_packet
                getct   hct2
                addct2  hct2, tat_wait                  ' Start the response turn-around timer
                bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
                mov     newb_flg, #0                    ' Initialize for multi-byte read
.wait_sop
                rdpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #.get_pid
                jnct2   #.wait_sop
        _ret_   mov     retval, #ERR_TAT
.get_pid
                call    #urx_next
                testb   urx, #BUS_ERRB          wc
        if_nc   jmp     #.chk_pid
        _ret_   mov     retval, #ERR_URX
.chk_pid
                cmp     retval, #PID_ACK        wz
        if_nz   cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
                testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
                cmp     retval, #PID_DATA0      wz
   if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
   if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
                cmp     retval, #PID_DATA1      wz
   if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
   if_z_and_nc  jmp     #.ack_resend
        _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
.ack_resend
                rqpin   urx, dm
                testb   urx, #EOPB              wc
        if_nc   jmp     #.ack_resend
                mov     retval, #PID_ACK
                call    #utx_handshake                  ' Send handshake PID and return to caller
        _ret_   mov     retval, #ERR_DATAX_SYNC
.chk_eop
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
                call    #urx_next                       ' Low-speed requires an additional read to get EOP status
                testb   hstatus, #EOPB          wc
        if_c    jmp     #.idle                          ' Low-speed EOP seen
                testb   urx, #BUS_ERRB          wz
        if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
        if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
                ret
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
                ret

'------------------------------------------------------------------------------
' Send a token packet with CRC5 checksum of address and endpoint. It is the
' responsibility of the caller to append the appropriate inter-packet delay,
' if one is required.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - packed with the PID, address and endpoint.
' On exit:
'------------------------------------------------------------------------------
utx_token
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #utx_token
                testb   hstatus, #DWNSTRM_HUBB  wc
        if_c    call    #utx_pre
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     htmp, ep_addr_pid               ' Preserve the PID and destination
                mov     pkt_cnt, #3
.next_byte
                getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
                shr     htmp, #8                        ' Shift to next byte to send
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   utx, dm
        _ret_   djnz    pkt_cnt, #.next_byte

'------------------------------------------------------------------------------
' SETUP/OUT/INTERRUPT transaction.
' Possible function response in order of precedence: STALL, ACK, NAK.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
'   PTRA - start address of the data buff/struct that has the bytes to send.
'   pkt_data - count of DATAx payload bytes to send.
' On exit:
'------------------------------------------------------------------------------
txn_out
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                call    #utx_token                      ' Put SETUP/OUT token on the bus
                rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
                mov     pkt_cnt, pkt_data

                ' Fall through to utx_data

'------------------------------------------------------------------------------
' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
' calculated while the data byte is being shifted out. Since data stage
' success/fail is not determined until the status stage of the transaction,
' this routine is only concerned about the current DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - hub start address of the data to read.
'   pkt_cnt - data payload size.
' On exit:
'------------------------------------------------------------------------------
utx_data
                rqpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #utx_data
                mov     hctwait, ip_delay
                call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
                testb   hstatus, #DWNSTRM_HUBB  wc
        if_c    call    #utx_pre
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                bmask   crc, #15                        ' Prime the CRC16 pump
                testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
        if_nc   mov     utx, #PID_DATA0
        if_c    mov     utx, #PID_DATA1
                call    #utx_byte                       ' No CRC calc done on PID
                cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
        if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
.read_byte
                rfbyte  utx                             ' Fetch data byte
                call    #utx_byte
                rev     utx                             ' Calculate CRC while the data is shifting out
                setq    utx                             ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
                djnz    pkt_cnt, #.read_byte
.send_crc
                bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
                getbyte utx, crc, #0
                call    #utx_byte
                getbyte utx, crc, #1
                call    #utx_byte                       ' Last CRC byte out
                jmp     #urx_packet                     ' Handle function response/error and back to caller

'------------------------------------------------------------------------------
' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
' payload bytes are received. The routine reads bytes until EOP is detected and
' expects that the packet includes at least the CRC word.
'
' In control transfers, it's possible to recieve fewer data bytes than what
' was requested, which makes it difficult to determine where the data stops
' and the CRC word begins. So the CRC calculation is done on every byte of the
' packet, including the CRC word. The CRC value should then be equal to the
' USB-16 expected residual value of 0xB001.
'
' The routine writes the IN packet data to a static max_packet_size buffer
' so the caller can verify IN success before writing the data to its final
' destination.
'------------------------------------------------------------------------------
' On entry:
'   pkt_data - max byte count expected to be in the packet.
'   newb_flg - signals new byte ready when toggled.
' On exit:
'   pkt_cnt - actual number of bytes read.
'------------------------------------------------------------------------------
urx_data
                mov     htmp2, pb
                mov     pb, urx_buff_p
                wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
                mov     pb, htmp2
                bmask   crc, #15                        ' Prime the CRC16 pump
                mov     pkt_cnt, #0                     ' Keep track of payload bytes received
                mov     pkt_tmp, pkt_data
                add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
.wait_byte
' In-line rx for max speed
                rqpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   jmp     #.get_byte                      ' New byte!
                testb   urx, #EOPB              wc
        if_c    jmp     #.chk_crc                       ' At end-of-packet
                jmp     #.wait_byte
.get_byte
                getbyte retval, urx, #1                 ' New byte from smart pins
                wfbyte  retval                          ' Add it to the data buffer
                rev     retval                          ' Calculate CRC while next byte is shifting in
                setq    retval                          ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
.end_crc
                add     pkt_cnt, #1
                cmp     pkt_cnt, pkt_tmp        wcz
        if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
        if_a    ret
' For full-speed at 80MHz, the time it takes to do the final byte write and
' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
' to miss it, so cheat a bit and look for SOP clear here.
                rqpin   urx, dm
                testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
        if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
.chk_crc
                sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
                xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
        if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
                mov     retval, #PID_ACK
                mov     hctwait, ip_delay
                call    #poll_waitx

                ' Fall through to utx_handshake

'------------------------------------------------------------------------------
' Transmit a handshake PID. The routine assumes that the bus is IDLE and
' the appropriate IP delay has been inserted.
'------------------------------------------------------------------------------
' On entry:
'   retval - handshake PID to send.
' On exit:
'   retval unchanged.
'------------------------------------------------------------------------------
utx_handshake
                testb   hstatus, #DWNSTRM_HUBB  wc
        if_c    call    #utx_pre
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                mov     utx, retval
                call    #utx_byte                       ' Send handshake PID
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
                mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
                jmp     #poll_waitx

'------------------------------------------------------------------------------
' Wait for the USB tx buffer to empty and feed it a new byte.
'------------------------------------------------------------------------------
' On entry:
'   utx - byte to transmit.
' On exit:
'------------------------------------------------------------------------------
utx_byte
                testp   dp                      wc
        if_nc   jmp     #utx_byte
                akpin   dp
                waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
        _ret_   wypin   utx, dm

'------------------------------------------------------------------------------
' Fetch the next data byte of a packet. Always check receiver status for EOP.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the byte read.
'   urx - the receiver status. The caller must check the hstatus reg EOP flag
'     on return. If EOP is set, the byte in reg retval remains as the last byte
'     received.
'------------------------------------------------------------------------------
urx_next
                rdpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
        if_nz   ret                                     ' New byte is priority, so return now
                testb   urx, #SOPB              wc
                testb   urx, #BUS_ERRB          wz
   if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
        if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
                ret

'------------------------------------------------------------------------------
' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
' the data used for the USB-5 CRC lookups. The token packet is three bytes in
' length, and the PID is not included in the CRC calculation:
'  CRC5  FRAME_NUMBER SOF (full-speed)
'  CRC5  ENDP ADDRESS PID
' %00000_1111_1111111_xxxxxxxx
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - stuffed with the function endpoint, address and
'     SETUP/IN/OUT/SOF PID according to the USB standard.
' On exit:
'   ep_addr_pid - CRC value appended to the packet.
'------------------------------------------------------------------------------
calc_crc5
                and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
                mov     htmp, ep_addr_pid
                shr     htmp, #8                        ' PID not included in CRC calc
                mov     crc, #$1f                       ' Initial CRC5 value
                rev     htmp                            ' Input data reflected
                setq    htmp                            ' CRCNIB setup for data bits 0..7
                crcnib  crc, #USB5_POLY
                crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
                shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
                crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                xor     crc, #$1f                       ' Final XOR value
                shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
        _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home

'------------------------------------------------------------------------------
' Full-speed/low-speed frame timing interrupt service routine.
'------------------------------------------------------------------------------
isr1_fsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                mov     utx, #PID_SOF
                wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
                call    #utx_byte                       ' Send token PID byte
                mov     icrc, #$1f                      ' Prime the CRC5 pump
                mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
                rev     sof_pkt                         ' Input data reflected
                setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
                crcnib  icrc, #USB5_POLY
                crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
                getbyte utx, frame, #0                  ' Send the low byte of the frame number
                call    #utx_byte
                shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
                rep     #2, #3                          ' Three data bits left to process
                shl     sof_pkt, #1             wc
                crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
                xor     icrc, #$1f                      ' Final XOR value
                getbyte utx, frame, #1                  ' Send remaining frame number bits
                shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
                or      utx, icrc
                call    #utx_byte                       ' Last start-of-frame byte is on the wire
                mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
                jmp     #isr1_wait
isr1_lsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
                mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
isr1_wait
                rqpin   utx, dm
                testb   utx, #SOPB                 wc
        if_c    jmp     #isr1_wait
                add     frame, #1                       ' Next frame# and check for wrap around
                zerox   frame, #10
                waitx   isrtmp1                         ' Make sure bus is idle
                reti1

'------------------------------------------------------------------------------
' Wait for a window within the 1ms frame boundary that will ensure that a
' transaction will complete before the next frame is triggered.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
wait_txn_ok
                getct   htmp2
                sub     htmp2, iframe_ct_base
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    cmp     htmp2, _txn_ok_ls_      wcz
        if_nc   cmp     htmp2, _txn_ok_fs_      wcz
        if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
                ret

'------------------------------------------------------------------------------
' A device connection was detected, or a bus reset was requested by the USB
' client. Set the appropriate smart pin FS/LS speed mode to match the device
' and perform a reset sequence prior to device enumeration.
'------------------------------------------------------------------------------
dev_reset
                rqpin   urx, dm
                testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
        if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
        if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
reset
                setint1 #0                              ' Don't want frame interrupt while in reset
                wypin   #OUT_SE0, dm                    ' Assert bus reset
                waitx   _reset_hold_                    ' Spec is >= 10ms
                wypin   #OUT_IDLE, dm
                mov     frame, #0                       ' Reset the frame timespan count
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
                add     htmp, #36
                setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
.framewait
                cmp     frame, htmp             wcz
        if_b    jmp     #.framewait
                ret

'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - source address.
'   PB - destination address.
'   hr0 - length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
hmemcpy
                rdbyte  htmp, ptra++
                wrbyte  htmp, pb
                add     pb, #1
        _ret_   djnz    hr0, #hmemcpy

'------------------------------------------------------------------------------
' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
' loop until the errant device is disconnected.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
host_error
                drvl    host_error_led
                jmp     #host_reset                     ' See if it works...

' USB commands and error codes
cmd_data        long    0
usb_err_code    long    ERR_NONE

' Parameters block assigned at cog startup
dm              long    USB_BASE_PIN + 2    ' Client defines the basepin for four consecutive USB port pins
dp              long    USB_BASE_PIN + 3
usb_event_pin   long    USB_BASE_PIN        ' Host event reporting uses a long repository smart pin
host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
hid_descr_p     long    0, 0[7]
hid_report_p    long    0, 0[7]
hub_descr_p     long    0
urx_buff_p      long    0
dev_desc_buff_p long    0
con_desc_buff_p long    0
cache_start_p   long    0
cache_end_p     long    0

hdev_init_start
hdev_port       long    0
hdev_next_datax long    0, 0
hub_intf_num    long    0
hub_next_datax  long    0
hub_status_chg  long    0
hub_port_status long    0
ms_intf_num     long    0
ms_in_max_pkt   long    0
kb_intf_num     long    0
kb_interval     long    0
kb_in_max_pkt   long    0
kb_max_index    long    0
kb_led_states   long    0
kbm_next_datax  long    0
gp_intf_num     long    0
gp_interval     long    0
gp_max_index    long    0
gp_descr_len    long    0, 0[7]
hdev_init_end

hidr_start
hidr_id         long    0
hidr_axis       long    0[3]
hidr_buttons    long    0
hidr_hats       long    0
hidr_flags      long    0
hidr_state      long    0
hidr_size       long    0
hidr_count      long    0
hidr_offset     long    0
hidr_usage      long    0
hidr_usage_idx  long    0
hidr_lminmax    long    0
hidr_pminmax    long    0
hidr_end

' Initialized at cog startup:
save_sysclk     long    0         ' Save the current sysclock as the client may change it
hcog_base_addr  long    0         ' This object's start address in hub, read from PTRB at cog creation
iframe_ct_new   long    0
iframe_ct_base  long    0
p2rev_val       long    P2RevB
utx_tweak       long    0         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
' This register block is reset to zero when a USB device connects
hreg_init_start
hstatus         long    0         ' Host status flags
hctwait         long    0         ' Poll-based wait clocks
ip_delay        long    0         ' Inter-packet delay in bit periods for connected device speed
tat_wait        long    0         ' Maximum bus turn-around time in bit periods for connected device speed
nak_retry       long    0         ' NAK retry count, unlimited retries if zero
xfer_retry      long    0         ' Control transfer retry count
retry           long    0         ' Transaction retry count
utx             long    0         ' Byte to transmit on USB
urx             long    0         ' LSByte receiver status flags, MSByte received data
newb_flg        long    0         ' Receive "new byte" bit toggle detector
max_pkt_size    long    0         ' Maximum payload bytes allowed, likely to change on device connect.
total_data      long    0         ' Total bytes to tx/rx in a transfer data stage
stage_data      long    0         ' Count of bytes sent/received so far during a data stage.
pkt_data        long    0         ' Payload size of an OUT packet or bytes received on IN
frame           long    0         ' USB 1ms frame counter value
sof_pkt         long    0         ' ISR frame# packet and CRC5
icrc            long    0         ' Only used by the 1ms frame output ISR routine
pkt_cnt         long    0         ' Count of DATAx packet payload bytes
crc             long    0         ' Used for CRC16 calculation
ep_addr_pid     long    0         ' Endpoint and device addresses for connected device
retval          long    0         ' Global success/fail return parameter
context_retval  long    0         ' Operation contextual return parameter
' Device stuff
hdev_id         long    0
hdev_bcd        long    0
hdev_type       long    0, 0      ' Configured device indicator
' Keyboard/mouse stuff
hctrl_ep_addr   long    0
hctrl_max_pkt   long    0
hconfig_base    long    0
hcon_tot_len    long    0         ' Size of the complete config descriptor chain
hdev_intf_idx   long    0         ' Used during verbose descriptor terminal output
hdev_class      long    0
hdev_subclass   long    0
hdev_protocol   long    0
hsearch_key     long    0         ' Descriptor type to search for in the config chain
hnext_desc      long    0         ' Offset from the config descriptor start address to the next descriptor in the chain
hhub_ctrl_ep    long    0         ' Hub control endpoint address
hhub_ep_addr    long    0         ' Hub interface endpoint address
hmouse_ep_addr  long    0         ' Mouse interface endpoint address
hkbd_ctrl_ep    long    0         ' Keyboard control endpoint address
hkbd_ep_addr    long    0         ' Keyboard interface endpoint address
hkbd_poll_cnt   long    0         ' Poll interval counter used for key auto-repeat
hkbd_ledstates  long    0         ' Off/on state of keyboard LEDs
hdev_ep_addr    long    0, 0[7]
hdev_out_addr   long    0
hreg_init_end
' Variables dependent on the system freqency
_var_64_lower_  res     1
_var_64_upper_  res     1
_12Mbps_        res     1
_1_5Mbps_       res     1
_1ns16fp_       res     1         ' 1ns as 32,16 fixed point
_1us_           res     1         ' 1us
_10us_          res     1         ' 10us
_33us_          res     1         ' 33us
_txn_err_       res     1         ' 250us
_500us_         res     1         ' 500us
_txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
_txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
_ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
_ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
_tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
_tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
_preamble_wait_ res     1
_1ms_           res     1         ' 1ms
_2ms_           res     1         ' 2ms
_suspend_wait_  res     1         ' 3ms
_4ms_           res     1         ' 4ms
_xfer_wait_     res     1         ' 5ms
_8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
_reset_hold_    res     1         ' 15ms
_resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
_21ms_          res     1         ' 21ms
_100ms_         res     1         ' 100ms
_500ms_         res     1         ' 500ms
_pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
_frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'------------------------------------------------------------------------------
_usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
_usb_d_ls_nco_  res     1
_usb_h_fs_nco_  res     1
_usb_d_fs_nco_  res     1
'------------------------------------------------------------------------------
' Scratch registers
htmp            res     1         ' Scratch registers whose context remains within the same code block
htmp1           res     1
htmp2           res     1
htmp3           res     1
hrep            res     1         ' Repeat count
hsave0          res     1         ' Subroutine parameter saves
hsave1          res     1
hsave2          res     1
isrtmp1         res     1
pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
hr0             res     1         ' Multi-purpose registers
hr1             res     1
hr2             res     1
hr3             res     1
hpar1           res     1         ' Routine entry/exit parameters
hpar2           res     1
hpar3           res     1
hct2            res     1         ' Function response bus turn-around timer
hct3            res     1         ' Keyboard/mouse poll timer
mod_cnt         res     1         ' Used in idle loops

                fit     $1F0

DAT             ' USB Host LUT execution
                org     $200
hlut_start

'------------------------------------------------------------------------------
' Full-speed is the host's native speed, so all that is needed is to set the FS
' settings to startup defaults.
'------------------------------------------------------------------------------
' On entry:
' On exit: Save/restore caller C flag state if C is changed in this routine!
'------------------------------------------------------------------------------
set_speed_full
                mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
'                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' When a low-speed device connects, the D-/D+ signaling is inverted. If there
' is a downstream hub connected (not yet implemented), the baud generator
' remains set at the full-speed rate, but signaling is switched to low-speed,
' which reverses the D-/D+ polarity. The polarity can be changed without
' putting the smart pins into reset.
'------------------------------------------------------------------------------
' On entry:
' On exit: CZ flags restored to caller states
'------------------------------------------------------------------------------
set_speed_low
                test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
        if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
                testb   p2rev_val, #0           wc      ' P2 Revision is either %0001 (A) or %0010 (B+)
        if_c    dirl    dm                              ' P2RevA needs to be completely reconfigured
        if_c    dirl    dp
        if_c    wrpin   ##USB_V1HMODE_LS, dm            ' Low-speed signaling is always used
        if_c    wrpin   ##USB_V1HMODE_LS, dp
        if_c    wxpin   _1_5Mbps_, dm                   ' Set 1.5Mbs baud if no downstream hub
        if_c    dirh    dm
        if_c    dirh    dp
        if_nc   wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
                bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' Perform configuration stuff required when a device intitially connects.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
on_connect
                mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
                call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
.retry
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
        if_nc   mov     hpar1, #USB_SPEED_FULL
                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.get_dev_desc
                mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
                call    #poll_waitx
                sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
        if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
                call    #reset                          ' Try another reset to see if the device responds
                jmp     #.retry
.get_dev_desc
                mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
                call    #reset
                loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
                add     ptra, hcog_base_addr
                wrword  #8, ptra[wValue]                ' Only support one device port at this time
                call    #control_write                  ' Execute SetAddress()
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctwait, _8ms_
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
                call    #calc_crc5
                loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
                add     ptra, hcog_base_addr
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
                mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
                rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
                mov     hctwait, _500us_
                call    #poll_waitx
                loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   ret
                mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
                mov     hconfig_base, ptra              ' Will need this for configuration
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    mov     retval, #ERR_CONFIG_FAIL
        if_b    jmp     #host_error
                loc     pa, #@init_kbdm_data - @usb_host_start
                add     pa, hcog_base_addr
                call    pa
                loc     pa, #@hparse_con_desc - @usb_host_start
                add     pa, hcog_base_addr
                jmp     pa

'------------------------------------------------------------------------------
' Perform a control read transaction (Section 8.5.3, Figure 8-37).
' Status reporting is always in the function-to-host direction.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data in hub.
'   PB - start address of the buffer/struct to be written to during the IN data
'     stage.
'   ep_addr_pid - device address, endpoint and CRC5.
' On exit:
'   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'     contains the count of data stage bytes actually received, which must
'     always be <= the count requested.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_read
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb                       ' Save dest buffer pointer
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                mov     nak_retry, ##IN_NAK_RETRIES
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
.nak_retry
                mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
.in_retry
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' Commit on ACK
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak_retry                     ' Function not ready to send data
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.in_retry                      ' Bus error retry
                ret                                     ' The transfer has failed
.commit
                cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
        if_z    jmp     #.pre_status                    ' and also end-of-data
                mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
                mov     hr0, pkt_cnt
                cmp     ptra, pb                wz
        if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
                add     stage_data, pkt_cnt             ' Update bytes received on commit
                cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
        if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
                cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
        if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
        if_a    mov     retval, #ERR_PACKET
        if_a    mov     context_retval, retval          ' In this case overall and context are the same
        if_a    ret                                     ' Caller must handle ERR_PACKET
                bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
                jmp     #.data                          ' Start next IN transaction
.pre_status
                mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
                setbyte ep_addr_pid, #PID_OUT, #0
                mov     pkt_data, #0
                bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
                mov     nak_retry, ##OUT_NAK_RETRIES
.out_retry
                call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
                cmp     retval, #PID_ACK        wz
        if_z    ret                                     ' All is good when ACK
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
                ret                                     ' Caller must handle transfer retirement
' I've encountered transfer STALL, even though the data looks correct, and
' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
' ControlRead() transfer gets things unstuck most of the time...
.xfer_retry
                mov     hctwait, _xfer_wait_
                call    #poll_waitx
                call    #wait_txn_ok
                mov     ep_addr_pid, hpar1
                mov     ptra, hpar2
                mov     pb, hpar3
                djnz    xfer_retry, #.xfer_start
                mov     context_retval, retval          ' Preserve the USB error code
        _ret_   mov     retval, #ERR_XFER_RETRY

'------------------------------------------------------------------------------
' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
' reporting is always in the function-to-host direction. It is assumed that
' the SETUP data struct is filled with the required values.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to the start of the struct for the SETUP data.
'   PB - the start address of the struct/buffer to be read for the OUT data
'     stage.
'   ep_addr_pid - the proper CRC'd address and endpoint to use.
' On exit:
'   retval - used to convey the success/failure of each stage.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_write
                testb   ep_addr_pid, #31        wc
        if_c    bith    hstatus, #DWNSTRM_HUBB
        if_c    bith    _usb_h_ls_nco_, #14

                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
.out_retry
                mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
                call    #txn_out
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit                        ' Function got the data
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
        if_nz   jmp     #.out_retry
                jmp     #dwnstream_reset                ' Caller must handle transfer retirement
.commit
                mov     pb, ptra                        ' Save the current buffer/struct location
                add     stage_data, pkt_data
                cmp     stage_data, total_data  wz
        if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
        if_nz   jmp     #.data                          ' More data to send
pre_status_in
                bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.status_retry
                mov     pkt_data, #0
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
        if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
        if_z    jmp     #dwnstream_reset                ' Control Write finished
                cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
        if_z    jmp     #dwnstream_reset
                call    #retry_wait                     ' NAK or bus error, so delay a bit
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.status_retry
'                ret                                     ' Caller must handle transfer retirement

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - The function address and endpoint for the IN request.
'   hpar2 - Address of the IN data buffer
'   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
' On exit:
'   retval - the result of the operation.
'   hpar3 - the count of IN data bytes actually received.
'------------------------------------------------------------------------------
do_int_in
                testb   ep_addr_pid, #31        wc
        if_c    bith    hstatus, #DWNSTRM_HUBB
        if_c    bith    _usb_h_ls_nco_, #14

                getword htmp, hpar3, #0
                cmp     htmp, #PID_DATA0        wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
                mov     retry, #TXN_RETRIES
.retry
                getword pkt_data, hpar3, #1             ' IN max packet length
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK if data received
        if_z    jmp     #.commit
                cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
        if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
        if_z    jmp     #.post_ret                      ' The caller must handle either
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    jmp     #.post_ret
                jmp     #.retry
.commit
                mov     ptra, urx_buff_p                ' Copy the rx buffer
                mov     pb, hpar2                       ' to the destination buffer
                mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
        if_nz   cmp     ptra, pb                wz
        if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
.post_ret
                mov     hpar3, pkt_cnt                  ' IN bytes actually received

'------------------------------------------------------------------------------
' Resets the downstream hub port to FS
'------------------------------------------------------------------------------
dwnstream_reset
                testb   ep_addr_pid, #31        wc
        if_nc   ret                                     ' No LS device, reset not needed
                bitl    _usb_h_ls_nco_, #14
                bitl    hstatus, #DWNSTRM_HUBB
                wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods

'------------------------------------------------------------------------------
' The one millisecond frame timer is implemented as an interrupt service
' routine. Since this timing is critical, care must be taken to avoid any
' instructions that can delay the interrupt branch, which will likely upset
' the timer. WAITX is among those instructions, so any time you're inside
' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'------------------------------------------------------------------------------
' On entry:
'   hctwait - wait interval in sysclocks.
' On exit:
'------------------------------------------------------------------------------
poll_waitx
                getct   hct2
                addct2  hct2, hctwait
.wait
                jnct2   #.wait
                ret

'------------------------------------------------------------------------------
' Transaction retry handling for NAK/STALL or bus error.
'------------------------------------------------------------------------------
' On entry:
'   retval - transaction response PID or error code.
' On exit:
'------------------------------------------------------------------------------
retry_wait
                cmp     retval, #PID_STALL      wz
        if_z    ret                                     ' STALL is special case
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak
                mov     hctwait, _txn_err_              ' Transaction error wait...
                call    #poll_waitx
.dec
                sub     retry, #1               wz
        if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
                ret                                     ' Retry result to caller
.nak
                mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
                call    #poll_waitx
                cmp     nak_retry, #NAK_NOLIMIT wz
        if_z    ret                                     ' Indefinite NAK retries
                sub     nak_retry, #1           wz
        if_z    mov     retval, #ERR_NAK
                ret

host_reset
                setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
                mov     htmp, ##_CLKFREQ                ' Get current sysclock setting
' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
                cmp     htmp, ##168_000_000     wcz
        if_be   mov     utx_tweak, #0
        if_a    mov     utx_tweak, #3   '#20
' Check to see if the system clock has been changed.
                cmp     htmp, save_sysclk       wz
        if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
        if_nz   add     pb, hcog_base_addr
        if_nz   call    pb                              ' Recalculate sysclk dependent timing values
                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                cmp     p2rev_val, #P2RevB      wz
        if_z    jmp     #.not_reva
                wrpin   ##USB_V1HMODE_FS, dm            ' The host is also the root hub, so full-speed is its native speed
                wrpin   ##USB_V1HMODE_FS, dp
                wxpin   _12Mbps_, dm                    ' Default to Full-Speed
                jmp     #.enable
.not_reva
                wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
                wrpin   ##USB_V2_DRVOUT, dp
                wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
.enable
                dirh    dm                              ' Crank them smart pins up
                dirh    dp
                waitx   _1us_
                wypin   #OUT_IDLE, dm

                ' Handle Port protection enable and startup delay
                mov     htmp, usb_event_pin             ' I/O + 1 pin is the Serial Host USB Protection enable/disable
                add     htmp, #1                        ' Protection enable is a one-time operation
                drvl    htmp                            ' disable port
                waitx   _21ms_                          ' Wait a while for everything to turn off
                drvh    htmp                            ' Enable the port
                waitx   _21ms_                          ' Hold to let the idle state get settled

                setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
                rep     @.regloop,#hreg_init_end - hreg_init_start
                alti    pa, #%000_111_000
                mov     0-0, #0
.regloop

discon_entry
                mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one

                ' Fall through to disconnected loop

'-----------------------------------------------------------------------------------------------------------------
' Device connect handling (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
' device to connect (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
disconnected
                mov     hr1, ##_CLKFREQ                 ' Check to see if the system frequency has changed
                cmp     hr1, save_sysclk        wz
        if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
                shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
                waitx   hr1                             ' it down to smaller wait chunks
                incmod  mod_cnt, #8             wc
        if_c    drvnot  host_active_led
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
        if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
        if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
.se1_test
                mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
                call    #poll_waitx
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
        if_ne   jmp     #discon_entry                   ' Back to connect detection loop
.se1            'SE1 is a fatal error condition
                mov     hctwait, _100ms_
                call    #poll_waitx
                mov     retval, #ERR_SE1
                call    #host_error                     ' Seeing SE1 for any length of time is not good...
.connect_test                                           ' Test lines until stable J/K state seen
                waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_z    jmp     #discon_entry                   ' D+ and D- low
        if_e    jmp     #.se1_test                      ' D+ and D- high
connected
                bith    hstatus, #CONNECTEDB            ' Device plugged in
                call    #on_connect                     ' Initial device configuration
                cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
        if_nz   jmp     #discon_entry
.set_pulse
                getct   _pulse_time_
                add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
' of 1ms and make a correction, if necessary.
'                mov     htmp, _1ms_
'                subs    htmp, iframe_delta
'                adds    _frame1ms_clks_, htmp
'                debug(udec(_frame1ms_clks_))

                ' Fall through to idle/processing loop

                cmp     hdev_port, #7           wcz
        if_a    mov     hdev_port, #0

hidle
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_c    jmp     #.se0_test
                pollct3                         wc
        if_nc   jmp     #.nopoll
                getct   hct3
                addct3  hct3, _1ms_                     ' Set the timer for next poll interval

                altgb   hdev_port, #hdev_type
                getbyte htmp

                cmp     htmp, #HID_READY        wz
        if_nz   cmp     htmp, #PS3_READY        wz
        if_nz   cmp     htmp, #XINPUT_READY     wz
                loc     pa, #@hget_gp_in_report - @usb_host_start
        if_z    jmp     #.poll

                cmp     htmp, #HUB_READY        wz
                loc     pa, #@hget_hub_status - @usb_host_start
        if_z    jmp     #.poll

                cmp     htmp, #KB_READY         wz
                loc     pa, #@hget_kbd_in_report - @usb_host_start
        if_z    jmp     #.poll

                cmp     htmp, #M_READY          wz
                loc     pa, #@hget_mouse_in_report - @usb_host_start
        if_z    jmp     #.poll

                cmp     htmp, #KBM_READY        wz
        if_nz   jmp     #.next
                bitnot  hstatus, #KBM_TOGGLEB   wcz
        if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
        if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
.poll
                add     pa, hcog_base_addr
                call    pa
.next
                incmod  hdev_port, #7

.nopoll
                cmp     cmd_data, #CMD_SUSPEND  wz
        if_z    jmp     #hsuspend
                cmp     cmd_data, #CMD_RESET    wz
        if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
        if_z    jmp     #host_reset                     ' See if it works...
                getct   hr0
                cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
        if_ae   drvnot  host_active_led
        if_ae   getct   _pulse_time_
        if_ae   add     _pulse_time_, _500ms_
                jmp     #hidle
' Check for extended SE0 state on the bus
.se0_test
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Wait a bit and test for SE0 again
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #hidle                          ' Bus still IDLE
                call    #wait_txn_ok
                wypin   ##OUT_IDLE, dm                  ' Float USB
                wxpin   #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
                jmp     #host_reset                     ' Device disconnected

hsuspend
                call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
                setint1 #0                              ' Stopping the 1ms frame packets signals suspend
                waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
                wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
                mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
                mov     mod_cnt, #0

                ' Fall through to resume wait loop

hwait_resume
                mov     hr1, ##_CLKFREQ                 ' Use the CLKFREQ value, as the sysclock may change
                shr     hr1, #2
                waitx   hr1                             ' Pulse the activity LED every two seconds but break
                incmod  mod_cnt, #8             wc      ' it down to smaller wait chunks
        if_c    drvnot  host_active_led
                cmp     cmd_data, #CMD_RESUME   wz
        if_nz   jmp     #hwait_resume
                mov     htmp, ##_CLKFREQ                ' Check to see if the system frequency has changed
                cmp     htmp, save_sysclk       wz
        if_z    jmp     #.resume
                loc     pb, #@hinit_usb_timings - @usb_host_start
                add     pb, hcog_base_addr
                call    pb                              ' Recalculate sysclk dependent timing values
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
        if_c    wxpin   _usb_h_ls_nco_, dm
.resume
                wypin   #OUT_K, dm
                waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
                wypin   #OUT_SE0, dm
                mov     htmp, _ip_delay_ls_
                shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
                waitx   htmp
                wypin   #OUT_J, dm
                shr     htmp, #1
                waitx   htmp
                wypin   #OUT_IDLE, dm
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                setint1 #1                              ' Enable the 1ms frame ISR
                mov     hctwait, _4ms_
                call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
        _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete

'------------------------------------------------------------------------------
' Send preamble to enable low-speed HUB ports
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   USB baud rate set to low-speed
'------------------------------------------------------------------------------
utx_pre
                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                wrpin   #0, dm                          ' Disable smartpin mode
                wrpin   #0, dp
                drvl    dm
                drvh    dp

                mov     htmp, ##OUT_SOP | (PID_PRE << 8)

                rep     @.l1, #16 + 1
                shr     htmp, #1        wc
        if_nc   setq    #1
        if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
                waitx   _preamble_wait_
.l1

                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
                wrpin   ##USB_V2_DRVOUT, dp
                wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
                dirh    dm                              ' Crank them smart pins up
                dirh    dp
                wypin   #OUT_IDLE, dm

                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods

hlut_end
                fit     $400

DAT             ' USB Host HUB execution
                orgh
'------------------------------------------------------------------------------
' Routines called from cog space.
'------------------------------------------------------------------------------
' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'------------------------------------------------------------------------------

'------------------------------------------------------------------------------
' USB host cog initialization.
'------------------------------------------------------------------------------
usb_host_init
                loc     pb, #hid_descr                  ' Initialize buffer pointers
                mov     hid_descr_p, pb
                add     pb, #HID_DESCR_LEN
                mov     hid_descr_p + 1, pb
                add     pb, #HID_DESCR_LEN
                mov     hid_descr_p + 2, pb
                add     pb, #HID_DESCR_LEN
                mov     hid_descr_p + 3, pb
                add     pb, #HID_DESCR_LEN
                mov     hid_descr_p + 4, pb
                add     pb, #HID_DESCR_LEN
                mov     hid_descr_p + 5, pb
                add     pb, #HID_DESCR_LEN
                mov     hid_descr_p + 6, pb
                add     pb, #HID_DESCR_LEN
                mov     hid_descr_p + 7, pb

                loc     pb, #hid_report
                mov     hid_report_p, pb
                add     pb, #HID_IN_RPT_LEN
                mov     hid_report_p + 1, pb
                add     pb, #HID_IN_RPT_LEN
                mov     hid_report_p + 2, pb
                add     pb, #HID_IN_RPT_LEN
                mov     hid_report_p + 3, pb
                add     pb, #HID_IN_RPT_LEN
                mov     hid_report_p + 4, pb
                add     pb, #HID_IN_RPT_LEN
                mov     hid_report_p + 5, pb
                add     pb, #HID_IN_RPT_LEN
                mov     hid_report_p + 6, pb
                add     pb, #HID_IN_RPT_LEN
                mov     hid_report_p + 7, pb

                loc     pb, #hub_descr
                mov     hub_descr_p, pb
                loc     pb, #urx_buff
                mov     urx_buff_p, pb
                loc     pb, #dev_desc_buff
                mov     dev_desc_buff_p, pb
                loc     pb, #con_desc_buff
                mov     con_desc_buff_p, pb
                loc     pb, #usb_cache_start
                mov     cache_start_p, pb
                loc     pb, #usb_cache_end
                mov     cache_end_p, pb

                drvl    host_error_led                  ' Ensure fatal error LED is inactive
'                mov     p2rev_val, ptrb                 ' Running on P2RevA or P2RevB+ silicon?
'                setq    #1
'                rdlong  $1e0, ptrb++
'                subr    p2rev_val, ptrb
'                shr     p2rev_val, #2           wz      ' RevA if shift result is zero
'        if_z    mov     p2rev_val, #P2RevA              ' 1 == RevA, 2 == RevB+
'                loc     ptrb, #p2rev_char               ' Make a revision "A" or "B" char accessible to Spin2
'                mov     htmp, p2rev_val
'                add     htmp, #"@"
'                wrbyte  htmp, ptrb
                dirl    usb_event_pin                   ' Configure the USB event mailbox smart pin
                wrpin   ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
                dirh    usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
' Configure and enable the Serial Host USB port.
                jmp     #host_reset                     ' Initialize host and enter main processing loop

'------------------------------------------------------------------------------
' Timing calculations happen before any interrupt(s) are enabled.
'------------------------------------------------------------------------------
' On entry:
'   htmp - current CLKFREQ value.
'------------------------------------------------------------------------------
hinit_usb_timings
'                getct   htmp2
                mov     save_sysclk, htmp
                qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
                getqx   _12Mbps_
                shr     _12Mbps_, #16           wc
                addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
                mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
                shl     _usb_h_fs_nco_, #14
                add     _usb_h_fs_nco_, _12Mbps_
                mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
                shl     _usb_d_fs_nco_, #14
                add     _usb_d_fs_nco_, _12Mbps_
                mov     _1_5Mbps_, _12Mbps_
                shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
                mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
                shl     _usb_h_ls_nco_, #14
                add     _usb_h_ls_nco_, _1_5Mbps_
                mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
                qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1b
                getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1m
                getqx   _1us_                           ' 1us as 32,9 fixed point
                mov     hsave0, _1us_                   ' Save it to compute other us values
                shr     _1us_, #9               wc
                addx    _1us_, #0                       ' Round to final value
                qmul    hsave0, #10                     ' Calc 10us
                getqx   _10us_
                shr     _10us_, #9              wc
                addx    _10us_, #0                      ' 10us
                qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
                getqx   _33us_
                shr     _33us_, #9              wc
                addx    _33us_, #0                      ' 33us
                qmul    hsave0, #250                    ' Calc 250us
                getqx   _txn_err_
                shr     _txn_err_, #9           wc
                addx    _txn_err_, #0                   ' 250us
                qmul    hsave0, #500                    ' Calc 500us
                getqx   _500us_
                shr     _500us_, #9             wc
                addx    _500us_, #0                     ' 500us
                qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
                getqx   _txn_ok_ls_
                shr     _txn_ok_ls_, #9         wc
                addx    _txn_ok_ls_, #0                 ' 666us
                qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
                getqx   _txn_ok_fs_
                shr     _txn_ok_fs_, #9         wc
                addx    _txn_ok_fs_, #0                 ' 850us
                mov     _ip_delay_ls_, _1ns16fp_
                mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_ls_, #16      wc
                addx    _ip_delay_ls_, #0
                mov     _tat_wait_ls_, _1ns16fp_
                mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
                shr     _tat_wait_ls_, #16      wc
                addx    _tat_wait_ls_, #0
                mov     _ip_delay_fs_, _1ns16fp_
                mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_fs_, #16      wc
                addx    _ip_delay_fs_, #0
                mov     _tat_wait_fs_, _1ns16fp_
                mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
                shr     _tat_wait_fs_, #16      wc
                addx    _tat_wait_fs_, #0
                qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
                getqx   _preamble_wait_
                sub     _preamble_wait_,# 9 - 1
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1thou
                getqx   _1ms_                           ' 1ms as 32,9 fixed point
                shr     _1ms_, #9               wc
                addx    _1ms_, #0                       ' 1ms
                mov     _frame1ms_clks_, ##-14
                adds    _frame1ms_clks_, _1ms_
                mov     _2ms_, _1ms_
                shl     _2ms_, #1                       ' 2ms
                mov     _suspend_wait_, _1ms_
                add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
                mov     _4ms_, _1ms_
                shl     _4ms_, #2                       ' 4ms
                mov     _xfer_wait_, _4ms_
                add     _xfer_wait_, _1ms_              ' 5ms
                mov     _reset_hold_, _xfer_wait_       ' 5ms
                mov     _resume_hold_, _reset_hold_
                shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
                mov     _100ms_, _resume_hold_          ' 20ms
                shl     _100ms_, #1                     ' 40ms
                mov     _8ms_, _1ms_
                shl     _8ms_, #3                       ' 8ms
                shl     _reset_hold_, #1                ' 10ms
                add     _100ms_, _reset_hold_           ' 50ms
                add     _reset_hold_, _xfer_wait_       ' 15ms
                mov     _21ms_, _xfer_wait_             ' 5ms
                shl     _21ms_, #2                      ' 20ms
                add     _21ms_, _1ms_                   ' 21ms
                mov     _500ms_, _100ms_                ' 50ms
                shl     _100ms_, #1                     ' 100ms
                shl     _500ms_, #3                     ' 400ms
        _ret_   add     _500ms_, _100ms_                ' 500ms
'        _ret_   mov     _1sec_, save_sysclk
'        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'                ret
{
                getct   htmp
                sub     htmp, htmp2
        debug("USB timing calc sysclocks: ", udec( htmp))
                ret
}

'------------------------------------------------------------------------------
' Parse a configuration descriptor chain to see if the device is a recognized
' one. If it is, start the task progression that will configure the device for
' use.
'------------------------------------------------------------------------------
' On entry:
'   hconfig_base - start address of the cached config descriptor chain.
' On exit:
'------------------------------------------------------------------------------
hparse_con_desc
                mov     ptrb, dev_desc_buff_p
                rdlong  hdev_id, ptrb[2]                ' idVendor + idProduct
                movbyts hdev_id, #%%1032                ' |
                rdword  hdev_bcd, ptrb[6]               ' bcdDevice
                debug(uhex_long(hdev_id), uhex_word(hdev_bcd))

                mov     pa, #CON_wTotalLen
                add     pa, hconfig_base
                rdword  hcon_tot_len, pa                ' Keep config chain size handy
                debug(uhex_byte_array(hconfig_base, hcon_tot_len))
' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
' that defines a keyboard and/or mouse.
                rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
.next_intf
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #hset_config
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.intf
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                jmp     #.next_intf
.intf
                mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
                mov     hpar3, #0
                rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
                rdbyte  hdev_class, ptrb[INTF_bIntfClass]
                rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
                rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
                debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))

.endp
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #.get_device
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.get_device
                cmp     htmp, #TYPE_ENDPOINT    wz
        if_z    jmp     #.get_ep
                jmp     #.endp
.get_ep
                rdbyte  hr1, ptrb[ENDP_bAddress]
                testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
                shl     hr1, #8 + 7
                mov     htmp, hctrl_ep_addr
                and     htmp, ##ADDR_MASK
                or      htmp, hr1                       ' endpoint address
                cmp     hpar2, #0               wz
 if_z_and_c     jmp     #.in_ep
                cmp     hpar3, #0               wz
 if_z_and_nc    jmp     #.out_ep
                jmp     #.endp
.in_ep
                mov     hpar2, htmp                     ' IN endpoint
                rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr2, hr0, #3
                jmp     #.endp
.out_ep
                mov     hpar3, htmp                     ' OUT endpoint
                rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr3, hr0, #3
                jmp     #.endp

.get_device
                cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
        if_z    cmp     hdev_subclass, #$5D     wz
        if_z    cmp     hdev_protocol, #$01     wz
        if_z    jmp     #.gamepad
                cmp     hdev_class, #CLASS_HUB  wz
        if_z    jmp     #.hub
                cmp     hdev_class, #CLASS_HID              wz
        if_nz   jmp     #.next_intf                     ' No HID class, ignore
                cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
        if_z    cmp     hdev_protocol, #INTF_PROTO_NONE     wz
        if_z    jmp     #.gamepad
                cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
        if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
.keyboard
                cmp     hdev_protocol, #INTF_PROTO_KBD      wz
        if_nz   jmp     #.mouse                         ' No Keyboard
                cmp     hkbd_ep_addr, #0    wz
        if_nz   jmp     #.next_intf
                getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
                getbyte kb_interval, hr2, #3
                getbyte kb_in_max_pkt, hr2, #0
                mov     hkbd_ep_addr, hpar2             ' IN endpoint address
                'debug(udec(kb_intf_num))
                debug(uhex_long(hkbd_ep_addr),uhex_long(hdev_out_addr),udec(kb_in_max_pkt,kb_interval))
                debug(uhex_long(hdev_ep_addr),uhex_long_(hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4))
                jmp     #.next_intf
.mouse
                cmp     hdev_protocol, #INTF_PROTO_MOUSE    wz
        if_nz   jmp     #.next_intf                     ' No Mouse
                cmp     hmouse_ep_addr, #0      wz
        if_nz   jmp     #.next_intf
                getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
                'getbyte ms_interval, hr2, #3
                getbyte ms_in_max_pkt, hr2, #0
                mov     hmouse_ep_addr, hpar2           ' IN endpoint address
                'debug(udec(kb_intf_num))
                debug(uhex_long(hmouse_ep_addr),udec(ms_in_max_pkt))
                debug(uhex_long(hdev_ep_addr),uhex_long_(hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4))
                jmp     #.next_intf
.gamepad
                cmp     hdev_port, #4           wcz     ' Limit to ports (0)1-4
        if_a    jmp     #.next_intf                     ' |
                mov     htmp1, hpar2
                and     htmp1, ##ADDR_MASK
                mov     htmp, hkbd_ep_addr              ' Skip if keyboard hid interface
                and     htmp, ##ADDR_MASK               ' |
                cmp     htmp, htmp1             wz      ' |
        if_z    jmp     #.next_intf
                mov     htmp, hmouse_ep_addr            ' Skip if mouse hid interface
                and     htmp, ##ADDR_MASK               ' |
                cmp     htmp, htmp1             wz      ' |
        if_z    jmp     #.next_intf
                altd    hdev_port, #hdev_ep_addr        ' Skip if already set
                cmp     0-0, #0                 wz      ' |
        if_nz   jmp     #.next_intf
                getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
                getbyte gp_interval, hr2, #3
                altd    hdev_port, #hdev_ep_addr
                mov     0-0, hpar2                      ' IN endpoint address
                mov     hdev_out_addr, hpar3            ' OUT endpoint address
                'debug(udec(gp_intf_num))
                debug(uhex_long(hdev_ep_addr),uhex_long_(hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4),udec(gp_interval),uhex_long(hdev_out_addr))
                jmp     #.next_intf
.hub
                cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
        if_nz   jmp     #.next_intf
                cmp     hdev_protocol, #INTF_PROTO_NONE     wz
        if_nz   cmp     hdev_protocol, #2                   wz
        if_nz   jmp     #.next_intf
                cmp     hhub_ep_addr, #0    wz
        if_nz   jmp     #.next_intf
                getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
                mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
                mov     ep_addr_pid, hpar2              ' IN endpoint address
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                mov     hhub_ep_addr, ep_addr_pid
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
                debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
                debug(uhex_long(hdev_ep_addr),uhex_long_(hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4))
                jmp     #.next_intf

'------------------------------------------------------------------------------
' If a newly-connected device is recognized, do whatever is needed to configure
' it according to its function, or functions. In the case of this boot protocol
' keyboard/mouse class driver:
' - SetConfiguration(config_num)
' - SetProtocol(boot)
' - SetIdle(indefinite)
' - Enter the device interrupt IN polling task stage.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hset_config
                mov     htmp2, #DEV_UNKNOWN
                altd    hdev_port, #hdev_ep_addr
                cmp     0-0, #0                 wz
        if_z    cmp     hkbd_ep_addr, #0        wz
        if_z    cmp     hmouse_ep_addr, #0      wz
        if_z    cmp     hhub_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No known device
.set_config
                loc     ptra, #set_config
                mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
                add     pa, hconfig_base
                rdbyte  hpar1, pa
                wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
                mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
                mov     pb, #0                          ' SetConfiguration() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   ret
.kbd_config
                cmp     hkbd_ep_addr, #0        wz
        if_z    jmp     #.mouse_config                  ' No keyboard
                mov     htmp, hkbd_ep_addr
                and     htmp, ##ADDR_MASK
                mov     htmp1, ep_addr_pid
                and     htmp1, ##ADDR_MASK
                cmp     htmp, htmp1             wz
        if_nz   jmp     #.mouse_config                  ' No keyboard

                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_protocol
                wrword  #BOOT_PROTOCOL, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                mov     pb, #0                          ' SetProtocol() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
                getbyte hpar2, kb_intf_num, #0
                call    #hset_idle
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hctwait, _2ms_
                call    #poll_waitx
                mov     kb_led_states, #LED_NUMLKF
                mov     hkbd_ledstates, kb_led_states
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     ep_addr_pid, hkbd_ep_addr
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                testb   hub_port_status, #HUB_PORT_LOWSPEED wc
                bitc    ep_addr_pid, #31
                mov     hkbd_ep_addr, ep_addr_pid
                mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
                bitc    hkbd_ctrl_ep, #31
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
                mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
                setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
                mov     htmp2, #KB_READY                ' Keyboard interface configured
                'jmp     #.notify_client
.mouse_config
                cmp     hmouse_ep_addr, #0      wz
        if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
                mov     htmp, hmouse_ep_addr
                and     htmp, ##ADDR_MASK
                mov     htmp1, ep_addr_pid
                and     htmp1, ##ADDR_MASK
                cmp     htmp, htmp1             wz
        if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected

                getbyte htmp, ms_intf_num, #0
                loc     ptra, #set_protocol
                wrword  #BOOT_PROTOCOL, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                mov     pb, #0                          ' SetProtocol() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hmouse_ep_addr, #0
        if_nz   jmp     #.notify_client
                cmp     hkbd_ep_addr, #0        wz      ' A SetIdle() duration of indefinite covers both keyboard and mouse
        if_nz   jmp     #.skip                          ' So skip if it has already been done
                mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
                getbyte hpar2, kb_intf_num, #0
                call    #hset_idle
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hmouse_ep_addr, #0
        if_nz   jmp     #.notify_client
.skip
                mov     ep_addr_pid, hmouse_ep_addr
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                testb   hub_port_status, #HUB_PORT_LOWSPEED wc
                bitc    ep_addr_pid, #31
                mov     hmouse_ep_addr, ep_addr_pid
                'mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
                setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
                cmp     hkbd_ep_addr, #0        wz
        if_nz   mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
        if_z    mov     htmp2, #M_READY                 ' Only the mouse interface configured
                jmp     #.notify_client
.gamepad_config
                altd    hdev_port, #hdev_ep_addr
                cmp     0-0, #0                 wz
        if_z    jmp     #.hub_config                    ' No gamepad
                alts    hdev_port, #hdev_ep_addr
                mov     htmp, 0-0
                and     htmp, ##ADDR_MASK
                mov     htmp1, ep_addr_pid
                and     htmp1, ##ADDR_MASK
                cmp     htmp, htmp1             wz
        if_nz   jmp     #.hub_config                    ' No gamepad

                alts    hdev_port, #hdev_ep_addr
                mov     ep_addr_pid, 0-0
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                testb   hub_port_status, #HUB_PORT_LOWSPEED wc
                bitc    ep_addr_pid, #31
                altd    hdev_port, #hdev_ep_addr
                mov     0-0, ep_addr_pid
                mov     ep_addr_pid, hdev_out_addr  wz
        if_nz   setbyte ep_addr_pid, #PID_OUT, #0
        if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
        if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
        if_nz   bitc    ep_addr_pid, #31
        if_nz   mov     hdev_out_addr, ep_addr_pid
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration

                cmp     hdev_class, #$FF        wz      ' XInput vendor class
        if_e    jmp     #.xinput
                cmp     hdev_id, ##$054C_0268   wz      ' PS3 vendor/product
        if_e    jmp     #.ps3

                loc     ptra, #get_desc                 ' Get HID descriptor
                wrword  #$FF, ptra[wLength]
                alts    hdev_port, #hid_descr_p
                mov     pb, 0-0
                call    #control_read
                cmp     retval, #PID_ACK        wz
        if_nz   altd    hdev_port, #hdev_ep_addr
        if_nz   mov     0-0, #0
        if_nz   jmp     #.notify_client
                altd    hdev_port, #gp_descr_len
                mov     0-0, total_data
                alts    hdev_port, #hid_descr_p
                mov     pb, 0-0
                debug(uhex(pb),uhex_byte_array(pb,total_data))

                mov     htmp2, #HID_READY               ' Standard gamepad
                jmp     #.notify_client
.xinput
                loc     ptra, #xinp_led_cmd             ' Turn on LED
                mov     pb, hdev_port
                cmpsub  pb, #1                          ' Root device is also player 1
                add     pb, #$06                        ' LED patterns 06..09 for players 1..4
                wrbyte  pb, ptra[2]

                mov     pkt_data, #3
                bitl    hstatus, #DATAx_TGLB
                mov     ep_addr_pid, hdev_out_addr
                call    #txn_out
                mov     ep_addr_pid, hctrl_ep_addr

                loc     ptra, #xinp_fix_8bitdo
                mov     pb, urx_buff_p                  ' We don't actually care where it goes
                call    #control_read                   ' Execute GetDeviceDescriptor()
                debug("8bitdo weird fix... ",uhex(retval))
                mov     retval, #PID_ACK                ' If we don't do this something else becomes sad (TODO fix?)

                mov     htmp2, #XINPUT_READY
                jmp     #.notify_client
.ps3
                loc     ptra, #ps3_command_buff         ' Turn on LED
                mov     pb, hdev_port
                fge     pb, #1                          ' Root device is also player 1
                'fle    pb, #4
                decod   pb
                wrbyte  pb, ptra[9]

                getbyte htmp, gp_intf_num, #0
                loc     ptra, #set_report
                wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                wrword  #48, ptra[wLength]
                loc     pb, #ps3_command_buff
                call    #control_write

                getbyte htmp, gp_intf_num, #0
                loc     ptra, #set_report
                wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                wrword  #4, ptra[wLength]
                loc     pb, #ps3_enable_cmd             ' Enable PS3
                call    #control_write
                cmp     retval, #PID_ACK    wz
        if_nz   altd    hdev_port, #hdev_ep_addr
        if_nz   mov     0-0, #0
        if_nz   jmp     #.notify_client

                mov     htmp2, #PS3_READY               ' PS3 gamepad ready
                jmp     #.notify_client

.hub_config
                cmp     hhub_ep_addr, #0    wz
        if_z    jmp     #.notify_client                 ' No HUB
                mov     htmp, hhub_ep_addr
                and     htmp, ##ADDR_MASK
                mov     htmp1, ep_addr_pid
                and     htmp1, ##ADDR_MASK
                cmp     htmp, htmp1             wz
        if_nz   jmp     #.notify_client                 ' No HUB

                loc     ptra, #get_hub_desc             ' Get HUB descriptor
                wrword  #$FF, ptra[wLength]
                mov     pb, hub_descr_p
                call    #control_read
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hhub_ep_addr, #0
        if_nz   jmp     #.notify_client

                mov     ptra, hub_descr_p
                rdbyte  htmp3, ptra[2]                  ' bNbrPorts
                fle     htmp3, #7                       ' Max. 7 ports supported
                debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
.loop
                loc     ptra, #set_port_feat            ' Power on ports
                wrword  #HUB_PORT_POWER, ptra[wValue]
                wrword  htmp3, ptra[wIndex]
                call    #control_write
                djnz    htmp3, #.loop

                mov     hctwait, _500ms_
                add     hctwait, _100ms_
                call    #poll_waitx

                mov     htmp2, #HUB_READY               ' Hub ready
                'jmp     #.notify_client

.notify_client
                altsb   hdev_port, #hdev_type
                setbyte htmp2                           ' Save device ready
                debug("hdev_type = ", uhex_long_(hdev_type+1,hdev_type))
        _ret_   wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured

'------------------------------------------------------------------------------
' Initialize the keyboard/mouse data area to start-up values.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
init_kbdm_data
                mov     hkbd_ep_addr, #0
                mov     hdev_ep_addr, #0

                mov     ptra, cache_start_p         ' Clear cached data buffers
                mov     pa, cache_end_p
.loop
                wrbyte  #0, ptra++
                cmp     ptra, pa                wcz
        if_b    jmp     #.loop

                mov     pa, #hdev_init_start        ' Clear device data registers
.regloop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hdev_init_end      wz
        if_nz   jmp     #.regloop

                setbyte hdev_next_datax, #PID_DATA0, #0         ' Reset interrupt IN datax sequence PIDs
                setbyte hdev_next_datax, #PID_DATA0, #1
                setbyte hdev_next_datax, #PID_DATA0, #2
                setbyte hdev_next_datax, #PID_DATA0, #3
                setbyte hdev_next_datax + 1, #PID_DATA0, #0
                setbyte hdev_next_datax + 1, #PID_DATA0, #1
                setbyte hdev_next_datax + 1, #PID_DATA0, #2
                setbyte hdev_next_datax + 1, #PID_DATA0, #3
                setbyte kbm_next_datax, #PID_DATA0, #0
                setbyte kbm_next_datax, #PID_DATA0, #1
        _ret_   mov     hub_next_datax, #PID_DATA0

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
' function.
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'   hpar2 - index number of the target interface.
' On exit:
'------------------------------------------------------------------------------
hset_idle
                mov     hctwait, _2ms_
                call    #poll_waitx
                loc     ptra, #set_idle
                wrword  hpar1, ptra[wValue]
                wrword  hpar2, ptra[wIndex]
                jmp     #control_write

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - device address and enpoint for the request.
' On exit:
'   retval - transaction result.
'------------------------------------------------------------------------------
hset_kbdled_report
                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_report
                wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
                wrword  htmp, ptra[wIndex]
                wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
                mov     pb, urx_buff_p
                wrbyte  kb_led_states, pb
                jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for keyboard activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_kbd_in_report
                mov     ep_addr_pid, hkbd_ep_addr
                mov     hpar2, urx_buff_p
                getbyte hpar3, kbm_next_datax, #0
                setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' No ACK, ignore
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet

                getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
                cmp     htmp, #PID_DATA0        wz      ' |
        if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
        if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |

                'debug("KBD: ", uhex_byte_array(urx_buff_p, hpar3))
                mov     kb_max_index, hpar3             ' Save actual bytes read
                call    #hkbd_compare
.led_check
                mov     htmp, kb_led_states
                cmp     hkbd_ledstates, htmp    wz
        if_z    ret                                     ' No toggle key indicator changes, so we're done
                mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
                mov     ep_addr_pid, hkbd_ctrl_ep
                jmp     #hset_kbdled_report             ' Set report and ignore errors

'------------------------------------------------------------------------------
' Compare current and previous keyboard data buffers for keypress changes.
'------------------------------------------------------------------------------
hkbd_compare
                mov     ptra, urx_buff_p
                alts    hdev_port, #hid_report_p
                mov     ptrb, 0-0
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
                cmp     htmp1, htmp2    wz
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
        if_z    cmp     htmp1, htmp2    wz
        if_z    ret

                alts    hdev_port, #hid_report_p
                mov     ptra, 0-0

                mov     hpar1, #0               ' Handle modifiers
                rdbyte  hpar2, urx_buff_p
                rdbyte  htmp1, ptra
                rolword htmp1, hpar2, #0
                mergew  htmp1
                mov     htmp, #0
                mov     pa, #8
.modloop
                rczr    htmp1           wcz     ' New value in C, old value in Z
                mov     hpar1, #$E8
                sub     hpar1, pa
   if_c_ne_z    call    #hkbd_translate
                djnz    pa, #.modloop

.release        modc    _set            wc
                'alts    hdev_port, #hid_report_p
                'mov     ptra, 0-0
                add     ptra, #2
                mov     pa, #6
.rl1            rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.rl3
                mov     ptrb, urx_buff_p
                add     ptrb, #2
                mov     pb, #6
.rl2            rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.rl3
                djnz    pb, #.rl2
                call    #hkbd_translate
.rl3            djnz    pa, #.rl1

                mov     hpar3, #0
                bith    hpar3, #31

.press          modc    _clr    wc
                mov     ptra, urx_buff_p
                add     ptra, #2
                mov     pa, #6
.pl1            rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.pl3
                alts    hdev_port, #hid_report_p
                mov     ptrb, 0-0
                add     ptrb, #2
                mov     pb, #6
.pl2            rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.pl3
                djnz    pb, #.pl2
                call    #hkbd_translate
.pl3            djnz    pa, #.pl1

.copy           mov     ptra, urx_buff_p
                alts    hdev_port, #hid_report_p
                mov     ptrb, 0-0
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++

                ret

'------------------------------------------------------------------------------
' Translate keyboard scancode to ASCII
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - scancode
'   hpar2 - key modifiers state
'       c - pressed (0) or released (1) flag
' On exit:
'   hr0 - bit     31 = 0 pressed, 1 released
'             27..24 = led state
'             23..16 = key modifiers state
'              15..8 = scancode
'               7..0 = ASCII key code (or 0 if none)
'------------------------------------------------------------------------------
hkbd_translate
                mov     hr0, #0
                setbyte hr0, hpar1, #1
                setbyte hr0, hpar2, #2
                bitc    hr0, #31

                cmp     hpar1, #KEY_CAPSLOCK    wz
  if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
                cmp     hpar1, #KEY_NUMLOCK     wz
  if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
                cmp     hpar1, #KEY_SCROLLLOCK  wz
  if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
                setnib  hr0, hkbd_ledstates, #6

                mov     htmp, hpar1
                shl     htmp, #1
                loc     pb, #kbd_table
                add     pb, htmp
                testb   hpar2, #LEFT_SHIFTB          wz
                testb   hpar2, #RIGHT_SHIFTB         orz
                testb   hkbd_ledstates, #LED_CAPSLKB xorz
        if_x1   add     pb, #1
                cmp     hpar1, #KEY_APP     wcz
        if_be   rdbyte  hr1, pb
        if_a    mov     hr1, #0
                setbyte hr0, hr1, #0

                testb   hr0, #31            wc
        if_c    jmp     #.l1
                debug(udec(hdev_port)," KEYBOARD PRESS scancode=", uhex_byte_(hpar1), ", key: ",uhex_byte_(hr1), ", mod: ",ubin_byte_(hpar2))
        if_nc   jmp     #.l2
.l1             debug(udec(hdev_port)," KEYBOARD REL   scancode=", uhex_byte_(hpar1), ", key: ",uhex_byte_(hr1), ", mod: ",ubin_byte_(hpar2))
.l2             ret

kbd_table ' Index is the key scan code
          {$00} word    $0000, $0000, $0000, $0000 ' $03
          {$04} word    $4161, $4262, $4363, $4464                                 ' $07: Aa Bb Cc Dd
          {$08} word    $4565, $4666, $4767, $4868, $4969, $4A6A, $4B6B, $4C6C     ' $0f: Ee Ff Gg Hh Ii Jj Kk Ll
          {$10} word    $4D6D, $4E6E, $4F6F, $5070, $5171, $5272, $5373, $5474     ' $17: Mm Nn Oo Pp Qq Rr Ss Tt
          {$18} word    $5575, $5676, $5777, $5878, $5979, $5A7A, $2131, $4032     ' $1f: Uu Vv Ww Xx Yy Zz !1 @2
          {$20} word    $2333, $2434, $2535, $5E36, $2637, $2A38, $2839, $2930     ' $27: #3 $4 %5 ^6 &7 *8 (9 )0
          {$28} word    $0D0D, $1B1B, $0808, $0909, $2020, $5F2D, $2B3D, $7B5B     ' $2f: Enter Esc BkSpc Tab Spc _- += {[
          {$30} word    $7D5D, $7C5C, $7E23, $3A3B, $2227, $7E60, $3C2C, $3E2E     ' $37: }] |\ ~# :; "' ~` <, >.
          {$38} word    $3F2F, $0000, $0000, $0000, $0000, $0000, $0000, $0000     ' $3f: ?/ CapsLock F1 F2 F3 F4 F5 F6
          {$40} word    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000     ' $47: F7 F8 F9 F10 F11 F12 PrtSc, ScrLk
          {$48} word    $0000, $0000, $0000, $0000, $7F7F, $0000, $0000, $0000     ' $4f: Pause, Ins, Home PgUp BkSpc_Del End PgDn Right
          {$50} word    $0000, $0000, $0000, $0000, $2F2F, $2A2A, $2D2D, $2B2B     ' $57: Left Down Up KpdNumLck Kp/ Kp* Kp- Kp+
          {$58} word    $0D0D, $3131, $3232, $3333, $5034, $3535, $3636, $3737     ' $5f: KpEnter Kp1_End Kp2_Down Kp3_PgDn Kp4_Left Kp5 Kp6_Right Kp7_Home
          {$60} word    $3838, $3939, $3030, $7F2E, $5C7C, $0000                   ' $65: Kp8_Up Kp9_PgUp Kp0_Ins Kp._Del Kp\_| App

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for mouse activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   hr0 - bit   7..0 = button state
'   hr1              = X direction and velocity (signed)
'   hr2              = Y direction and velocity (signed)
'   hr3              = Wheel direction and velocity (signed)
'------------------------------------------------------------------------------
hget_mouse_in_report
                mov     ep_addr_pid, hmouse_ep_addr
                mov     hpar2, urx_buff_p
                getbyte hpar3, kbm_next_datax, #1
                setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' No ACK, ignore
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet

                getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
                cmp     htmp, #PID_DATA0        wz      ' |
        if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
        if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |

                'debug("MS:  ", uhex_byte_array(urx_buff_p, hpar3))
                mov     ptra, urx_buff_p
                cmp     hpar3, #5               wcz     ' Combo PS/2-USB adapters adds report-id
        if_ae   add     ptra, #1                        ' | skip
                rdbyte  hr0, ptra++                     ' Button flags
                rdbyte  hr1, ptra++                     ' X direction and velocity is 8-bit signed
                signx   hr1, #7
                rdbyte  hr2, ptra++                     ' Y direction and velocity is 8-bit signed
                signx   hr2, #7
                cmp     hpar3, #4               wcz     ' Very few mice send +/- scroll wheel data in boot protocol
        if_ae   rdbyte  hr3, ptra
        if_z    signx   hr3, #7                         ' If it's there, use it
        if_nz   mov     hr3, #0
                debug(udec(hdev_port)," MOUSE btn=", ubin_byte_(hr0), ", X: ",sdec_(hr1), ", Y: ",sdec_(hr2), ", W: ",sdec_(hr3))
                ret

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for gamepad activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_gp_in_report
                alts    hdev_port, #hdev_ep_addr
                mov     ep_addr_pid, 0-0

                mov     hpar2, urx_buff_p
                altgb   hdev_port, #hdev_next_datax
                getbyte hpar3
                setword hpar3, #255, #1                 ' Always ask for max report size
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' No ACK, ignore
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet

                altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
                getbyte htmp                            ' |
                cmp     htmp, #PID_DATA0        wz      ' |
        if_z    mov     htmp, #PID_DATA1                ' |
        if_nz   mov     htmp, #PID_DATA0                ' |
                altsb   hdev_port, #hdev_next_datax     ' |
                setbyte htmp                            ' |

'------------------------------------------------------------------------------
' Decode controller report
'------------------------------------------------------------------------------
hid_decode
                mov     htmp, #hidr_start       ' clear all hid report registers
.cl             altd    htmp
                mov     0-0, #0
                add     htmp, #1
                cmp     htmp, #hidr_end         wz
        if_nz   jmp     #.cl

                mov     ptrb, urx_buff_p

                altgb   hdev_port, #hdev_type
                getbyte htmp
                cmp     htmp, #XINPUT_READY     wz
        if_z    jmp     #hpad_xinput
                cmp     htmp, #PS3_READY        wz
        if_z    jmp     #hpad_ps3

'------------------------------------------------------------------------------
' Handle HID controller
' On entry:
'   ptrb - controller report
'------------------------------------------------------------------------------
hpad_hid
                alts    hdev_port, #hid_descr_p
                mov     ptra, 0-0
                alts    hdev_port, #gp_descr_len
                mov     pa, 0-0
                'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
                mov     hidr_usage, ##$76543210

.next
                cmps    pa, #0      wcz
        if_be   jmp     #hpad_translate

                rdbyte  hpar1, ptra++
                sub     pa, #1
                mov     hpar2, #0

                mov     htmp, hpar1
                and     htmp, #$03
                cmp     htmp, #1    wz
        if_z    rdbyte  hpar2, ptra++
        if_z    sub     pa, #1
                cmp     htmp, #2    wz
        if_z    rdword  hpar2, ptra++
        if_z    sub     pa, #2
                cmp     htmp, #3    wz
        if_z    rdlong  hpar2, ptra++
        if_z    sub     pa, #4

                and     hpar1, #$FC
                'debug(uhex_byte(hpar1),uhex_long(hpar2))

                cmp     hpar1, #HID_REPORT_ID   wz
        if_z    jmp     #.report_id
                cmp     hpar1, #HID_USAGE_PAGE  wz
        if_z    jmp     #.usage_page
                cmp     hpar1, #HID_USAGE       wz
        if_z    jmp     #.usage
                cmp     hpar1, #HID_LOGICAL_MIN wz
        if_z    setword hidr_lminmax, hpar2, #1
                cmp     hpar1, #HID_LOGICAL_MAX wz
        if_z    setword hidr_lminmax, hpar2, #0
                cmp     hpar1, #HID_PHYSICAL_MIN wz
        if_z    setword hidr_pminmax, hpar2, #1
                cmp     hpar1, #HID_PHYSICAL_MAX wz
        if_z    setword hidr_pminmax, hpar2, #0
                cmp     hpar1, #HID_REPORT_SIZE wz
        if_z    mov     hidr_size, hpar2
                cmp     hpar1, #HID_REPORT_COUNT wz
        if_z    mov     hidr_count, hpar2
                cmp     hpar1, #HID_INPUT       wz
        if_nz   jmp     #.next

                and     hpar2, #$03
                cmp     hpar2, #HID_ITEM_VARIABLE   wz
        if_nz   jmp     #.skip

                cmp     hidr_state, #2  wz
        if_z    jmp     #.axes
                cmp     hidr_state, #3  wz
        if_z    jmp     #.hats
                cmp     hidr_state, #4  wz
        if_z    jmp     #.buttons
.skip
                mov     htmp, hidr_size
                mul     htmp, hidr_count
                add     hidr_offset, htmp
                jmp     #.next
.axes
                'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count))
                getnib  hr0, hidr_flags, #2
                mov     hr1, hidr_count
.l1
                mov     hpar1, hidr_offset
                mov     hpar2, hidr_size
                call    #hpad_getbits
                call    #hpad_normalize
                cmp     hr0, #6         wcz
        if_b    altgn   hr0, #hidr_usage
        if_b    getnib  hr2
        if_b    altsw   hr2, #hidr_axis
        if_b    setword retval
        if_b    add     hr0, #1
                add     hidr_offset, hidr_size
                djnz    hr1, #.l1

                setnib  hidr_flags, hr0, #2
                mov     hidr_state, #1
                jmp     #.next
.hats
                'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
                mov     hpar1, hidr_offset
                mov     hpar2, hidr_size
                call    #hpad_getbits
                setbyte hidr_hats, retval, #0
                setnib  hidr_flags, #1, #3
                mov     hidr_state, #1
                jmp     #.skip
.buttons
                'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
                mov     hpar1, hidr_offset
                mov     hpar2, hidr_size
                mul     hpar2, hidr_count
                call    #hpad_getbits
                getbyte htmp, hidr_flags, #0
                shl     retval, htmp
                or      hidr_buttons, retval
                add     htmp, hidr_count
                setbyte hidr_flags, htmp, #0
                mov     hidr_state, #1
                jmp     #.skip
.report_id
                cmp     hidr_id, #0     wz
        if_nz   jmp     #hpad_translate
                rdbyte  hidr_id, ptrb++
                cmp     hidr_id, hpar2  wz
        if_nz   ret
                jmp     #.next
.usage_page
                cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
        if_z    cmp     hidr_state, #1  wz
        if_z    mov     hidr_state, #4
                jmp     #.next
.usage
                cmp     hpar2, #HID_USAGE_JOYSTICK  wz
        if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
        if_z    mov     hidr_state, #1
        if_z    jmp     #.next
                cmp     hpar2, #HID_USAGE_X     wz
        if_nz   cmp     hpar2, #HID_USAGE_Y     wz
        if_nz   cmp     hpar2, #HID_USAGE_Z     wz
        if_nz   cmp     hpar2, #HID_USAGE_RX    wz
        if_nz   cmp     hpar2, #HID_USAGE_RY    wz
        if_nz   cmp     hpar2, #HID_USAGE_RZ    wz
        if_z    jmp     #.usage_axis
                cmp     hpar2, #HID_USAGE_HATSWITCH wz
        if_z    cmp     hidr_state, #1      wz
        if_z    mov     hidr_state, #3
                jmp     #.next
.usage_axis
                altsn   hidr_usage_idx, #hidr_usage
                setnib  hpar2

                sub     hpar2, #HID_USAGE_X - 16
                decod   hpar2
                or      hidr_flags, hpar2

                add     hidr_usage_idx, #1
                cmp     hidr_state, #1      wz
        if_z    mov     hidr_state, #2
                jmp     #.next

'------------------------------------------------------------------------------
' Handle XInput controller
' On entry:
'   ptrb - controller report
'------------------------------------------------------------------------------
'   Default implementation translates the report to a pseudo-defacto hid
'   standard and jumps to hpad_translate for actions.
'   Implementors may take specific actions for this kind of controller.
'------------------------------------------------------------------------------
hpad_xinput
                rdbyte  htmp, ptrb      wz
        if_nz   ret                         ' Ignore message type <> $00
                rdbyte  htmp, ptrb[1]
                cmp     htmp, #$14      wz
        if_nz   ret                         ' Ignore report length <> $14 (20)

                debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))

                bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
                setnib  hidr_flags, #6, #2

                rdword  hidr_axis, ptrb[3]  ' X = left stick X
                rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
                not     retval
                setword hidr_axis, retval, #1
                rdword  hidr_axis+1, ptrb[5]' Z = right stick X
                rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
                not     retval
                setword hidr_axis+2, retval, #1

                mov     hidr_lminmax, #$0000_00FF
                rdbyte  retval, ptrb[4]     ' left analog trigger
                cmp     retval, #192    wcz
        if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
                call    #hpad_normalize
                setword hidr_axis+1, retval, #1
                rdbyte  retval, ptrb[5]     ' right analog trigger
                cmp     retval, #192    wcz
        if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
                call    #hpad_normalize
                setword hidr_axis+2, retval, #0

                setbyte hidr_flags,#13,#0
                rdword  retval, ptrb[1]
                testb   retval, #15     wc  ' Y
                bitc    hidr_buttons, #0
                testb   retval, #13     wc  ' B
                bitc    hidr_buttons, #1
                testb   retval, #12     wc  ' A
                bitc    hidr_buttons, #2
                testb   retval, #14     wc  ' X
                bitc    hidr_buttons, #3
                testb   retval, #8      wc  ' LB
                bitc    hidr_buttons, #4
                testb   retval, #9      wc  ' RB
                bitc    hidr_buttons, #5
                testb   retval, #5      wc  ' SELECT
                bitc    hidr_buttons, #8
                testb   retval, #4      wc  ' START
                bitc    hidr_buttons, #9
                testb   retval, #6      wc  ' L3
                bitc    hidr_buttons, #10
                testb   retval, #7      wc  ' R3
                bitc    hidr_buttons, #11
                testb   retval, #10     wc  ' XBOX
                bitc    hidr_buttons, #12

                setnib  hidr_flags, #1, #3
                getnib  htmp, retval, #0    ' map dpad buttons to hat direction
                mov     htmp1, ##$F576_F40F
                mov     htmp2, ##$FFFF_F312
                altgn   htmp, #htmp1
                getnib  htmp
                setbyte hidr_hats, htmp, #0

                jmp     #hpad_translate

'------------------------------------------------------------------------------
' Handle PS3 controller
' On entry:
'   ptrb - controller report
'------------------------------------------------------------------------------
'   Default implementation translates the report to a pseudo-defacto hid
'   standard and jumps to hpad_translate for actions.
'   Implementors may take specific actions for this kind of controller.
'------------------------------------------------------------------------------
hpad_ps3
                rdbyte  htmp, ptrb++
                cmp     htmp, #$01      wz
        if_nz   ret                         ' Ignore report ID <> $01

                debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))

                mov     hidr_lminmax, #$0000_00FF
                rdbyte  retval, ptrb[5]         ' X = left stick X
                call    #hpad_normalize
                setword hidr_axis, retval, #0
                bith    hidr_flags, #HID_AXIS_X
                rdbyte  retval, ptrb[6]         ' Y = left stick Y
                call    #hpad_normalize
                setword hidr_axis, retval, #1
                bith    hidr_flags, #HID_AXIS_Y
                rdbyte  retval, ptrb[7]         ' Z = right stick X
                call    #hpad_normalize
                setword hidr_axis+1, retval, #0
                bith    hidr_flags, #HID_AXIS_Z
                rdbyte  retval, ptrb[8]         ' RZ = right stick Y
                call    #hpad_normalize
                setword hidr_axis+2, retval, #1
                bith    hidr_flags, #HID_AXIS_RZ
                setnib  hidr_flags, #4, #2

                mov     hpar1, #8
                mov     hpar2, #19
                call    #hpad_getbits

                setbyte hidr_flags,#13,#0
                testb   retval, #12     wc  ' A
                bitc    hidr_buttons, #0
                testb   retval, #13     wc  ' B
                bitc    hidr_buttons, #1
                testb   retval, #14     wc  ' X
                bitc    hidr_buttons, #2
                testb   retval, #15     wc  ' Y
                bitc    hidr_buttons, #3
                testb   retval, #10     wc  ' L1
                bitc    hidr_buttons, #4
                testb   retval, #11     wc  ' R1
                bitc    hidr_buttons, #5
                testb   retval, #8      wc  ' L2
                bitc    hidr_buttons, #6
                testb   retval, #9      wc  ' R2
                bitc    hidr_buttons, #7
                testb   retval, #0      wc  ' SELECT
                bitc    hidr_buttons, #8
                testb   retval, #3      wc  ' START
                bitc    hidr_buttons, #9
                testb   retval, #1      wc  ' LEFT STICK
                bitc    hidr_buttons, #10
                testb   retval, #2      wc  ' RIGHT STICK
                bitc    hidr_buttons, #11
                testb   retval, #16     wc  ' HOME
                bitc    hidr_buttons, #12

                setnib  hidr_flags, #1, #3
                getnib  htmp, retval, #1    ' map dpad buttons to hat direction
                mov     htmp1, ##$F3F4_120F
                mov     htmp2, ##$FFF5_FF76
                altgn   htmp, #htmp1
                getnib  htmp
                setbyte hidr_hats, htmp, #0

                jmp     #hpad_translate

'------------------------------------------------------------------------------
' Read bits from report data buffer
'------------------------------------------------------------------------------
' On entry:
'   PTRB - report buffer
'   hpar1 - start bit
'   hpar2 - number of bits
' On exit:
'   retval - bits
'------------------------------------------------------------------------------
hpad_getbits
                mov     htmp, hpar1
                shr     htmp, #3        ' byte offset
                add     htmp, ptrb
                rdlong  retval, htmp

                mov     htmp1, hpar1
                and     htmp1, #$07     ' shift
                shr     retval, htmp1

                cmp     hpar2, #24      wcz
        if_a    jmp     #.l1

                decod   hpar2
                sub     hpar2, #1
                and     retval, hpar2
                ret
.l1
                zerox   retval, #23
                add     htmp, #3
                rdlong  htmp2, htmp
                sub     hpar2, #24
                decod   hpar2
                sub     hpar2, #1
                shr     htmp2, htmp1
                and     htmp2, hpar2
                shl     htmp2, #24
                or      retval, htmp2
                ret

'------------------------------------------------------------------------------
' Normalize value to signed word (-32768 / 32767)
'------------------------------------------------------------------------------
' On entry:
'   retval - value to normalize
'   hidr_lminmax - min (word 1) max (word 0) value range
'   - or -
'   hidr_pminmax - min (word 1) max (word 0) value range
'   hidr_size - value bits length
' On exit:
'   retval - normalized value
'------------------------------------------------------------------------------
hpad_normalize
                mov     htmp, hidr_lminmax  wz
        if_z    mov     htmp, hidr_pminmax  wz
        if_z    ret
                getword htmp1, htmp, #1     ' htmp1 = min
                getword htmp, htmp, #0      ' htmp = max
                signx   htmp1, #15      wc
        if_c    sub     hidr_size, #1
        if_c    signx   retval, hidr_size
        if_c    add     hidr_size, #1
                subs    htmp, htmp1         ' htmp = (max - min)
                subs    retval, htmp1       ' retval = (retval - min)
                shl     retval, #16         ' retval = (retval - min) << 16
                subs    retval, #1          ' retval = ((retval - min) << 16) - 1
                abs     htmp            wc
                testb   retval, #31     wz
                abs     retval
                qdiv    retval, htmp
                getqx   retval
    if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
                adds    retval, ##$8000 signx 15
                ret

'------------------------------------------------------------------------------
' Perform controller actions
' On entry:
'    hidr_id        report id
'    hidr_axis      axis value (signed word, 2 axes per long)
'                      X = hidr_axis+0, #0
'                      Y = hidr_axis+0, #1
'                      Z = hidr_axis+1, #0
'                     RX = hidr_axis+1, #1
'                     RY = hidr_axis+2, #0
'                     RZ = hidr_axis+2, #1
'    hidr_buttons   buttons state (bits 0 to 31)
'    hidr_hats      hats state (byte 0, 1, 2, 3)
'
'                     -------3 -------2 -------1 -------0 byte
'                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
'    hidr_flags       xxxxxxxx_xxrrrzyx_hhhhaaaa_bbbbbbbb
'                                zyx||| |||||||| ++++++++ n. buttons
'                                |||||| ||||++++--------- n. axes
'                                |||||| ++++------------- n. hats
'                                ++++++------------------ valid axes
'------------------------------------------------------------------------------
hpad_translate
                rdlong  hr0, #@m6532_io

                testb   hidr_buttons, #8   wz   ' SELECT
                bitnz   hr0, #16+1
                testb   hidr_buttons, #9   wz   ' START
                bitnz   hr0, #16

                bith    hr0, #4 addbits 3

                getnib  htmp, hidr_flags, #3    ' hats
                cmp     htmp, #0        wz
        if_z    jmp     #.nohat

                getbyte htmp, hidr_hats, #0     ' hat 0
                cmp     htmp, #$00      wz
        if_ne   cmp     htmp, #$01      wz
        if_ne   cmp     htmp, #$07      wz
        if_e    bitl    hr0, #4                 ' P0 UP
                cmp     htmp, #$01      wz
        if_ne   cmp     htmp, #$02      wz
        if_ne   cmp     htmp, #$03      wz
        if_e    bitl    hr0, #7                 ' P0 RIGHT
                cmp     htmp, #$03      wz
        if_ne   cmp     htmp, #$04      wz
        if_ne   cmp     htmp, #$05      wz
        if_e    bitl    hr0, #5                 ' P0 DOWN
                cmp     htmp, #$05      wz
        if_ne   cmp     htmp, #$06      wz
        if_ne   cmp     htmp, #$07      wz
        if_e    bitl    hr0, #6                 ' P0 LEFT
.nohat

                testb   hidr_flags, #HID_AXIS_X wz
                testb   hidr_flags, #HID_AXIS_Y andz
        if_x0   jmp     #.noaxis

                getword htmp, hidr_axis, #0     ' X axis
                signx   htmp, #15
                cmps    htmp, ##-16384  wcz     ' left threshold
        if_c    bitl    hr0, #6                 ' LEFT
                cmps    htmp, ##16384   wcz     ' right threshold
        if_nc   bitl    hr0, #7                 ' RIGHT

                getword htmp, hidr_axis, #1     ' Y axis
                signx   htmp, #15
                cmps    htmp, ##-16384  wcz     ' up threshold
        if_c    bitl    hr0, #4                 ' UP
                cmps    htmp, ##16384   wcz     ' down threshold
        if_nc   bitl    hr0, #5                 ' DOWN
.noaxis

                wrlong  hr0, #@m6532_io

                rdlong  hr1, #@tia_inpt
                testb   hidr_buttons, #0    wz  ' A
                testb   hidr_buttons, #1    orz ' B
                bitnz   hr1, #4
                wrlong  hr1, #@tia_inpt

                'debug(uhex_byte(hidr_hats),ubin_long(hidr_buttons,hr0))

                ret

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for gamepad activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_hub_status
                mov     ep_addr_pid, hhub_ep_addr
                mov     hpar2, urx_buff_p
                setword hpar3, hub_next_datax, #0
                setword hpar3, #1, #1
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.data
                cmp     retval, #PID_NAK        wz
        if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
                ret
.data
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet

                cmp     hub_next_datax, #PID_DATA0  wz
        if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
        if_nz   mov     hub_next_datax, #PID_DATA0
                rdlong  hub_status_chg, urx_buff_p
                'debug(ubin_long(hub_status_chg))

                mov     hdev_port, #1
.loop
                testb   hub_status_chg, hdev_port wz
        if_x1   call    #hub_port_handler
                incmod  hdev_port, #7           wcz
        if_nc   jmp     #.loop
                ret

hub_port_handler
                mov     ep_addr_pid, hhub_ctrl_ep
                loc     ptra, #get_port_status          ' Get HUB port status
                mov     pb, urx_buff_p
                wrword  hdev_port, ptra[wIndex]
                call    #control_read
                rdlong  hub_port_status, urx_buff_p
                'debug(udec(hdev_port), ubin_long(hub_port_status))

                testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
        if_x0   jmp     #.other
                loc     ptra, #clr_port_feat
                wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
                wrword  hdev_port, ptra[wIndex]
                call    #control_write
                testb   hub_port_status, #HUB_PORT_CONNECTION   wz ' Connection bit
        if_x0   jmp     #.disconnect
                mov     hctwait, _100ms_
                call    #poll_waitx

                loc     ptra, #set_port_feat            ' reset port
                wrword  #HUB_PORT_RESET, ptra[wValue]
                wrword  hdev_port, ptra[wIndex]
                call    #control_write

                mov     htmp3, #2
.wait_reset
                mov     hctwait, _8ms_
                call    #poll_waitx
                loc     ptra, #get_port_status          ' Get HUB port status
                mov     pb, urx_buff_p
                wrword  hdev_port, ptra[wIndex]
                call    #control_read
                rdlong  hub_port_status, urx_buff_p
                testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
        if_x0   djnz    htmp3, #.wait_reset

                loc     ptra, #clr_port_feat
                wrword  #HUB_C_PORT_RESET, ptra[wValue]
                wrword  hdev_port, ptra[wIndex]
                call    #control_write

                mov     htmp, #36                       ' Allow reset recovery time (Section 9.2.6.2)
.wait_recover
                mov     hctwait, _1ms_
                call    #poll_waitx
                djnz    htmp,#.wait_recover

                testb   hub_port_status, #HUB_PORT_LOWSPEED wc
        if_c    bith    hstatus, #DWNSTRM_HUBB
        if_c    bith    _usb_h_ls_nco_, #14

                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
                wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done
.get_dev_desc
                mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
                mov     htmp, hdev_port                 ' Address is hub port number
                wrword  htmp, ptra[wValue]
                call    #control_write                  ' Execute SetAddress()
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done                          ' Back to idle if not ACK
                mov     hctwait, _8ms_
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, hdev_port
                shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
                call    #calc_crc5
                loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done                          ' Back to idle if not ACK
                mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
                mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
                'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
                mov     hctwait, _500us_
                call    #poll_waitx
                loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
                wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done
                mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
                mov     hconfig_base, ptra              ' Will need this for configuration
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    mov     retval, #ERR_CONFIG_FAIL
        if_b    jmp     #.done
                call    #hparse_con_desc
                jmp     #.done

.other
                loc     ptra, #clr_port_feat
                wrword  hdev_port, ptra[wIndex]

                testb   hub_port_status, #HUB_C_PORT_RESET wz
        if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
        if_x1   loc     ptra, #clr_port_feat
        if_x1   call    #control_write

                testb   hub_port_status, #HUB_C_PORT_ENABLE wz
        if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
        if_x1   loc     ptra, #clr_port_feat
        if_x1   call    #control_write

                testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
        if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
        if_x1   loc     ptra, #clr_port_feat
        if_x1   call    #control_write

                testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
        if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
        if_x1   loc     ptra, #clr_port_feat
        if_x1   call    #control_write

                jmp     #.done

.disconnect
                altgb   hdev_port, #hdev_type
                getbyte htmp
                cmp     htmp, #KB_READY         wz
        if_nz   cmp     htmp, #KBM_READY        wz
        if_z    mov     hkbd_ep_addr, #0
        if_z    mov     hkbd_ctrl_ep, #0
        if_z    mov     kb_led_states, #0
        if_z    mov     hkbd_ledstates, kb_led_states
                cmp     htmp, #M_READY          wz
        if_nz   cmp     htmp, #KBM_READY        wz
        if_z    mov     hmouse_ep_addr, #0

                altsb   hdev_port, #hdev_type
                setbyte #0
                altd    hdev_port, #hdev_ep_addr
                mov     0-0, #0

.done
                bitl    _usb_h_ls_nco_, #14     wcz
                bitl    hstatus, #DWNSTRM_HUBB
        if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
                mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods

                loc     ptra, #get_port_status          ' Get HUB port status
                mov     pb, urx_buff_p
                wrword  hdev_port, ptra[wIndex]
                call    #control_read
                rdlong  hub_port_status, ptra
                'debug(udec(hdev_port), ubin_long(hub_port_status))
                ret

'------------------------------------------------------------------------------
' Partially populated SETUP packets
'------------------------------------------------------------------------------
get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_DEVICE << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_CONFIG << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_CONFIG
                word    0       ' Configuration value
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_CONFIG has no data stage
set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_ADDR
                word    0       ' Zero
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_ADDR has no data stage
'------------------------------------------------------------------------------
' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
' wValue field dictates which protocol should be used.
'
' When initialized, all devices default to report protocol. However the host
' should not make any assumptions about the device state and should set the
' desired protocol whenever initializing a device.
'------------------------------------------------------------------------------
set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_PROTO
                word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
                                                ' (HID 1.11 Section 7.2.6).
                word    0               ' Interface index number.
                word    0               ' Zero, as HID_SET_PROTO has no data stage.
'------------------------------------------------------------------------------
set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_IDLE
                word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
                                        ' reporting until a change is detected in the report data

                                        ' (HID 1.11 Section 7.2.4).
                word    0       ' Interface index number.
                word    0       ' Zero, as HID_SET_IDLE has no data stage.
set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_REPORT
                word    0       ' Byte1 = report type, byte0 = ReportID.
                                        ' (HID 1.11 Section 7.2.2).
                word    0       ' Interface index number.
                word    0       ' Size of the report, in bytes.
get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
                byte    REQ_GET_DESC
                word    TYPE_REPORT << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
'------------------------------------------------------------------------------
get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_HUB << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
                byte    REQ_SET_FEATURE
                word    0       ' port power
                word    1       ' Port index number (1+)
                word    0       ' Number of bytes to transfer if there is a data stage
clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
                byte    REQ_CLEAR_FEATURE
                word    0       ' port power
                word    1       ' Port index number (1+)
                word    0       ' Number of bytes to transfer if there is a data stage
get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
                byte    REQ_GET_STATUS
                word    0
                word    1       ' Port index number (1+)
                word    4       ' Number of bytes to transfer if there is a data stage
'------------------------------------------------------------------------------
ps3_enable_cmd  byte    $42, $0C, $00, $00
ps3_command_buff
                byte    $00, $00, $00, $00, $00
                byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
                byte    $FF, $27, $10, $00, $32
                byte    $FF, $27, $10, $00, $32
                byte    $FF, $27, $10, $00, $32
                byte    $FF, $27, $10, $00, $32
                byte    $00, $00, $00, $00, $00
                byte    $00, $00, $00, $00, $00
                byte    $00, $00, $00, $00, $00
                byte    $00, $00, $00
'------------------------------------------------------------------------------
xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
                                        ' 0x01 All blinking
                                        ' 0x02 1 flashes, then on
                                        ' 0x03 2 flashes, then on
                                        ' 0x04 3 flashes, then on
                                        ' 0x05 4 flashes, then on
                                        ' 0x06 1 on
                                        ' 0x07 2 on
                                        ' 0x08 3 on
                                        ' 0x09 4 on
                                        ' 0x0A Rotating (e.g. 1-2-4-3)
                                        ' 0x0B Blinking*
                                        ' 0x0C Slow blinking*
                                        ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
xinp_rumble_cmd byte    $00, $08, $00
                byte    $00             ' Left rumble
                byte    $00             ' Right rumble
                byte    $00, $00, $00

xinp_fix_8bitdo '' This inexplicable String request (that WILL fail) somehow un-bugs the terrible firmware
                '' of certain wired 8bitdo gamepads.
                byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_STRING << 8 + 4
                word    $0409   ' Zero or Language ID (Section 9.6.7)
                word    2       ' Number of bytes to transfer if there is a data stage

'------------------------------------------------------------------------------
' The USB data cache area gets zero-filled at every device disconnect
'------------------------------------------------------------------------------
usb_cache_start

' HID descriptor and report buffers
hid_descr       byte    0[HID_DESCR_LEN * 8]
hid_report      byte    0[HID_IN_RPT_LEN * 8]

' HUB descriptor
hub_descr       byte    0   ' bDescLength
                byte    0   ' bDescriptorType
                byte    0   ' bNbrPorts
                word    0   ' wHubCharacteristics
                byte    0   ' bPwrOn2PwrGood
                byte    0   ' bHubContrCurrent
                byte    0   ' DeviceRemoveable
                byte    0   ' PortPwrCtrlMask

usb_cache_end

urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain

CON ' USB Host Shared constants
'------------------------------------------------------------------------------
' Smart pin configuration for "long repository" mode with output enabled,
' regardless of DIR. This allows one pin to provide a long event code via IN
' and also to control the USB port activity LED on/off state vio OUT.
    SP_REPO1_MODE = %01_00001_0 | 1 << 16    ' %TT_MMMMM_0, P[12:10] != %101
'------------------------------------------------------------------------------
' A simple event/cmd system using a smart pin configured in "long repository"
' mode. The USB_EVENT_REPO pin defined above is used to allow the USB cog to
' signal the client that a particular event has occurred. The client must poll
' this smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main"
' loop and process the event IDs you're interested in.
'------------------------------------------------------------------------------
    #0, NO_EVENT, USB_ERROR, DEV_UNKNOWN, KB_READY, M_READY, KBM_READY, HID_READY
    XINPUT_READY, PS3_READY, HUB_READY, DEV_DISCONNECT, DBG_DATA, M_DATA, GP_DATA
    CMD_SUSPEND, CMD_RESUME, CMD_RESET
'------------------------------------------------------------------------------
' The CMD_* tokens are asynchronous USB commands available to the user, through
' the Spin2 usbCommand method of this object. This method will post the cmd
' token to the host and when the cmd is complete the host will post the CMD_*
' token to byte[0] of the event long. Byte[1] is typically set to one of the
' below protocol error codes, with bytes[2..3] available for additional cmd data.
'------------------------------------------------------------------------------
' Protocol error codes:
    #0, ERR_NONE, ERR_CMD, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY
    ERR_XFER_RETRY, ERR_NAK, ERR_DATAX_SYNC, ERR_CONFIG_FAIL, ERR_TIMEOUT
'------------------------------------------------------------------------------
' Keyboard LED output report toggle key bit postions:
    #0, LED_NUMLKB, LED_CAPSLKB, LED_SCRLKB, LED_COMPOSEB
    LED_KANAB, LED_CONST0B, LED_CONST1B, LED_CONST2B
' Keyboard LED output report toggle key bitflags:
    LED_NUMLKF   = decod(LED_NUMLKB)
    LED_CAPSLKF  = decod(LED_CAPSLKB)
    LED_SCRLKF   = decod(LED_SCRLKB)
    LED_COMPOSEF = decod(LED_COMPOSEB)
    LED_KANAF    = decod(LED_KANAB)
    LED_CONST0F  = decod(LED_CONST0B)
    LED_CONST1F  = decod(LED_CONST1B)
    LED_CONST2F  = decod(LED_CONST2B)
' Keyboard modifier key bit positions:
    #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
    RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
' Keyboard modifier bitflags
    LEFT_CTRLF   = decod(LEFT_CTRLB)
    LEFT_SHIFTF  = decod(LEFT_SHIFTB)
    LEFT_ALTF    = decod(LEFT_ALTB)
    LEFT_GUIF    = decod(LEFT_GUIB)
    RIGHT_CTRLF  = decod(RIGHT_CTRLB)
    RIGHT_SHIFTF = decod(RIGHT_SHIFTB)
    RIGHT_ALTF   = decod(RIGHT_ALTB)
    RIGHT_GUIF   = decod(RIGHT_GUIB)
' Consolidated left/right modkeys. Add the modifier keys you want to trap
' together, then add the key scan code e.g. CTRL+ALT+"X" would be: $600 + KEY_X_x.
' The key() Spin2 method does this and the rawKey() method returns the key data
' as packed by the USB keyboard driver.
'   SHIFT = $100
'   CTRL  = $200
'   ALT   = $400
'   APP   = $800
' L|R key modifier flag combinations:
    KEYS_APP   = LEFT_GUIF + RIGHT_GUIF
    KEYS_ALT   = LEFT_ALTF + RIGHT_ALTF
    KEYS_CTRL  = LEFT_CTRLF + RIGHT_CTRLF
    KEYS_SHIFT = LEFT_SHIFTF + RIGHT_SHIFTF
'-------------
' Keyboard keys
' The first four scancodes are info/error indicators:
    #$00, KEY_NO_KEY, KEY_ERR_ROLLOVER, KEY_POST_FAIL, KEY_ERR_UNDEF
' Letters:
    KEY_A         = $04
    KEY_B         = $05
    KEY_C         = $06
    KEY_D         = $07
    KEY_E         = $08
    KEY_F         = $09
    KEY_G         = $0a
    KEY_H         = $0b
    KEY_I         = $0c
    KEY_J         = $0d
    KEY_K         = $0e
    KEY_L         = $0f
    KEY_M         = $10
    KEY_N         = $11
    KEY_O         = $12
    KEY_P         = $13
    KEY_Q         = $14
    KEY_R         = $15
    KEY_S         = $16
    KEY_T         = $17
    KEY_U         = $18
    KEY_V         = $19
    KEY_W         = $1a
    KEY_X         = $1b
    KEY_Y         = $1c
    KEY_Z         = $1d
' Number Row:
    KEY_1         = $1e
    KEY_2         = $1f
    KEY_3         = $20
    KEY_4         = $21
    KEY_5         = $22
    KEY_6         = $23
    KEY_7         = $24
    KEY_8         = $25
    KEY_9         = $26
    KEY_0         = $27
' Keyboard return (ENTER), tab, space, etc.:
    KEY_ENTER     = $28
    KEY_ESC       = $29
    KEY_BACKSPACE = $2a   ' Delete (backspace)
    KEY_TAB       = $2b
    KEY_SPACE     = $2c
    KEY_MINUS     = $2d   ' - and _
    KEY_EQUAL     = $2e   ' = and +
    KEY_LBRACE    = $2f   ' [ and {
    KEY_RBRACE    = $30   ' ] and }
    KEY_BACKSLASH = $31   ' \ and |
    KEY_HASHTILDE = $32   ' None-US # and ~
    KEY_SEMICOLON = $33   ' ; and :
    KEY_APOST     = $34   ' ' and "
    KEY_GRAVE     = $35   ' ` and ~
    KEY_COMMA     = $36   ' , and <
    KEY_DOT       = $37   ' . and >
    KEY_SLASH     = $38   ' / and ?
    KEY_CAPSLOCK  = $39
' Function key scancodes:
    KEY_F1        = $3a
    KEY_F2        = $3b
    KEY_F3        = $3c
    KEY_F4        = $3d
    KEY_F5        = $3e
    KEY_F6        = $3f
    KEY_F7        = $40
    KEY_F8        = $41
    KEY_F9        = $42
    KEY_F10       = $43
    KEY_F11       = $44
    KEY_F12       = $45
' Special, toggle and movement keys:
    KEY_PRINTSCREEN = $46
    KEY_SCROLLLOCK  = $47
    KEY_PAUSE       = $48
    KEY_INSERT      = $49
    KEY_HOME        = $4a
    KEY_PAGEUP      = $4b
    KEY_DELETE      = $4c
    KEY_END         = $4d
    KEY_PAGEDOWN    = $4e
    KEY_RIGHT       = $4f
    KEY_LEFT        = $50
    KEY_DOWN        = $51
    KEY_UP          = $52
' Keypad keys:
    KEY_NUMLOCK   = $53
    KEY_NUMSLASH  = $54
    KEY_NUMASTER  = $55
    KEY_NUMMINUS  = $56
    KEY_NUMPLUS   = $57
    KEY_NUMENTER  = $58
    KEY_NUM1      = $59
    KEY_NUM2      = $5a
    KEY_NUM3      = $5b
    KEY_NUM4      = $5c
    KEY_NUM5      = $5d
    KEY_NUM6      = $5e
    KEY_NUM7      = $5f
    KEY_NUM8      = $60
    KEY_NUM9      = $61
    KEY_NUM0      = $62
    KEY_DOT_DEL   = $63
    KEY_NOUS_SP   = $64   ' Non-US \ and |
    KEY_APP       = $65   ' Application key
' Modifier keys:
    KEY_LCTRL     = $E0
    KEY_LSHIFT    = $E1
    KEY_LALT      = $E2
    KEY_LMETA     = $E3 ' The left "Windows" key
    KEY_RCTRL     = $E4
    KEY_RSHIFT    = $E5
    KEY_RALT      = $E6
    KEY_RMETA     = $E7 ' The right "Windows" key

CON ' USB Host constants
'------------------------------------------------------------------------------
    _1thou         = 1_000
    _1m            = 1_000_000
    _1b            = 1_000_000_000
    _12m           = 12_000_000
    LSBTns         = 672.0                  ' Low-Speed bit period, in nanoseconds
    FSBTns         = 83.54                  ' Full-Speed bit period, in nanoseconds
    LSBTns4        = round(LSBTns * 4.0)    ' Low-Speed inter-packet delay, in nanoseconds
    LSBTns22       = round(LSBTns * 22.0)   ' Low-Speed turnaround wait time, in nanoseconds
    FSBTns4        = round(FSBTns * 4.0)    ' Full-Speed inter-packet delay, in nanoseconds
    FSBTns28       = round(FSBTns * 28.0)   ' Full-Speed turnaround wait time, in nanoseconds
' NCO baud calculations for low-speed/full-speed:
'        _1_5Mbps  = round(1_500_000.0 / _FCLKFREQ * 65536.0)  ' = NCO 492 @200MHz, 614 @160
'        _12Mbps   = round(12_000_000.0 / _FCLKFREQ * 65536.0) ' = NCO 3932 @200MHz, 4915 @160
' To configure RevA silicon LS/FS NCO baud: (WXPIN _1_5Mbps, D-) or (WXPIN _12Mbps, D-)
' To configure RevA LS/FS host/device: WRPIN appropriate LS/FS mode to D- (lower) and D+ (upper) pins:
    USB_V1HMODE_LS = %1_11000_0 + 1 << 16   ' Host mode
    USB_V1DMODE_LS = %1_11010_0 + 1 << 16   ' Device mode
    USB_V1HMODE_FS = %1_11001_0 + 1 << 16
    USB_V1DMODE_FS = %1_11011_0 + 1 << 16
' On RevB+ the USB smart pin mode is set to the D- and D+ pins via (WRPIN USBMode, pin#):
    USB_V2_DRVOUT  = %1_11011_0 + 1 << 16
    USB_V2_SNIFF   = %0_11011_0 + 1 << 16   ' Disable output to create a USB "sniffer"
' To configure NCO baud, host/device for LS/FS, set the appropriate mode to the D- pin# (WXPIN NCOMode, D-)
'   USB_H_LS_NCO   = %10 << 14 + _1_5Mbps   ' Host mode at NCO baud
'   USB_D_LS_NCO   = %00 << 14 + _1_5Mbps   ' Device mode at NCO baud
'   USB_H_FS_NCO   = %11 << 14 + _12Mbps
'   USB_D_FS_NCO   = %01 << 14 + _12Mbps
'------------------------------------------------------------------------------
' Time delays and intervals
' Useful USB constants and wait intervals:
    XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
    TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
    NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
    IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
    OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
' Standard Device request maximum timeout periods (reference):
{
    TO_STANDARD  = _1ms * 5000              ' Non-specific maximum timout period
    TO_DATA      = _1ms * 500               ' Standard Device requests with a data stage
    TO_NODATA    = _1ms * 50                ' Standard Device requests without a data stage
    TO_SETADDR   = _1ms * 50                ' Device SetAddress() command processing maximum
    TO_CHGADDR   = _1ms * 2                 ' Device SetAddress() period allowed to change its address before next request sent
}
'------------------------------------------------------------------------------
' Token packet format.
'------------------------------------------------------------------------------
'                   CRC5  ENDP ADDRESS PID
    CRC_MASK     = %11111_0000_0000000_00000000
    EP_MASK      = %00000_1111_0000000_00000000
    ADDR_MASK    = %00000_0000_1111111_00000000
    EP_ADDR_MASK = %00000_1111_1111111_11111111
    EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
'------------------------------------------------------------------------------
' Packet Identifier Bytes (PID). Notice that the first two LSBits are
' identical for each group.
'------------------------------------------------------------------------------
' Token:
    PID_OUT   = %1110_0001                  ' $e1
    PID_IN    = %0110_1001                  ' $69
    PID_SOF   = %1010_0101                  ' $a5
    PID_SETUP = %0010_1101                  ' $2d
' Data:
    PID_DATA0 = %1100_0011                  ' $c3
    PID_DATA1 = %0100_1011                  ' $4b
    PID_DATA2 = %1000_0111                  ' $87
    PID_MDATA = %0000_1111                  ' $0f
' Handshake:
    PID_ACK   = %1101_0010                  ' $d2
    PID_NAK   = %0101_1010                  ' $5a
    PID_STALL = %0001_1110                  ' $1e
    PID_NYET  = %1001_0110                  ' $96
' Special:
    PID_PRE   = %0011_1100                  ' $3c
    PID_ERR   = %0011_1100                  ' $3c
    PID_SPLIT = %0111_1000                  ' $78
    PID_PING  = %1011_0100                  ' $b4
    PID_RESVD = %1111_0000                  ' $f0
' Tx, rx and host related constants
' USB transmitter WYPIN D line state options:
    OUT_IDLE = 0
    OUT_SE0  = 1
    OUT_K    = 2
    OUT_J    = 3
    OUT_EOP  = 4
    OUT_SOP  = $80
' USB receiver RDPIN status bit positions:
    #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
' USB receiver RDPIN status bitflags:
    J_IDLEF    = decod(J_IDLEB)
    K_RESUMEF  = decod(K_RESUMEB)
    SE0_RESETF = decod(SE0_RESETB)
    SE1_BADF   = decod(SE1_BADB)
    SOPF       = decod(SOPB)
    EOPF       = decod(EOPB)
    BUS_ERRF   = decod(BUS_ERRB)
    BYTE_TGLF  = decod(BYTE_TGLB)
' USB CRC constants:
    USB5_POLY      = %0_0101 rev (5 - 1)    ' USB5 polynomial is reflected when calculating CRC
    USB5_RESIDUAL  = %0_1100 rev (5 - 1)    ' Expected CRC5 residual value when checking received data
    USB16_POLY     = $8005 rev (16 - 1)     ' USB16 polynomial is reflected when calculating CRC
    USB16_RESIDUAL = $800d rev (16 - 1)     ' Expected CRC16 residual value when checking received data
' Host->class driver USB connect speed:
    #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
    #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB[4], DWNSTRM_HUBB, SUSPENDB, KBM_TOGGLEB
' Host status bitflags. Unless otherwise noted, bit states are active high:
    IDLEF        = decod(IDLEB)             ' Set when USB in idle state
    CONNECTEDF   = decod(CONNECTEDB)        ' USB device connected
    LOW_SPEEDF   = decod(LOW_SPEEDB)        ' Low-speed device connected, clear if full-speed
    DATAx_TGLF   = decod(DATAx_TGLB)        ' Cleared if sending DATA0 packet, set if sending DATA1 packet
'   EOPF         = decod(EOPB)              ' Same bit position as the USB rx RDPIN status constants defined above
'   BUS_ERRF     = decod(BUS_ERRB)          ' Same bit position as the USB rx RDPIN status constants defined above
'   BYTE_TGLF    = decod(BYTE_TGLB)         ' Same bit position as the USB rx RDPIN status constants defined above
    DWNSTRM_HUBF = decod(DWNSTRM_HUBB)      ' NYI: downstream hub(s) connected
    SUSPENDF     = decod(SUSPENDB)          ' NYI: command the host to signal a global suspend
'------------------------------------------------------------------------------
' P2 silicon revision detection:
'------------------------------------------------------------------------------
    #1, P2RevA, P2RevB
'------------------------------------------------------------------------------

CON ' USB Descriptor Definitions
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
'------------------------------------------------------------------------------
' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
' Use TYPE_STANDARD for all USB Standard Device Request codes.
'------------------------------------------------------------------------------
' D7 Data direction  | D6:5 Type    | D4:0 Recipient
'------------------------------------------------------------------------------
' 0 - Host-to-device | 0 = Standard | 0 = Device
' 1 - Device-to-host | 1 = Class    | 1 = Interface
'                    | 2 = Vendor   | 2 = Endpoint
'                    | 3 = Reserved | 3 = Other
'                    |              | 4 -31 = Reserved
'------------------------------------------------------------------------------
    DIR_HOST_TO_DEV = 0 << 7
    DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
    TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
    TYPE_CLASS      = %01 << 5
    TYPE_VENDOR     = %10 << 5
    TYPE_RESERVED   = %11 << 5
    RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
    RECIP_INTERFACE = %0_0001
    RECIP_ENDPOINT  = %0_0010
    RECIP_OTHER     = %0_0011
'    RECIP 4 - 31 = Reserved
'------------------------------------------------------------------------------
' Standard Device Request codes (Section 9.4, Table 9-4):
'------------------------------------------------------------------------------
    #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
    REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
    REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
'------------------------------------------------------------------------------
' Standard descriptor types (Section 9.4, Table 9-5):
'------------------------------------------------------------------------------
    #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
    TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
'------------------------------------------------------------------------------
' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
'------------------------------------------------------------------------------
    #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
    CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
    CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
    CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
    CLASS_DIAGNOSTIC_DEV  = $dc
    CLASS_WIRELESS_CTRL   = $e0
    CLASS_MISCELLANEOUS   = $ef
    CLASS_APP_SPECIFIC    = $fe
    CLASS_VENDOR_SPECIFIC = $ff
'------------------------------------------------------------------------------
' HUB Class Requests
'------------------------------------------------------------------------------
    #0, HUB_PORT_CONNECTION, HUB_PORT_ENABLE, HUB_PORT_SUSPEND, HUB_PORT_OVERCURRENT
    HUB_PORT_RESET[4], HUB_PORT_POWER, HUB_PORT_LOWSPEED[7]
    HUB_C_PORT_CONNECTION, HUB_C_PORT_ENABLE, HUB_C_PORT_SUSPEND, HUB_C_PORT_OVERCURRENT
    HUB_C_PORT_RESET, HUB_PORT_TEST, HUB_PORT_INDICATOR
'------------------------------------------------------------------------------
' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
'------------------------------------------------------------------------------
    #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
    HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
' HID Descriptor types:
    #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
    #$29, TYPE_HUB
'------------------------------------------------------------------------------
' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
'------------------------------------------------------------------------------
    #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
'------------------------------------------------------------------------------
' HID Interface SubClasses:
'------------------------------------------------------------------------------
    #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
'------------------------------------------------------------------------------
' HID Protocol codes:
'------------------------------------------------------------------------------
    #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
    #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
'------------------------------------------------------------------------------
' Other HID buffer lengths:
'------------------------------------------------------------------------------
    MAX_HID_REPTS   = 4             ' We have this many HID report buffers
    REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
    REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
    LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
    USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
'------------------------------------------------------------------------------
' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
'------------------------------------------------------------------------------
    LANG_ENG_US  = $0409            ' English (United States)
    LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
'------------------------------------------------------------------------------
' SETUP structure member offsets.
' NOTE: These offsets are defined in terms of the structure member's data type,
'       to take advantage of PTRA/B scaled indexing, e.g.:
'         RDBYTE D,   PTRA[bRequest]
'         WRWORD D/#, PTRA[wLength]
'------------------------------------------------------------------------------
    bmRequestType = 0
    bRequest      = 1
    wValue        = 1
    wIndex        = 2
    wLength       = 3
' SETUP bmRequestType combinations:
{
    HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
    DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
    HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
    HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
}
'------------------------------------------------------------------------------
' Standard USB descriptor structure sizes in bytes. The values defined are the
' minimum size of the descriptor:
'------------------------------------------------------------------------------
    SETUP_TXN_LEN = 8
    DEV_DESC_LEN  = 18
    CON_DESC_LEN  = 9
    INTF_DESC_LEN = 9
    ENDP_DESC_LEN = 7
    STR0_DESC_LEN = 4
    USTR_DESC_LEN = 4
'------------------------------------------------------------------------------
' Other USB-related buffer sizes:
'------------------------------------------------------------------------------
    URX_BUFF_LEN = 128      ' USB receiver scratch buffer
    CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
'------------------------------------------------------------------------------
' CON_bmAttrs member bit positions:
'------------------------------------------------------------------------------
    ATTR_RESVB     = 7      ' Reserved (should always be one)
    ATTR_SELF_PWRB = 6      ' Device Self-Powered
    ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
'    bmAttributes bits 4..0 reserved and reset to zero
'------------------------------------------------------------------------------
' Standard USB descriptor struct member offset and member size, in bytes. Note
' that the DESC_bLength and DESC_bDescType members are defined in all of the
' descriptors (including HID) at the offsets shown.
'------------------+
' !!! IMPORTANT !!!|
'------------------+
' All standard descriptor member offsets are defined in bytes, so if you want
' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
'       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
' If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
' must be very careful...
'------------------------------------------------------------------------------
'       Member          Offset  Size    Value           Description
'------------------------------------------------------------------------------
    DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
    DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
' Device Descriptor (Section 9.6.1, Table 9-8):
    DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
    DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
    DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
    DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
    DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
    DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
    DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
    DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
    DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
    DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
    DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
    DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
  ' Configuration Descriptor (Section 9.6.3, Table 9-10):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
    CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
    CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
    CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
    CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
    CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
    CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
' Interface Descriptor (Section 9.6.5, Table 9-12):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
    INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
    INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
    INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
    INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
    INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
                            '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
                            '                       reserved for assignment by the USB-IF.
    INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
                            '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
                            '                       vendor-specific protocol for this interface.
    INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
' Endpoint Descriptor (Section 9.6.6, Table 9-13):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
    ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
    ENDP_bmAttrs     = 3    ' 1     Bitmap
    ENDP_wMaxPktSize = 4    ' 2     Number
    ENDP_bInterval   = 6    ' 1     Number
' String Descriptor Zero (Section 9.6.7, Table 9-15):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
' Unicode String Descriptor (Section 9.6.7, Table 9-16):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    USTR_wString     = 2    ' N     wString[(N - 2) / 2]
'------------------------------------------------------------------------------
' HID Descriptor (Section 6.2.1)
'------------------------------------------------------------------------------
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
    HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
    HID_bCountryCode = 4    ' 1     Number          Hardware target country
    HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
    HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
    HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).

' HID Report Items from HID 1.11 Section 6.2.2
    HID_USAGE_PAGE      = $04
    HID_USAGE           = $08
    HID_COLLECTION      = $A0
    HID_END_COLLECTION  = $C0
    HID_REPORT_COUNT    = $94
    HID_REPORT_SIZE     = $74
    HID_USAGE_MIN       = $18
    HID_USAGE_MAX       = $28
    HID_LOGICAL_MIN     = $14
    HID_LOGICAL_MAX     = $24
    HID_PHYSICAL_MIN    = $34
    HID_PHYSICAL_MAX    = $44
    HID_INPUT           = $80
    HID_REPORT_ID       = $84
    HID_OUTPUT          = $90

' HID Report Usage Pages from HID Usage Tables 1.12 Section 3, Table 1
    HID_USAGE_PAGE_GENERIC_DESKTOP = $01
    HID_USAGE_PAGE_KEY_CODES       = $07
    HID_USAGE_PAGE_LEDS            = $08
    HID_USAGE_PAGE_BUTTONS         = $09

' HID Report Usages from HID Usage Tables 1.12 Section 4, Table 6
    HID_USAGE_POINTER   = $01
    HID_USAGE_MOUSE     = $02
    HID_USAGE_JOYSTICK  = $04
    HID_USAGE_GAMEPAD   = $05
    HID_USAGE_KEYBOARD  = $06
    HID_USAGE_X         = $30
    HID_USAGE_Y         = $31
    HID_USAGE_Z         = $32
    HID_USAGE_RX        = $33
    HID_USAGE_RY        = $34
    HID_USAGE_RZ        = $35
    HID_USAGE_SLIDER    = $36
    HID_USAGE_WHEEL     = $38
    HID_USAGE_HATSWITCH = $39

' HID Report Collection Types from HID 1.12 6.2.2.6
    HID_COLLECTION_PHYSICAL    = 0
    HID_COLLECTION_APPLICATION = 1

' HID Input/Output/Feature Item Data (attributes) from HID 1.11 6.2.2.5
    HID_ITEM_CONSTANT = $1
    HID_ITEM_VARIABLE = $2
    HID_ITEM_RELATIVE = $4

' Keyboard report data buffer lengths (boot protocol):
    KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
    KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size
' Gamepad report and descriptor data buffer lengths:
    HID_IN_RPT_LEN   = 256
    HID_DESCR_LEN    = 256

' Gamepad axes flag bits
    HID_AXIS_X   = 16+0
    HID_AXIS_Y   = 16+1
    HID_AXIS_Z   = 16+2
    HID_AXIS_RX  = 16+3
    HID_AXIS_RY  = 16+4
    HID_AXIS_RZ  = 16+5

DAT             ' SVGA 800x600@60Hz Driver
                org     $000

video_driver
                add     ptrb, #@video_driver_lut - @video_driver
                setq2   #(@video_driver_lut_end - @video_driver_lut) - 1
                rdlong  0, ptrb

                setcmod #%01_0_000_0          ' enable colorspace conversion
                setcy   ##VGA_INTENSITY << 24 ' r      set colorspace for rgb
                setci   ##VGA_INTENSITY << 16 ' g
                setcq   ##VGA_INTENSITY << 08 ' b
                setxfrq _xf                 ' set transfer frequency

                cogid   _vx                 ' insert cogid into dac modes
                setnib  dacmode_s, _vx, #2
                setnib  dacmode_c, _vx, #2

                wrpin   dacmode_s, _pn      ' enable 123-ohm 3.3V dac mode in pin +0

                xor     _pn, #2 << 6 | 1    ' enable 75-ohm 2.0V dac mode in pins +1..3
                wrpin   dacmode_c, _pn

                xor     _pn, #3 << 6 ^ (2 << 6 | 1) ' make pins +0..3 outputs
                drvl    _pn

                xor     _pn, #4 | (3 << 6)  ' leave av_base pointing to pin +4 (vertical sync)
                drvl    _pn

.field
                drvnot  _pn                 ' vertical sync on
                callpa  #4, #.blank         ' do vertical sync blanks
                drvnot  _pn                 ' vertical sync off

                rdlong  _xf, #@fb_ptr   wz
        if_nz   mov     _fb, _xf
        if_nz   wrlong  #0, #@fb_ptr

                callpa  #23, #.blank        ' vertical blank

                callpa  #TOP_BORDER_LINES, #.blank ' top border

                mov     ptra, _fb
                mov     _sl, #VISIBLE_LINES

.line
                rdfast  #0, ptra
                xcont   _bs, #0             ' do before-sync part of scan line
                xzero   _ds, #1             ' do sync part of scan line
                xcont   _bv, #0             ' do before-visible part of scan line
#ifdef _PAL
                xcont   _vr, #0             ' do visible part of scan line
#endif                                      ' |
                rep     @.l1, #160          ' |
                rfbyte  _ch                 ' |
                movbyts _ch, #%%0000        ' |
                xcont   _vi, _ch            ' |
.l1                                         ' |
#ifdef _PAL                                 ' |
                xcont   _vr, #0             ' |
#endif                                      ' |

                rdfast  #0, ptra
                xcont   _bs, #0             ' do before-sync part of scan line
                xzero   _ds, #1             ' do sync part of scan line
                xcont   _bv, #0             ' do before-visible part of scan line
#ifdef _PAL
                xcont   _vr, #0             ' do visible part of scan line
#endif
                rep     @.l2, #160          ' |
                rfbyte  _ch                 ' |
                movbyts _ch, #%%0000        ' |
                xcont   _vi, _ch            ' |
.l2                                         ' |
#ifdef _PAL                                 ' |
                xcont   _vr, #0             ' |
#endif                                      ' |

                add     ptra, #160
                djnz    _sl, #.line         ' line loop

                callpa  #BOTTOM_BORDER_LINES, #.blank ' bottom border

                callpa  #1, #.blank         ' do bottom blanks

                jmp     #.field             ' frame loop

.blank          xcont   _bs, #0             ' do before-sync part of scan line
                xzero   _ds, #1             ' do sync part of scan line
                xcont   _bv, #0             ' do before-visible part of scan line
                xcont   _vb, #0             ' do blank part of scan line
        _ret_   djnz    pa, #.blank         ' loop if more blanks needed

dacmode_s       long    P_DAC_124R_3V + P_CHANNEL ' %0000_0000_000_1011000000000_01_00000_0         'hsync is 123-ohm, 3.3V
dacmode_c       long    P_DAC_75R_2V + P_CHANNEL  ' %0000_0000_000_1011100000000_01_00000_0         'R/G/B are 75-ohm, 2.0V

_pn             long    VGA_BASE_PIN
_xf             long    (VGA_FPIX frac _CLKFREQ) >> 1
#ifdef _PAL
_bs             long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  40   ' streamer command: before sync
_ds             long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 + 128   ' streamer command: sync
_bv             long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  88   ' streamer command: before visible
_vb             long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 + 800   ' streamer command: blank

_vi             long    X_IMM_4X8_LUT    | X_DACS_3_2_1_0 +   4   ' streamer command: visible
_vr             long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  80   ' streamer command: border
#else
_bs             long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  16   ' streamer command: before sync
_ds             long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  96   ' streamer command: sync
_bv             long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  48   ' streamer command: before visible
_vb             long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 + 640   ' streamer command: blank

_vi             long    X_IMM_4X8_LUT    | X_DACS_3_2_1_0 +   4   ' streamer command: visible
'_vr             long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +   0   ' streamer command: border
#endif

_fb             long    0
_sl             long    0
_vx             long    0
_ch             long    0

DAT
                org     $200

video_driver_lut
#ifdef _PAL
                long    $000000_00, $282828_00, $505050_00, $747474_00, $949494_00, $B4B4B4_00, $D0D0D0_00, $F1F1F1_00
                long    $000000_00, $282828_00, $505050_00, $747474_00, $949494_00, $B4B4B4_00, $D0D0D0_00, $F1F1F1_00
                long    $805800_00, $947020_00, $A8843C_00, $BC9C58_00, $CCAC70_00, $DCC084_00, $ECD09C_00, $FCE0B0_00
                long    $445C00_00, $5C7820_00, $74903C_00, $8CAC58_00, $A0C070_00, $B0D484_00, $C4E89C_00, $D4FCB0_00
                long    $703400_00, $885020_00, $A0683C_00, $B48458_00, $C89870_00, $DCAC84_00, $ECC09C_00, $FCD4B0_00
                long    $006414_00, $208034_00, $3C9850_00, $58B06C_00, $70C484_00, $84D89C_00, $9CE8B4_00, $B0FCC8_00
                long    $700014_00, $882034_00, $A03C50_00, $B4586C_00, $C87084_00, $DC849C_00, $EC9CB4_00, $FCB0C8_00
                long    $005C5C_00, $207474_00, $3C8C8C_00, $58A4A4_00, $70B8B8_00, $84C8C8_00, $9CDCDC_00, $B0ECEC_00
                long    $70005C_00, $842074_00, $943C88_00, $A8589C_00, $B470B0_00, $C484C0_00, $D09CD0_00, $E0B0E0_00
                long    $003C70_00, $1C5888_00, $3874A0_00, $508CB4_00, $68A4C8_00, $7CB8DC_00, $90CCEC_00, $A4E0FC_00
                long    $580070_00, $6C2088_00, $803CA0_00, $9458B4_00, $A470C8_00, $B484DC_00, $C49CEC_00, $D4B0FC_00
                long    $002070_00, $1C3C88_00, $3858A0_00, $5074B4_00, $6888C8_00, $7CA0DC_00, $90B4EC_00, $A4C8FC_00
                long    $3C0080_00, $542094_00, $6C3CA8_00, $8058BC_00, $9470CC_00, $A884DC_00, $B89CEC_00, $C8B0FC_00
                long    $000088_00, $20209C_00, $3C3CB0_00, $5858C0_00, $7070D0_00, $8484E0_00, $9C9CEC_00, $B0B0FC_00
                long    $000000_00, $282828_00, $505050_00, $747474_00, $949494_00, $B4B4B4_00, $D0D0D0_00, $F1F1F1_00
                long    $000000_00, $282828_00, $505050_00, $747474_00, $949494_00, $B4B4B4_00, $D0D0D0_00, $F1F1F1_00
#else
                long    $000000_00, $404040_00, $6C6C6C_00, $909090_00, $B0B0B0_00, $C8C8C8_00, $DCDCDC_00, $F4F4F4_00
                long    $444400_00, $646410_00, $848424_00, $A0A034_00, $B8B840_00, $D0D050_00, $E8E85C_00, $FCFC68_00
                long    $702800_00, $844414_00, $985C28_00, $AC783C_00, $BC8C4C_00, $CCA05C_00, $DCB468_00, $ECC878_00
                long    $841800_00, $983418_00, $AC5030_00, $C06848_00, $D0805C_00, $E09470_00, $ECA880_00, $FCBC94_00
                long    $880000_00, $9C2020_00, $B03C3C_00, $C05858_00, $D07070_00, $E08888_00, $ECA0A0_00, $FCB4B4_00
                long    $78005C_00, $8C2074_00, $A03C88_00, $B0589C_00, $C070B0_00, $D084C0_00, $DC9CD0_00, $ECB0E0_00
                long    $480078_00, $602090_00, $783CA4_00, $8C58B8_00, $A070CC_00, $B484DC_00, $C49CEC_00, $D4B0FC_00
                long    $140084_00, $302098_00, $4C3CAC_00, $6858C0_00, $7C70D0_00, $9488E0_00, $A8A0EC_00, $BCB4FC_00
                long    $000088_00, $1C209C_00, $3840B0_00, $505CC0_00, $6874D0_00, $7C8CE0_00, $90A4EC_00, $A4B8FC_00
                long    $00187C_00, $1C3890_00, $3854A8_00, $5070BC_00, $6888CC_00, $7C9CDC_00, $90B4EC_00, $A4C8FC_00
                long    $002C5C_00, $1C4C78_00, $386890_00, $5084AC_00, $689CC0_00, $7CB4D4_00, $90CCE8_00, $A4E0FC_00
                long    $003C2C_00, $1C5C48_00, $387C64_00, $509C80_00, $68B494_00, $7CD0AC_00, $90E4C0_00, $A4FCD4_00
                long    $003C00_00, $205C20_00, $407C40_00, $5C9C5C_00, $74B474_00, $8CD08C_00, $A4E4A4_00, $B8FCB8_00
                long    $143800_00, $345C1C_00, $507C38_00, $6C9850_00, $84B468_00, $9CCC7C_00, $B4E490_00, $C8FCA4_00
                long    $2C3000_00, $4C501C_00, $687034_00, $848C4C_00, $9CA864_00, $B4C078_00, $CCD488_00, $E0EC9C_00
                long    $442800_00, $644818_00, $846830_00, $A08444_00, $B89C58_00, $D0B46C_00, $E8CC7C_00, $FCE08C_00
#endif
video_driver_lut_end

CON ' VGA constants

    VGA_INTENSITY = 80    '0..128
#ifdef _PAL
    VGA_FPIX = 40_000_000
    TOP_BORDER_LINES = (600 - (VISIBLE_LINES * 2)) / 2
    BOTTOM_BORDER_LINES = 600 - (VISIBLE_LINES * 2) - TOP_BORDER_LINES
#else
    VGA_FPIX = 25_175_000
    TOP_BORDER_LINES = (480 - (VISIBLE_LINES * 2)) / 2
    BOTTOM_BORDER_LINES = 480 - (VISIBLE_LINES * 2) - TOP_BORDER_LINES
#endif

DAT
                orgh

                ' align rom to 8k boundary for bank switching
                byte    $00[(($ + $1FFF) & !$1FFF) - $]
cartridge_rom
                'file    "Diagnostic Stella 2600-7800 (Hack).a26"

                'file    "Combat (1977) (Atari) [!].a26"         ' 2k ROM need to be duplicated
                'file    "Combat (1977) (Atari) [!].a26"         ' |
                'file    "Demon Attack (1982) (Imagic) [!].a26"
                'file    "Keystone Kapers (1983) (Activision) [!].a26"
                'file    "Frogger (1982) (Parker Bros) [!].a26"
                'file    "Pac-Man (1981) (Atari) [!].a26"
                'file    "Pitfall! (1982) (Activision) [!].a26"
                'file    "River Raid (1982) (Activision) [!].a26"
                file    "Space Invaders (1978) (Atari) [!].a26"
cartridge_rom_end

framebuffer

CON ' License
{{

 TERMS OF USE: MIT License

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 associated documentation files (the "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
 following conditions:

 The above copyright notice and this permission notice shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}
