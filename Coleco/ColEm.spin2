{
    ColecoVision Console Emulator
    Copyright (c) 2022 by Marco Maccaferri <macca@maccasoft.com>

    Based on ZiKore Z80 Emulator by Ada Gottensträter
    with modifications by Marco Maccaferri

    TMS9918 Emulator by Marco Maccaferri
    SN76489 Emulator by Johannes Ahlebrand port to P2 by Ada Gottensträter
    PS/2 Keyboard driver by Marco Maccaferri

    USB host driver based on 1CogKbM code by Garry Jordan ("garryj")
    with gamepad support and other modifications by Marco Maccaferri
    and portions derived from code by Ada Gottensträter
}
CON

    _CLKFREQ = 250_000_000

    VIDEO    = VGA ' video mode VGA, NTSC or PAL
    VGA_PIN  = 48
    CVBS_PIN = 32 addpins 1 ' 32=CVBS/Y, 33=C

    USB_BASE_PIN  = 40

    PS2_DATA_PIN  = 47
    PS2_CLOCK_PIN = 46

    AUDIO_LEFT_PIN  = 38
    AUDIO_RIGHT_PIN = 39

DAT             ' Startup
                org     $000

                asmclk
                drvl    #56
                drvl    #57

                rep     @.lockmadness,#16
                locknew pb
                nop
.lockmadness

                coginit #5, ##@psg_driver   ' start SN76489 on cog #5
                coginit #4, ##@tms_driver   ' start TMS9918 on cog #4
                coginit #3, ##@ps2_driver   ' start PS/2 driver on cog #3
                coginit #1, ##@usb_host_start ' start USB driver on cog #1
                coginit #0, ##@zk_cogbase   ' start Z80 on cog #0 (this)

                orgh

' Controller status

coleco_ctrls
                byte    $7F     ' keypad 0
                byte    $7F     ' joystick 0
                byte    $7F     ' keypad 1
                byte    $7F     ' joystick 1

' TMS9918 registers

tms_regs        byte    $00, $00, $00, $00, $00, $00, $00, $00
tms_status      long    $00     ' 7..0 = VDP status
                                '    8 = NMI

' SN76489 registers

psg_registers
                                ' Reg bits function
                                ' -----------------------------------
                long    $0000   ' 00  9..0 channel 1 freq
                long    $0F     ' 01  3..0 channel 1 attunation
                long    $0000   ' 02  9..0 channel 2 freq
                long    $0F     ' 03  3..0 channel 2 attunation
                long    $0000   ' 04  9..0 channel 3 freq
                long    $0F     ' 05  3..0 channel 3 attunation
                long    $00     ' 06  4..0 noise control
                long    $0F     ' 07  7..0 noise attunation

DAT ' PS/2 Keyboard driver
                org     $000

ps2_driver
                fltl    #PS2_DATA_PIN
                fltl    #PS2_CLOCK_PIN

                mov     ps2_data, #$F3      ' auto-repeat
                call    #ps2_transmit
                and     ps2_data, #%011_11111 ' slow 1s / 2cps
                call    #ps2_transmit

                mov     ps2_state, #%0_000  ' turn off all leds
                jmp     #ps2_locks

ps2_reset
                wrlong  coleco_ctrls, #@coleco_ctrls

ps2_loop        and     ps2_state, #$07     ' keep locks state

.l1             call    #ps2_receive
                getbyte ps2_code, ps2_data, #0

                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #.l1

                cmp     ps2_data, #$E0  wz
        if_z    bith    ps2_state, #28
        if_z    jmp     #ps2_ext0
                cmp     ps2_data, #$E1  wz
        if_z    bith    ps2_state, #29
        if_z    jmp     #ps2_ext1

ps2_ext_ret     testbn  ps2_state, #29  wz
        if_nz   jmp     #ps2_loop           ' E1 codes are ignored

                testb   ps2_state, #7   wc  ' release

                cmp     ps2_code, #$14  wz  ' left control
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_CTRLF

                cmp     ps2_code, #$14  wz  ' right control
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_CTRLF

                cmp     ps2_code, #$12  wz  ' left shift
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_SHIFTF
                cmp     ps2_data, #$59  wz  ' right shift
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_SHIFTF

                cmp     ps2_code, #$11  wz  ' left alt
        if_z    testbn  ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_ALTF

                cmp     ps2_code, #$11  wz  ' right alt
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_ALTF

                cmp     ps2_code, #$1F  wz  ' left gui
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #LEFT_GUIF
                cmp     ps2_code, #$27  wz  ' right gui
        if_z    testb   ps2_state, #28  andz
        if_z    muxnc   ps2_shift, #RIGHT_GUIF

                cmp     ps2_code, #$77  wz  ' num. lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #0       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds
                cmp     ps2_code, #$58  wz  ' caps lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #1       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds
                cmp     ps2_code, #$7E  wz  ' scroll lock
  if_z_and_c    jmp     #ps2_loop           ' | ignore if released
        if_z    bitnot  ps2_state, #2       ' | toggle state
        if_z    jmp     #ps2_locks          ' | update leds

                testb   ps2_state, #28  wc  ' extended code
                rcl     ps2_code, #1        '   to bit 0
                altgb   ps2_code, #ps2_table ' get usb scancode
                getbyte ps2_key, ps2_code, #0   ' |
        '        shl     key, #8         wz
        'if_z    jmp     #loop

                mov     ps2_ctrl, ##$7F7F7F7F

                testb   ps2_shift, #LEFT_CTRLB  wz  ' LCTRL (LEFT BUTTON)
                bitnz   ps2_ctrl, #8+6
                testb   ps2_shift, #LEFT_SHIFTB wz  ' LSHIFT (RIGHT BUTTON)
                bitnz   ps2_ctrl, #6

                testb   ps2_state, #7       wc  ' release
                cmp     ps2_key, #$1E       wz  ' 1
 if_z_and_nc    setnib  ps2_ctrl, #$D,  #0
                cmp     ps2_key, #$1F       wz  ' 2
 if_z_and_nc    setnib  ps2_ctrl, #$7,  #0
                cmp     ps2_key, #$20       wz  ' 3
 if_z_and_nc    setnib  ps2_ctrl, #$C,  #0
                cmp     ps2_key, #$21       wz  ' 4
 if_z_and_nc    setnib  ps2_ctrl, #$2,  #0
                cmp     ps2_key, #$22       wz  ' 5
 if_z_and_nc    setnib  ps2_ctrl, #$3,  #0
                cmp     ps2_key, #$23       wz  ' 6
 if_z_and_nc    setnib  ps2_ctrl, #$E,  #0
                cmp     ps2_key, #$24       wz  ' 7
 if_z_and_nc    setnib  ps2_ctrl, #$5,  #0
                cmp     ps2_key, #$25       wz  ' 8
 if_z_and_nc    setnib  ps2_ctrl, #$1,  #0
                cmp     ps2_key, #$26       wz  ' 9
 if_z_and_nc    setnib  ps2_ctrl, #$B,  #0
                cmp     ps2_key, #$27       wz  ' 0
 if_z_and_nc    setnib  ps2_ctrl, #$A,  #0
                cmp     ps2_key, #$2D       wz  ' *
 if_z_and_nc    setnib  ps2_ctrl, #$9,  #0
                cmp     ps2_key, #$2E       wz  ' #
 if_z_and_nc    setnib  ps2_ctrl, #$6,  #0

                cmp     ps2_key, #$4F       wz  ' RIGHT
        if_z    bitc    ps2_ctrl, #8+1
                cmp     ps2_key, #$50       wz  ' LEFT
        if_z    bitc    ps2_ctrl, #8+3
                cmp     ps2_key, #$51       wz  ' DOWN
        if_z    bitc    ps2_ctrl, #8+2
                cmp     ps2_key, #$52       wz  ' UP
        if_z    bitc    ps2_ctrl, #8+0

                wrlong  ps2_ctrl, #@coleco_ctrls

                jmp     #ps2_loop

ps2_locks       mov     ps2_data, #$ED
                call    #ps2_transmit
                mov     ps2_data, #0
                testb   ps2_state, #0   wz  ' num. lock
                bitz    ps2_data, #1
                testb   ps2_state, #1   wz  ' caps lock
                bitz    ps2_data, #2
                testb   ps2_state, #2   wz  ' scroll lock
                bitz    ps2_data, #0
                call    #ps2_transmit
                jmp     #ps2_loop

ps2_ext1        call    #ps2_receive
                setbyte ps2_code, ps2_data, #1
                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #ps2_ext1

                ' fall through

ps2_ext0        call    #ps2_receive
                setbyte ps2_code, ps2_data, #0
                cmp     ps2_data, #$F0  wz  ' release
        if_z    bith    ps2_state, #7
        if_z    jmp     #ps2_ext0

                jmp     #ps2_ext_ret

ps2_transmit    drvl    #PS2_CLOCK_PIN      ' pull clock low
                getct   ps2_tout            ' hold clock for 128us (must be > 100us)
                addct1  ps2_tout, ps2_us128 ' |
                jnct1   #$
                drvl    #PS2_DATA_PIN       ' pull data low
                getct   ps2_tout            ' hold data for 4us
                addct1  ps2_tout, ps2_us4   ' |
                jnct1   #$

                fltl    #PS2_CLOCK_PIN      ' release clock
                getct   ps2_tout            ' allow pin to float
                addct1  ps2_tout, ps2_us1   ' |
                jnct1   #$

                test    ps2_data, #$FF  wc  ' append parity
                muxnc   ps2_data, #$100     ' |
                bith    ps2_data, #9        ' append stop bit

                getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ps2_us2000

                mov     ps2_bits, #10
.l1             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock low
        if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l1                ' |
                shr     ps2_data, #1    wc  ' output data bit
                drvc    #PS2_DATA_PIN       ' |
.l2             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock high
        if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l2                ' |
                djnz    ps2_bits, #.l1      ' another bit ?

                fltl    #PS2_DATA_PIN

.l3             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock and data low
        if_z    testpn  #PS2_DATA_PIN   wz  ' |
        if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l3                ' |

.l4             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock and data high
        if_nz   testpn  #PS2_DATA_PIN   wz  ' |
        if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l4                ' |

                ' Fall through to receive ack

ps2_receive     testpn  #PS2_CLOCK_PIN  wz  ' wait initial clock low
        if_nz   jmp     #ps2_receive        ' |

                getct   ps2_tout            ' safety timeout
                addct1  ps2_tout, ps2_us2000

                mov     ps2_bits, #11
.l1             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock low
        if_nz   jct1    #ps2_reset          ' | check timeout
        if_nz   jmp     #.l1                ' |
                testp   #PS2_DATA_PIN   wc  ' sample data
                rcr     ps2_data, #1        ' |
.l2             testpn  #PS2_CLOCK_PIN  wz  ' wait until clock high
        if_z    jct1    #ps2_reset          ' | check timeout
        if_z    jmp     #.l2                ' |
                djnz    ps2_bits, #.l1      ' another bit?

                shr     ps2_data, #22       ' align byte
                test    ps2_data, #$1FF wc  ' test parity
        if_nc   jmp     #ps2_reset          ' |
        _ret_   and     ps2_data, #$FF      ' ok


ps2_us1         long    _CLKFREQ / 1000_000 * 1     ' 1 usec.
ps2_us4         long    _CLKFREQ / 1000_000 * 4     ' 4 usec.
ps2_us128       long    _CLKFREQ / 1000_000 * 128   ' 128 usec.
ps2_us2000      long    _CLKFREQ / 1000_000 * 4000  ' 2000 usec.

ps2_bits        long    0
ps2_code        long    0
ps2_state       long    0
ps2_shift       long    0
ps2_key         long    0

ps2_data        long    0
ps2_tout        long    0

ps2_ctrl        long    $7F7F7F7F

ps2_table       byte    $00, $00    '00
                byte    $42, $00    '01     F9
                byte    $00, $00    '02
                byte    $3E, $00    '03     F5
                byte    $3C, $00    '04     F3
                byte    $3A, $00    '05     F1
                byte    $3B, $00    '06     F2
                byte    $45, $00    '07     F12
                byte    $00, $00    '08
                byte    $43, $00    '09     F10
                byte    $41, $00    '0A     F8
                byte    $3F, $00    '0B     F6
                byte    $3D, $00    '0C     F4
                byte    $2B, $00    '0D     Tab
                byte    $35, $00    '0E     `
                byte    $00, $00    '0F
                byte    $00, $00    '10
                byte    $E2, $E6    '11     Alt-L    Alt-R
                byte    $E1, $00    '12     Shift-L
                byte    $00, $00    '13
                byte    $E0, $E4    '14     Ctrl-L   Ctrl-R
                byte    $14, $00    '15     q
                byte    $1E, $00    '16     1
                byte    $00, $00    '17
                byte    $00, $00    '18
                byte    $00, $00    '19
                byte    $1D, $00    '1A     z
                byte    $16, $00    '1B     s
                byte    $04, $00    '1C     a
                byte    $1A, $00    '1D     w
                byte    $1F, $00    '1E     2
                byte    $00, $E3    '1F              Win-L
                byte    $00, $00    '20
                byte    $06, $00    '21     c
                byte    $1B, $00    '22     x
                byte    $07, $00    '23     d
                byte    $08, $00    '24     e
                byte    $21, $00    '25     4
                byte    $20, $00    '26     3
                byte    $00, $E7    '27              Win-R
                byte    $00, $00    '28
                byte    $2C, $00    '29     Space
                byte    $19, $00    '2A     v
                byte    $09, $00    '2B     f
                byte    $17, $00    '2C     t
                byte    $15, $00    '2D     r
                byte    $22, $00    '2E     5
                byte    $00, $65    '2F              Apps
                byte    $00, $00    '30
                byte    $11, $00    '31     n
                byte    $05, $00    '32     b
                byte    $0B, $00    '33     h
                byte    $0A, $00    '34     g
                byte    $1C, $00    '35     y
                byte    $23, $00    '36     6
                byte    $00, $00    '37              Power
                byte    $00, $00    '38
                byte    $00, $00    '39
                byte    $10, $00    '3A     m
                byte    $0D, $00    '3B     j
                byte    $18, $00    '3C     u
                byte    $24, $00    '3D     7
                byte    $25, $00    '3E     8
                byte    $00, $00    '3F              Sleep
                byte    $00, $00    '40
                byte    $36, $00    '41     ,
                byte    $0E, $00    '42     k
                byte    $0C, $00    '43     i
                byte    $12, $00    '44     o
                byte    $27, $00    '45     0
                byte    $26, $00    '46     9
                byte    $00, $00    '47
                byte    $00, $00    '48
                byte    $37, $00    '49     .
                byte    $38, $54    '4A     /        (/)
                byte    $0F, $00    '4B     l
                byte    $33, $00    '4C     ;
                byte    $13, $00    '4D     p
                byte    $2D, $00    '4E     -
                byte    $00, $00    '4F
                byte    $00, $00    '50
                byte    $00, $00    '51
                byte    $34, $00    '52     '
                byte    $00, $00    '53
                byte    $2F, $00    '54     [
                byte    $2E, $00    '55     =
                byte    $00, $00    '56
                byte    $00, $00    '57
                byte    $39, $00    '58     CapsLock
                byte    $E5, $00    '59     Shift-R
                byte    $28, $58    '5A     Enter    (Enter)
                byte    $30, $00    '5B     ]
                byte    $00, $00    '5C
                byte    $31, $00    '5D     \
                byte    $00, $00    '5E              WakeUp
                byte    $00, $00    '5F
                byte    $00, $00    '60
                byte    $64, $00    '61
                byte    $00, $00    '62
                byte    $00, $00    '63
                byte    $00, $00    '64
                byte    $00, $00    '65
                byte    $2A, $00    '66     BackSpace
                byte    $00, $00    '67
                byte    $00, $00    '68
                byte    $59, $4D    '69     (1)      End
                byte    $00, $00    '6A
                byte    $5C, $50    '6B     (4)      Left
                byte    $5F, $4A    '6C     (7)      Home
                byte    $00, $00    '6D
                byte    $00, $00    '6E
                byte    $00, $00    '6F
                byte    $62, $49    '70     (0)      Insert
                byte    $63, $4C    '71     (.)      Delete
                byte    $5A, $51    '72     (2)      Down
                byte    $5D, $00    '73     (5)
                byte    $5E, $4F    '74     (6)      Right
                byte    $60, $52    '75     (8)      Up
                byte    $29, $00    '76     Esc
                byte    $53, $00    '77     NumLock
                byte    $44, $00    '78     F11
                byte    $57, $00    '79     (+)
                byte    $5B, $4E    '7A     (3)      PageDn
                byte    $56, $00    '7B     (-)
                byte    $55, $46    '7C     (*)      PrScr
                byte    $61, $4B    '7D     (9)      PageUp
                byte    $47, $00    '7E     ScrLock
                byte    $00, $00    '7F
                byte    $00, $00    '80
                byte    $00, $00    '81
                byte    $00, $00    '82
                byte    $40, $00    '83     F7

                fit     $1F0

DAT             ' USB Host driver
                org     $000

usb_host_start
                mov     hcog_base_addr, ptrb

                add     ptrb, ##@hlut_start - @usb_host_start
                setq2   #512-1
                rdlong  0, ptrb

                jmp     #\usb_host_init

'------------------------------------------------------------------------------
' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
' special because the receiving function must not respond with either STALL or
' NAK, and must accept the DATAx packet that follows the SETUP token. If a
' non-control endpoint receives a SETUP token, or the function receives a
' corrupt packet, it must ignore the transaction
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data struct.
' On exit:
'   retval - PID_ACK on success, otherwise error code.
'------------------------------------------------------------------------------
txn_setup
                setbyte ep_addr_pid, #PID_SETUP, #0
                mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
                bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
                mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
                mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
.setup
                call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
                cmp     retval, #PID_ACK        wz
        if_z    ret
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    ret
                mov     ptra, pa                        ' Restore SETUP's DATAx pointer
                jmp     #.setup

'------------------------------------------------------------------------------
' IN/INTERRUPT transaction.
' Possible function response: STALL or NAK handshake, or DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
' On exit:
'------------------------------------------------------------------------------
txn_in
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                setbyte ep_addr_pid, #PID_IN, #0
                call    #utx_token                      ' Put IN request on the bus

                ' Fall through to urx_packet

'------------------------------------------------------------------------------
' Wait for a packet from a device/function. As host, the only two packet types
' received are handshakes and IN DATAx.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'     returned.
'------------------------------------------------------------------------------
urx_packet
                rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
                testb   urx, #SOPB              wc
        if_c    jmp     #urx_packet
                getct   hct2
                addct2  hct2, tat_wait                  ' Start the response turn-around timer
                bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
                mov     newb_flg, #0                    ' Initialize for multi-byte read
.wait_sop
                rdpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #.get_pid
                jnct2   #.wait_sop
        _ret_   mov     retval, #ERR_TAT
.get_pid
                call    #urx_next
                testb   urx, #BUS_ERRB          wc
        if_nc   jmp     #.chk_pid
        _ret_   mov     retval, #ERR_URX
.chk_pid
                cmp     retval, #PID_ACK        wz
        if_nz   cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
                testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
                cmp     retval, #PID_DATA0      wz
   if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
   if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
                cmp     retval, #PID_DATA1      wz
   if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
   if_z_and_nc  jmp     #.ack_resend
        _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
.ack_resend
                rqpin   urx, dm
                testb   urx, #EOPB              wc
        if_nc   jmp     #.ack_resend
                mov     retval, #PID_ACK
                call    #utx_handshake                  ' Send handshake PID and return to caller
        _ret_   mov     retval, #ERR_DATAX_SYNC
.chk_eop
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
                call    #urx_next                       ' Low-speed requires an additional read to get EOP status
                testb   hstatus, #EOPB          wc
        if_c    jmp     #.idle                          ' Low-speed EOP seen
                testb   urx, #BUS_ERRB          wz
        if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
        if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
                ret
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
                ret

'------------------------------------------------------------------------------
' Send a token packet with CRC5 checksum of address and endpoint. It is the
' responsibility of the caller to append the appropriate inter-packet delay,
' if one is required.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - packed with the PID, address and endpoint.
' On exit:
'------------------------------------------------------------------------------
utx_token
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #utx_token
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     htmp, ep_addr_pid               ' Preserve the PID and destination
                mov     pkt_cnt, #3
.next_byte
                getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
                shr     htmp, #8                        ' Shift to next byte to send
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   utx, dm
        _ret_   djnz    pkt_cnt, #.next_byte

'------------------------------------------------------------------------------
' SETUP/OUT/INTERRUPT transaction.
' Possible function response in order of precedence: STALL, ACK, NAK.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
'   PTRA - start address of the data buff/struct that has the bytes to send.
'   pkt_data - count of DATAx payload bytes to send.
' On exit:
'------------------------------------------------------------------------------
txn_out
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                call    #utx_token                      ' Put SETUP/OUT token on the bus
                rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
                mov     pkt_cnt, pkt_data

                ' Fall through to utx_data

'------------------------------------------------------------------------------
' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
' calculated while the data byte is being shifted out. Since data stage
' success/fail is not determined until the status stage of the transaction,
' this routine is only concerned about the current DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - hub start address of the data to read.
'   pkt_cnt - data payload size.
' On exit:
'------------------------------------------------------------------------------
utx_data
                rqpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #utx_data
                mov     hctwait, ip_delay
                call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                bmask   crc, #15                        ' Prime the CRC16 pump
                testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
        if_nc   mov     utx, #PID_DATA0
        if_c    mov     utx, #PID_DATA1
                call    #utx_byte                       ' No CRC calc done on PID
                cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
        if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
.read_byte
                rfbyte  utx                             ' Fetch data byte
                call    #utx_byte
                rev     utx                             ' Calculate CRC while the data is shifting out
                setq    utx                             ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
                djnz    pkt_cnt, #.read_byte
.send_crc
                xor     crc, ##$ffff                    ' Final XOR, and send the calculated CRC16
                getbyte utx, crc, #0
                call    #utx_byte
                getbyte utx, crc, #1
                call    #utx_byte                       ' Last CRC byte out
                jmp     #urx_packet                     ' Handle function response/error and back to caller

'------------------------------------------------------------------------------
' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
' payload bytes are received. The routine reads bytes until EOP is detected and
' expects that the packet includes at least the CRC word.
'
' In control transfers, it's possible to recieve fewer data bytes than what
' was requested, which makes it difficult to determine where the data stops
' and the CRC word begins. So the CRC calculation is done on every byte of the
' packet, including the CRC word. The CRC value should then be equal to the
' USB-16 expected residual value of 0xB001.
'
' The routine writes the IN packet data to a static max_packet_size buffer
' so the caller can verify IN success before writing the data to its final
' destination.
'------------------------------------------------------------------------------
' On entry:
'   pkt_data - max byte count expected to be in the packet.
'   newb_flg - signals new byte ready when toggled.
' On exit:
'   pkt_cnt - actual number of bytes read.
'------------------------------------------------------------------------------
urx_data
                mov     htmp2, pb
                mov     pb, urx_buff_p
                wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
                mov     pb, htmp2
                bmask   crc, #15                        ' Prime the CRC16 pump
                mov     pkt_cnt, #0                     ' Keep track of payload bytes received
                mov     pkt_tmp, pkt_data
                add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
.wait_byte
' In-line rx for max speed
                rqpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   jmp     #.get_byte                      ' New byte!
                testb   urx, #EOPB              wc
        if_c    jmp     #.chk_crc                       ' At end-of-packet
                jmp     #.wait_byte
.get_byte
                getbyte retval, urx, #1                 ' New byte from smart pins
                wfbyte  retval                          ' Add it to the data buffer
                rev     retval                          ' Calculate CRC while next byte is shifting in
                setq    retval                          ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
.end_crc
                add     pkt_cnt, #1
                cmp     pkt_cnt, pkt_tmp        wcz
        if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
        if_a    ret
' For full-speed at 80MHz, the time it takes to do the final byte write and
' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
' to miss it, so cheat a bit and look for SOP clear here.
                rqpin   urx, dm
                testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
        if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
.chk_crc
                sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
                xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
        if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
                mov     retval, #PID_ACK
                mov     hctwait, ip_delay
                call    #poll_waitx

                ' Fall through to utx_handshake

'------------------------------------------------------------------------------
' Transmit a handshake PID. The routine assumes that the bus is IDLE and
' the appropriate IP delay has been inserted.
'------------------------------------------------------------------------------
' On entry:
'   retval - handshake PID to send.
' On exit:
'   retval unchanged.
'------------------------------------------------------------------------------
utx_handshake
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                mov     utx, retval
                call    #utx_byte                       ' Send handshake PID
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
                mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
                jmp     #poll_waitx

'------------------------------------------------------------------------------
' Wait for the USB tx buffer to empty and feed it a new byte.
'------------------------------------------------------------------------------
' On entry:
'   utx - byte to transmit.
' On exit:
'------------------------------------------------------------------------------
utx_byte
                testp   dp                      wc
        if_nc   jmp     #utx_byte
                akpin   dp
                waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
        _ret_   wypin   utx, dm

'------------------------------------------------------------------------------
' Fetch the next data byte of a packet. Always check receiver status for EOP.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the byte read.
'   urx - the receiver status. The caller must check the hstatus reg EOP flag
'     on return. If EOP is set, the byte in reg retval remains as the last byte
'     received.
'------------------------------------------------------------------------------
urx_next
                rdpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
        if_nz   ret                                     ' New byte is priority, so return now
                testb   urx, #SOPB              wc
                testb   urx, #BUS_ERRB          wz
   if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
        if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
                ret

'------------------------------------------------------------------------------
' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
' the data used for the USB-5 CRC lookups. The token packet is three bytes in
' length, and the PID is not included in the CRC calculation:
'  CRC5  FRAME_NUMBER SOF (full-speed)
'  CRC5  ENDP ADDRESS PID
' %00000_1111_1111111_xxxxxxxx
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - stuffed with the function endpoint, address and
'     SETUP/IN/OUT/SOF PID according to the USB standard.
' On exit:
'   ep_addr_pid - CRC value appended to the packet.
'------------------------------------------------------------------------------
calc_crc5
                and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
                mov     htmp, ep_addr_pid
                shr     htmp, #8                        ' PID not included in CRC calc
                mov     crc, #$1f                       ' Initial CRC5 value
                rev     htmp                            ' Input data reflected
                setq    htmp                            ' CRCNIB setup for data bits 0..7
                crcnib  crc, #USB5_POLY
                crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
                shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
                crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                xor     crc, #$1f                       ' Final XOR value
                shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
        _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home

'------------------------------------------------------------------------------
' Full-speed/low-speed frame timing interrupt service routine.
'------------------------------------------------------------------------------
isr1_fsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                mov     utx, #PID_SOF
                wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
                call    #utx_byte                       ' Send token PID byte
                mov     icrc, #$1f                      ' Prime the CRC5 pump
                mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
                rev     sof_pkt                         ' Input data reflected
                setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
                crcnib  icrc, #USB5_POLY
                crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
                getbyte utx, frame, #0                  ' Send the low byte of the frame number
                call    #utx_byte
                shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
                rep     #2, #3                          ' Three data bits left to process
                shl     sof_pkt, #1             wc
                crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
                xor     icrc, #$1f                      ' Final XOR value
                getbyte utx, frame, #1                  ' Send remaining frame number bits
                shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
                or      utx, icrc
                call    #utx_byte                       ' Last start-of-frame byte is on the wire
                mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
                jmp     #isr1_wait
isr1_lsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
                mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
isr1_wait
                rqpin   utx, dm
                testb   utx, #SOPB                 wc
        if_c    jmp     #isr1_wait
                add     frame, #1                       ' Next frame# and check for wrap around
                and     frame, ##$7ff
                waitx   isrtmp1                         ' Make sure bus is idle
                reti1

'------------------------------------------------------------------------------
' Wait for a window within the 1ms frame boundary that will ensure that a
' transaction will complete before the next frame is triggered.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
wait_txn_ok
                getct   htmp2
                sub     htmp2, iframe_ct_base
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    cmp     htmp2, _txn_ok_ls_      wcz
        if_nc   cmp     htmp2, _txn_ok_fs_      wcz
        if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
                ret

'------------------------------------------------------------------------------
' A device connection was detected, or a bus reset was requested by the USB
' client. Set the appropriate smart pin FS/LS speed mode to match the device
' and perform a reset sequence prior to device enumeration.
'------------------------------------------------------------------------------
dev_reset
                rqpin   urx, dm
                testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
        if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
        if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
reset
                setint1 #0                              ' Don't want frame interrupt while in reset
                wypin   #OUT_SE0, dm                    ' Assert bus reset
                waitx   _reset_hold_                    ' Spec is >= 10ms
                wypin   #OUT_IDLE, dm
                mov     frame, #0                       ' Reset the frame timespan count
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
                add     htmp, #36
                setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
.framewait
                cmp     frame, htmp             wcz
        if_b    jmp     #.framewait
                ret

'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - source address.
'   PB - destination address.
'   hr0 - length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
hmemcpy
                rdbyte  htmp, ptra++
                wrbyte  htmp, pb
                add     pb, #1
        _ret_   djnz    hr0, #hmemcpy

'------------------------------------------------------------------------------
' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
' loop until the errant device is disconnected.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
host_error
                mov     usb_err_code, retval            ' Save the error code for the client interface
                wxpin   #USB_ERROR, usb_event_pin       ' Signal the client an error has occurred
                mov     hrep, #5
.spin
                cmp     cmd_data, #CMD_RESET    wz
        if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
        if_z    drvl    host_error_led
        if_z    jmp     #host_reset                     ' See if it works...
                drvnot  host_error_led
                mov     hctwait, _100ms_                ' Blink the error LED
                call    #poll_waitx
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #.spin
                djnz    hrep, #.spin
        if_c    drvl    host_error_led                  ' Clear the error LED
        if_c    ret                             wc      ' Handle disconnect?
                mov     hrep, #5
                jmp     #.spin

'------------------------------------------------------------------------------
' Post interrupt IN transactions at configured intervals.
'------------------------------------------------------------------------------
poll_kbd
                getct   hct3
                addct3  hct3, _8ms_                     ' Set the timer for next poll interval
                jmp     #\hget_kbd_in_report

poll_gamepad
                getct   hct3
                addct3  hct3, _8ms_
                jmp     #\hget_gp_in_report

' USB commands and error codes
cmd_data        long    0
usb_err_code    long    ERR_NONE

' Parameters block assigned at cog startup
dm              long    USB_BASE_PIN + 2    ' Client defines the basepin for four consecutive USB port pins
dp              long    USB_BASE_PIN + 3
usb_event_pin   long    USB_BASE_PIN        ' Host event reporting uses a long repository smart pin
host_active_led long    57                  ' Client defines the LED pin# for host bus activity
host_error_led  long    56                  ' Client defines the LED pin# to light on error
kb_cur_report_p long    @kb_cur_report
kb_pre_report_p long    @kb_pre_report
gp_descr_p      long    @gp_descr
gp_cur_report_p long    @gp_cur_report
gp_pre_report_p long    @gp_pre_report
urx_buff_p      long    @urx_buff
dev_desc_buff_p long    @dev_desc_buff
con_desc_buff_p long    @con_desc_buff
cache_start_p   long    @usb_cache_start
cache_end_p     long    @usb_cache_end

hdev_init_start
kb_intf_num     long    0
kb_interval     long    0
kb_in_max_pkt   long    0
kb_next_datax   long    0
kb_max_index    long    0
kb_led_states   long    0
gp_intf_num     long    0
gp_interval     long    0
gp_in_max_pkt   long    0
gp_next_datax   long    0
gp_max_index    long    0
gp_descr_len    long    0
hdev_init_end

hidr_start
hidr_id         long    0
hidr_axis       long    0[3]
hidr_buttons    long    0
hidr_hats       long    0
hidr_flags      long    0
hidr_state      long    0
hidr_size       long    0
hidr_count      long    0
hidr_offset     long    0
hidr_usage      long    0
hidr_usage_idx  long    0
hidr_lminmax    long    0
hidr_pminmax    long    0
hidr_end

' Initialized at cog startup:
save_sysclk     long    0         ' Save the current sysclock as the client may change it
hcog_base_addr  long    0         ' This object's start address in hub, read from PTRB at cog creation
iframe_ct_new   long    0
iframe_ct_base  long    0
p2rev_val       long    P2RevB
utx_tweak       long    0         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
' This register block is reset to zero when a USB device connects
hreg_init_start
hstatus         long    0         ' Host status flags
hctwait         long    0         ' Poll-based wait clocks
ip_delay        long    0         ' Inter-packet delay in bit periods for connected device speed
tat_wait        long    0         ' Maximum bus turn-around time in bit periods for connected device speed
nak_retry       long    0         ' NAK retry count, unlimited retries if zero
xfer_retry      long    0         ' Control transfer retry count
retry           long    0         ' Transaction retry count
utx             long    0         ' Byte to transmit on USB
urx             long    0         ' LSByte receiver status flags, MSByte received data
newb_flg        long    0         ' Receive "new byte" bit toggle detector
poll_target     long    0         ' Address of a subroutine that polls an interrupt IN endpoint
max_pkt_size    long    0         ' Maximum payload bytes allowed, likely to change on device connect.
total_data      long    0         ' Total bytes to tx/rx in a transfer data stage
stage_data      long    0         ' Count of bytes sent/received so far during a data stage.
pkt_data        long    0         ' Payload size of an OUT packet or bytes received on IN
frame           long    0         ' USB 1ms frame counter value
sof_pkt         long    0         ' ISR frame# packet and CRC5
icrc            long    0         ' Only used by the 1ms frame output ISR routine
pkt_cnt         long    0         ' Count of DATAx packet payload bytes
crc             long    0         ' Used for CRC16 calculation
ep_addr_pid     long    0         ' Endpoint and device addresses for connected device
retval          long    0         ' Global success/fail return parameter
context_retval  long    0         ' Operation contextual return parameter
' Device stuff
hdev_id         long    0
hdev_bcd        long    0
hdev_ready      long    0         ' Configured device indicator
' Keyboard/mouse stuff
hctrl_ep_addr   long    0
hctrl_max_pkt   long    0
hconfig_base    long    0
hcon_tot_len    long    0         ' Size of the complete config descriptor chain
hdev_intf_idx   long    0         ' Used during verbose descriptor terminal output
hdev_class      long    0
hdev_subclass   long    0
hdev_protocol   long    0
hsearch_key     long    0         ' Descriptor type to search for in the config chain
hnext_desc      long    0         ' Offset from the config descriptor start address to the next descriptor in the chain
hkbd_ep_addr    long    0         ' Keyboard interface endpoint address
hkbd_poll_cnt   long    0         ' Poll interval counter used for key auto-repeat
hkbd_ledstates  long    0         ' Off/on state of keyboard LEDs
hpad_ep_addr    long    0
hpad_out_addr   long    0
hpad_poll_cnt   long    0
hreg_init_end
' Variables dependent on the system freqency
_var_64_lower_  res     1
_var_64_upper_  res     1
_12Mbps_        res     1
_1_5Mbps_       res     1
_1ns16fp_       res     1         ' 1ns as 32,16 fixed point
_1us_           res     1         ' 1us
_10us_          res     1         ' 10us
_33us_          res     1         ' 33us
_txn_err_       res     1         ' 250us
_500us_         res     1         ' 500us
_txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
_txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
_ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
_ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
_tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
_tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
_1ms_           res     1         ' 1ms
_2ms_           res     1         ' 2ms
_suspend_wait_  res     1         ' 3ms
_4ms_           res     1         ' 4ms
_xfer_wait_     res     1         ' 5ms
_8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
_reset_hold_    res     1         ' 15ms
_resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
_21ms_          res     1         ' 21ms
_100ms_         res     1         ' 100ms
_500ms_         res     1         ' 500ms
_pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
_frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'------------------------------------------------------------------------------
_usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
_usb_d_ls_nco_  res     1
_usb_h_fs_nco_  res     1
_usb_d_fs_nco_  res     1
'------------------------------------------------------------------------------
' Scratch registers
htmp            res     1         ' Scratch registers whose context remains within the same code block
htmp1           res     1
htmp2           res     1
htmp3           res     1
hrep            res     1         ' Repeat count
hsave0          res     1         ' Subroutine parameter saves
hsave1          res     1
hsave2          res     1
isrtmp1         res     1
pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
hr0             res     1         ' Multi-purpose registers
hr1             res     1
hr2             res     1
hr3             res     1
hpar1           res     1         ' Routine entry/exit parameters
hpar2           res     1
hpar3           res     1
hct2            res     1         ' Function response bus turn-around timer
hct3            res     1         ' Keyboard/mouse poll timer
mod_cnt         res     1         ' Used in idle loops

                fit     $1F0

DAT             ' USB Host LUT execution
                org     $200
hlut_start

'------------------------------------------------------------------------------
' Full-speed is the host's native speed, so all that is needed is to set the FS
' settings to startup defaults.
'------------------------------------------------------------------------------
' On entry:
' On exit: Save/restore caller C flag state if C is changed in this routine!
'------------------------------------------------------------------------------
set_speed_full
                mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
'                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' When a low-speed device connects, the D-/D+ signaling is inverted. If there
' is a downstream hub connected (not yet implemented), the baud generator
' remains set at the full-speed rate, but signaling is switched to low-speed,
' which reverses the D-/D+ polarity. The polarity can be changed without
' putting the smart pins into reset.
'------------------------------------------------------------------------------
' On entry:
' On exit: CZ flags restored to caller states
'------------------------------------------------------------------------------
set_speed_low
                test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
        if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
                testb   p2rev_val, #0           wc      ' P2 Revision is either %0001 (A) or %0010 (B+)
        if_c    dirl    dm                              ' P2RevA needs to be completely reconfigured
        if_c    dirl    dp
        if_c    wrpin   ##USB_V1HMODE_LS, dm            ' Low-speed signaling is always used
        if_c    wrpin   ##USB_V1HMODE_LS, dp
        if_c    wxpin   _1_5Mbps_, dm                   ' Set 1.5Mbs baud if no downstream hub
        if_c    dirh    dm
        if_c    dirh    dp
        if_nc   wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
                bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' Perform configuration stuff required when a device intitially connects.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
on_connect
                mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
                call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
.retry
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
        if_nc   mov     hpar1, #USB_SPEED_FULL
                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$40, ptra[wLength]             ' Request IN data stage max of 64 bytes will test actual < requested logic
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.get_dev_desc
                mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
                call    #poll_waitx
                sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
        if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
                call    #reset                          ' Try another reset to see if the device responds
                jmp     #.retry
.get_dev_desc
                mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
                call    #reset
                loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
                add     ptra, hcog_base_addr
                wrword  #1, ptra[wValue]                ' Only support one device port at this time
                call    #control_write                  ' Execute SetAddress()
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctwait, _8ms_
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, #1 << 8            ' Device ep/addr now #1 and endpoint zero
                call    #calc_crc5
                loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
                add     ptra, hcog_base_addr
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
                mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
                rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
                mov     hctwait, _500us_
                call    #poll_waitx
                loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$ff, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   ret
                mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
                mov     hconfig_base, ptra              ' Will need this for configuration
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    mov     retval, #ERR_CONFIG_FAIL
        if_b    jmp     #host_error
                loc     pa, #@hparse_con_desc - @usb_host_start
                add     pa, hcog_base_addr
                jmp     pa

'------------------------------------------------------------------------------
' Perform a control read transaction (Section 8.5.3, Figure 8-37).
' Status reporting is always in the function-to-host direction.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data in hub.
'   PB - start address of the buffer/struct to be written to during the IN data
'     stage.
'   ep_addr_pid - device address, endpoint and CRC5.
' On exit:
'   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'     contains the count of data stage bytes actually received, which must
'     always be <= the count requested.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_read
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb                       ' Save dest buffer pointer
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                mov     nak_retry, ##IN_NAK_RETRIES
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
.nak_retry
                mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
.in_retry
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' Commit on ACK
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak_retry                     ' Function not ready to send data
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.in_retry                      ' Bus error retry
                ret                                     ' The transfer has failed
.commit
                cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
        if_z    jmp     #.pre_status                    ' and also end-of-data
                mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
                add     stage_data, pkt_cnt             ' Update bytes received on commit
                cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
        if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
                cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
        if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
        if_a    mov     retval, #ERR_PACKET
        if_a    mov     context_retval, retval          ' In this case overall and context are the same
        if_a    ret                                     ' Caller must handle ERR_PACKET
                bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
                jmp     #.data                          ' Start next IN transaction
.pre_status
                mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
                setbyte ep_addr_pid, #PID_OUT, #0
                mov     pkt_data, #0
                bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
                mov     nak_retry, ##OUT_NAK_RETRIES
.out_retry
                call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
                cmp     retval, #PID_ACK        wz
        if_z    ret                                     ' All is good when ACK
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
                ret                                     ' Caller must handle transfer retirement
' I've encountered transfer STALL, even though the data looks correct, and
' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
' ControlRead() transfer gets things unstuck most of the time...
.xfer_retry
                mov     hctwait, _xfer_wait_
                call    #poll_waitx
                call    #wait_txn_ok
                mov     ep_addr_pid, hpar1
                mov     ptra, hpar2
                mov     pb, hpar3
                djnz    xfer_retry, #.xfer_start
                mov     context_retval, retval          ' Preserve the USB error code
        _ret_   mov     retval, #ERR_XFER_RETRY

'------------------------------------------------------------------------------
' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
' reporting is always in the function-to-host direction. It is assumed that
' the SETUP data struct is filled with the required values.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to the start of the struct for the SETUP data.
'   PB - the start address of the struct/buffer to be read for the OUT data
'     stage.
'   ep_addr_pid - the proper CRC'd address and endpoint to use.
' On exit:
'   retval - used to convey the success/failure of each stage.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_write
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
.out_retry
                mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
                call    #txn_out
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit                        ' Function got the data
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
        if_nz   jmp     #.out_retry
                ret                                     ' Caller must handle transfer retirement
.commit
                mov     pb, ptra                        ' Save the current buffer/struct location
                add     stage_data, pkt_data
                cmp     stage_data, total_data  wz
        if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
        if_nz   jmp     #.data                          ' More data to send
pre_status_in
                bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.status_retry
                mov     pkt_data, #0
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
        if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
        if_z    ret                                     ' Control Write finished
                cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
        if_z    ret
                call    #retry_wait                     ' NAK or bus error, so delay a bit
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.status_retry
                ret                                     ' Caller must handle transfer retirement

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - The function address and endpoint for the IN request.
'   hpar2 - Address of the IN data buffer
'   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
' On exit:
'   retval - the result of the operation.
'   hpar3 - the count of IN data bytes actually received.
'------------------------------------------------------------------------------
do_int_in
                getword htmp, hpar3, #0
                cmp     htmp, #PID_DATA0        wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
                mov     retry, #TXN_RETRIES
.retry
                getword pkt_data, hpar3, #1             ' IN max packet length
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK if data received
        if_z    jmp     #.commit
                cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
        if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
        if_z    jmp     #.post_ret                      ' The caller must handle either
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    jmp     #.post_ret
                jmp     #.retry
.commit
                cmp     pkt_cnt, #0             wz
        if_z    jmp     #.post_ret                      ' Skip copy if it's an empty packet
                mov     ptra, urx_buff_p                ' Copy the rx buffer
                mov     pb, hpar2                       ' to the destination buffer
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
.post_ret
                mov     hpar3, pkt_cnt                  ' IN bytes actually received
                ret

'------------------------------------------------------------------------------
' The one millisecond frame timer is implemented as an interrupt service
' routine. Since this timing is critical, care must be taken to avoid any
' instructions that can delay the interrupt branch, which will likely upset
' the timer. WAITX is among those instructions, so any time you're inside
' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'------------------------------------------------------------------------------
' On entry:
'   hctwait - wait interval in sysclocks.
' On exit:
'------------------------------------------------------------------------------
poll_waitx
                getct   hct2
                addct2  hct2, hctwait
.wait
                jnct2   #.wait
                ret

'------------------------------------------------------------------------------
' Transaction retry handling for NAK/STALL or bus error.
'------------------------------------------------------------------------------
' On entry:
'   retval - transaction response PID or error code.
' On exit:
'------------------------------------------------------------------------------
retry_wait
                cmp     retval, #PID_STALL      wz
        if_z    ret                                     ' STALL is special case
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak
                mov     hctwait, _txn_err_              ' Transaction error wait...
                call    #poll_waitx
.dec
                sub     retry, #1               wz
        if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
                ret                                     ' Retry result to caller
.nak
                mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
                call    #poll_waitx
                cmp     nak_retry, #NAK_NOLIMIT wz
        if_z    ret                                     ' Indefinite NAK retries
                sub     nak_retry, #1           wz
        if_z    mov     retval, #ERR_NAK
                ret

host_reset
                setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
                mov     htmp, ##_CLKFREQ                ' Get current sysclock setting
' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
                cmp     htmp, ##168_000_000     wcz
        if_be   mov     utx_tweak, #0
        if_a    mov     utx_tweak, #3   '#20
' Check to see if the system clock has been changed.
                cmp     htmp, save_sysclk       wz
        if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
        if_nz   add     pb, hcog_base_addr
        if_nz   call    pb                              ' Recalculate sysclk dependent timing values
                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                cmp     p2rev_val, #P2RevB      wz
        if_z    jmp     #.not_reva
                wrpin   ##USB_V1HMODE_FS, dm            ' The host is also the root hub, so full-speed is its native speed
                wrpin   ##USB_V1HMODE_FS, dp
                wxpin   _12Mbps_, dm                    ' Default to Full-Speed
                jmp     #.enable
.not_reva
                wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
                wrpin   ##USB_V2_DRVOUT, dp
                wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
.enable
                dirh    dm                              ' Crank them smart pins up
                dirh    dp
                waitx   _1us_
                wypin   #OUT_IDLE, dm
                waitx   _21ms_                          ' Hold to let the idle state get settled
                mov     pa, #hreg_init_start            ' Reset all host common registers to startup values
.regloop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hreg_init_end      wz
        if_nz   jmp     #.regloop
discon_entry
                mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one

                ' Fall through to disconnected loop

'-----------------------------------------------------------------------------------------------------------------
' Device connect handling (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
' device to connect (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
disconnected
                mov     hr1, ##_CLKFREQ                 ' Check to see if the system frequency has changed
                cmp     hr1, save_sysclk        wz
        if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
                shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
                waitx   hr1                             ' it down to smaller wait chunks
                incmod  mod_cnt, #8             wc
        if_c    drvnot  host_active_led
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
        if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
        if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
.se1_test
                mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
                call    #poll_waitx
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
        if_ne   jmp     #discon_entry                   ' Back to connect detection loop
.se1            'SE1 is a fatal error condition
                mov     hctwait, _100ms_
                call    #poll_waitx
                mov     retval, #ERR_SE1
                call    #host_error                     ' Seeing SE1 for any length of time is not good...
.connect_test                                           ' Test lines until stable J/K state seen
                waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_z    jmp     #discon_entry                   ' D+ and D- low
        if_e    jmp     #.se1_test                      ' D+ and D- high
connected
                bith    hstatus, #CONNECTEDB            ' Device plugged in
                call    #on_connect                     ' Initial device configuration
                cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
        if_nz   jmp     #discon_entry
set_poll_target
                mov     poll_target, #0                 ' If unknown device, no interrupt targets
                cmp     hkbd_ep_addr, #0        wz
        if_nz   mov     poll_target, #poll_kbd
                cmp     hpad_ep_addr, #0        wz
        if_nz   mov     poll_target, #poll_gamepad
.set_pulse
                getct   _pulse_time_
                add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
' of 1ms and make a correction, if necessary.
'                mov     htmp, _1ms_
'                subs    htmp, iframe_delta
'                adds    _frame1ms_clks_, htmp
'                debug(udec(_frame1ms_clks_))

                ' Fall through to idle/processing loop

hidle
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_c    jmp     #.se0_test
                cmp     poll_target, #0         wz
        if_z    jmp     #.nopoll
                pollct3                         wc
        if_c    call    poll_target                     ' Call the current poll/wait subroutine
.nopoll
                cmp     cmd_data, #CMD_SUSPEND  wz
        if_z    jmp     #hsuspend
                cmp     cmd_data, #CMD_RESET    wz
        if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
        if_z    jmp     #host_reset                     ' See if it works...
                getct   hr0
                cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
        if_ae   drvnot  host_active_led
        if_ae   getct   _pulse_time_
        if_ae   add     _pulse_time_, _500ms_
                jmp     #hidle
' Check for extended SE0 state on the bus
.se0_test
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Wait a bit and test for SE0 again
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #hidle                          ' Bus still IDLE
                call    #wait_txn_ok
                wypin   ##OUT_IDLE, dm                  ' Float USB
                wxpin   #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
                jmp     #host_reset                     ' Device disconnected

hsuspend
                call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
                setint1 #0                              ' Stopping the 1ms frame packets signals suspend
                waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
                wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
                mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
                mov     mod_cnt, #0

                ' Fall through to resume wait loop

hwait_resume
                mov     hr1, ##_CLKFREQ                 ' Use the CLKFREQ value, as the sysclock may change
                shr     hr1, #2
                waitx   hr1                             ' Pulse the activity LED every two seconds but break
                incmod  mod_cnt, #8             wc      ' it down to smaller wait chunks
        if_c    drvnot  host_active_led
                cmp     cmd_data, #CMD_RESUME   wz
        if_nz   jmp     #hwait_resume
                mov     htmp, ##_CLKFREQ                ' Check to see if the system frequency has changed
                cmp     htmp, save_sysclk       wz
        if_z    jmp     #.resume
                loc     pb, #@hinit_usb_timings - @usb_host_start
                add     pb, hcog_base_addr
                call    pb                              ' Recalculate sysclk dependent timing values
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
        if_c    wxpin   _usb_h_ls_nco_, dm
.resume
                wypin   #OUT_K, dm
                waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
                wypin   #OUT_SE0, dm
                mov     htmp, _ip_delay_ls_
                shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
                waitx   htmp
                wypin   #OUT_J, dm
                shr     htmp, #1
                waitx   htmp
                wypin   #OUT_IDLE, dm
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                setint1 #1                              ' Enable the 1ms frame ISR
                mov     hctwait, _4ms_
                call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
                mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
                jmp     #set_poll_target                ' This addr configs a USB poll transaction and falls thru to hidle

hlut_end
                fit     $400

DAT             ' USB Host HUB execution
                orgh
'------------------------------------------------------------------------------
' Routines called from cog space.
'------------------------------------------------------------------------------
' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'------------------------------------------------------------------------------

'------------------------------------------------------------------------------
' USB host cog initialization.
'------------------------------------------------------------------------------
usb_host_init
                drvl    host_error_led                  ' Ensure fatal error LED is inactive
'                mov     p2rev_val, ptrb                 ' Running on P2RevA or P2RevB+ silicon?
'                setq    #1
'                rdlong  $1e0, ptrb++
'                subr    p2rev_val, ptrb
'                shr     p2rev_val, #2           wz      ' RevA if shift result is zero
'        if_z    mov     p2rev_val, #P2RevA              ' 1 == RevA, 2 == RevB+
'                loc     ptrb, #p2rev_char               ' Make a revision "A" or "B" char accessible to Spin2
'                mov     htmp, p2rev_val
'                add     htmp, #"@"
'                wrbyte  htmp, ptrb
                dirl    usb_event_pin                   ' Configure the USB event mailbox smart pin
                wrpin   ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
                dirh    usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
' Configure and enable the Serial Host USB port.
                mov     htmp, usb_event_pin             ' I/O + 1 pin is the Serial Host USB Protection enable/disable
                add     htmp, #1                        ' Protection enable is a one-time operation
                drvh    htmp                            ' Enable the port
                jmp     #host_reset                     ' Initialize host and enter main processing loop

'------------------------------------------------------------------------------
' Timing calculations happen before any interrupt(s) are enabled.
'------------------------------------------------------------------------------
' On entry:
'   htmp - current CLKFREQ value.
'------------------------------------------------------------------------------
hinit_usb_timings
'                getct   htmp2
                mov     save_sysclk, htmp
                qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
                getqx   _12Mbps_
                shr     _12Mbps_, #16           wc
                addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
                mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
                shl     _usb_h_fs_nco_, #14
                add     _usb_h_fs_nco_, _12Mbps_
                mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
                shl     _usb_d_fs_nco_, #14
                add     _usb_d_fs_nco_, _12Mbps_
                mov     _1_5Mbps_, _12Mbps_
                shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
                mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
                shl     _usb_h_ls_nco_, #14
                add     _usb_h_ls_nco_, _1_5Mbps_
                mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
                qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1b
                getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1m
                getqx   _1us_                           ' 1us as 32,9 fixed point
                mov     hsave0, _1us_                   ' Save it to compute other us values
                shr     _1us_, #9               wc
                addx    _1us_, #0                       ' Round to final value
                qmul    hsave0, #10                     ' Calc 10us
                getqx   _10us_
                shr     _10us_, #9              wc
                addx    _10us_, #0                      ' 10us
                qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
                getqx   _33us_
                shr     _33us_, #9              wc
                addx    _33us_, #0                      ' 33us
                qmul    hsave0, #250                    ' Calc 250us
                getqx   _txn_err_
                shr     _txn_err_, #9           wc
                addx    _txn_err_, #0                   ' 250us
                qmul    hsave0, #500                    ' Calc 500us
                getqx   _500us_
                shr     _500us_, #9             wc
                addx    _500us_, #0                     ' 500us
                qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
                getqx   _txn_ok_ls_
                shr     _txn_ok_ls_, #9         wc
                addx    _txn_ok_ls_, #0                 ' 666us
                qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
                getqx   _txn_ok_fs_
                shr     _txn_ok_fs_, #9         wc
                addx    _txn_ok_fs_, #0                 ' 850us
                mov     _ip_delay_ls_, _1ns16fp_
                mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_ls_, #16      wc
                addx    _ip_delay_ls_, #0
                mov     _tat_wait_ls_, _1ns16fp_
                mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
                shr     _tat_wait_ls_, #16      wc
                addx    _tat_wait_ls_, #0
                mov     _ip_delay_fs_, _1ns16fp_
                mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_fs_, #16      wc
                addx    _ip_delay_fs_, #0
                mov     _tat_wait_fs_, _1ns16fp_
                mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
                shr     _tat_wait_fs_, #16      wc
                addx    _tat_wait_fs_, #0
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1thou
                getqx   _1ms_                           ' 1ms as 32,9 fixed point
                shr     _1ms_, #9               wc
                addx    _1ms_, #0                       ' 1ms
                mov     _frame1ms_clks_, ##-14
                adds    _frame1ms_clks_, _1ms_
                mov     _2ms_, _1ms_
                shl     _2ms_, #1                       ' 2ms
                mov     _suspend_wait_, _1ms_
                add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
                mov     _4ms_, _1ms_
                shl     _4ms_, #2                       ' 4ms
                mov     _xfer_wait_, _4ms_
                add     _xfer_wait_, _1ms_              ' 5ms
                mov     _reset_hold_, _xfer_wait_       ' 5ms
                mov     _resume_hold_, _reset_hold_
                shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
                mov     _100ms_, _resume_hold_          ' 20ms
                shl     _100ms_, #1                     ' 40ms
                mov     _8ms_, _1ms_
                shl     _8ms_, #3                       ' 8ms
                shl     _reset_hold_, #1                ' 10ms
                add     _100ms_, _reset_hold_           ' 50ms
                add     _reset_hold_, _xfer_wait_       ' 15ms
                mov     _21ms_, _xfer_wait_             ' 5ms
                shl     _21ms_, #2                      ' 20ms
                add     _21ms_, _1ms_                   ' 21ms
                mov     _500ms_, _100ms_                ' 50ms
                shl     _100ms_, #1                     ' 100ms
                shl     _500ms_, #3                     ' 400ms
        _ret_   add     _500ms_, _100ms_                ' 500ms
'        _ret_   mov     _1sec_, save_sysclk
'        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'                ret
{
                getct   htmp
                sub     htmp, htmp2
        debug("USB timing calc sysclocks: ", udec( htmp))
                ret
}

'------------------------------------------------------------------------------
' Parse a configuration descriptor chain to see if the device is a recognized
' one. If it is, start the task progression that will configure the device for
' use.
'------------------------------------------------------------------------------
' On entry:
'   hconfig_base - start address of the cached config descriptor chain.
' On exit:
'------------------------------------------------------------------------------
hparse_con_desc
                call    #init_kbdm_data                 ' Reset device data area to start-up values

                mov     ptrb, dev_desc_buff_p
                rdword  htmp, ptrb[4]       ' idVendor
                rdword  hdev_id, ptrb[5]    ' idProduct
                setword hdev_id, htmp, #1
                rdword  hdev_bcd, ptrb[6]   ' bcdDevice
                debug(uhex_long(hdev_id), uhex_word(hdev_bcd))

                mov     pa, #CON_wTotalLen
                add     pa, hconfig_base
                rdword  hcon_tot_len, pa                ' Keep config chain size handy
                'debug(uhex_byte_array(hconfig_base, hcon_tot_len))
' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
' that defines a keyboard and/or mouse.
                rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
.next_intf
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #hset_config
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.intf
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                jmp     #.next_intf
.intf
                mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
                mov     hpar3, #0
                rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
                rdbyte  hdev_class, ptrb[INTF_bIntfClass]
                rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
                rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
                debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))

.endp
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #.get_device
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.get_device
                cmp     htmp, #TYPE_ENDPOINT    wz
        if_z    jmp     #.get_ep
                jmp     #.endp
.get_ep
                rdbyte  hr1, ptrb[ENDP_bAddress]
                testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
                shl     hr1, #8 + 7
                mov     htmp, hctrl_ep_addr
                and     htmp, ##ADDR_MASK
                or      htmp, hr1                       ' endpoint address
                cmp     hpar2, #0               wz
  if_z_and_c    jmp     #.in_ep
                cmp     hpar3, #0               wz
 if_z_and_nc    jmp     #.out_ep
                jmp     #.endp
.in_ep
                mov     hpar2, htmp                     ' IN endpoint
                rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr2, hr0, #3
                jmp     #.endp
.out_ep
                mov     hpar3, htmp                     ' OUT endpoint
                rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr3, hr0, #3
                jmp     #.endp

.get_device
                cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
        if_z    cmp     hdev_subclass, #$5D     wz
        if_z    cmp     hdev_protocol, #$01     wz
        if_z    jmp     #.gamepad
                cmp     hdev_class, #CLASS_HID              wz
        if_nz   jmp     #.next_intf                     ' No HID class, ignore
                cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
        if_z    cmp     hdev_protocol, #INTF_PROTO_NONE     wz
        if_z    jmp     #.gamepad
                cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
        if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
.keyboard
                cmp     hdev_protocol, #INTF_PROTO_KBD      wz
        if_nz   jmp     #.next_intf                     ' No Keyboard
                cmp     hkbd_ep_addr, #0    wz
        if_nz   jmp     #.next_intf
                getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
                getbyte kb_interval, hr2, #3
                mov     hkbd_ep_addr, hpar2             ' IN endpoint address
                getbyte kb_in_max_pkt, hr2, #0
                'debug(udec(kb_intf_num))
                debug(uhex_long(hkbd_ep_addr),udec(kb_in_max_pkt,kb_interval))
                jmp     #.next_intf
.gamepad
                cmp     hkbd_ep_addr, #0    wz
        if_z    cmp     hpad_ep_addr, #0    wz
        if_nz   jmp     #.next_intf
                getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
                getbyte gp_interval, hr2, #3
                mov     hpad_ep_addr, hpar2             ' IN endpoint address
                mov     hpad_out_addr, hpar3            ' OUT endpoint address
                getbyte gp_in_max_pkt, hr2, #0
                'debug(udec(gp_intf_num))
                debug(uhex_long(hpad_ep_addr),udec(gp_in_max_pkt,gp_interval),uhex_long(hpad_out_addr))
                jmp     #.next_intf

'------------------------------------------------------------------------------
' If a newly-connected device is recognized, do whatever is needed to configure
' it according to its function, or functions. In the case of this boot protocol
' keyboard/mouse class driver:
' - SetConfiguration(config_num)
' - SetProtocol(boot)
' - SetIdle(indefinite)
' - Enter the device interrupt IN polling task stage.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hset_config
'                mov     hkbd_ep_addr, #0                ' DEBUG
'                mov     hmouse_ep_addr, #0              ' DEBUG
                mov     htmp2, #DEV_UNKNOWN
                cmp     hkbd_ep_addr, #0        wz
        if_z    cmp     hpad_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No boot keyboard or mouse interface
.set_config
                loc     ptra, #set_config
                mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
                add     pa, hconfig_base
                rdbyte  hpar1, pa
                wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
                mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
                mov     pb, #0                          ' SetConfiguration() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   ret
.kbd_config
                cmp     hkbd_ep_addr, #0        wz
        if_z    jmp     #.gamepad_config                ' No keyboard
                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_protocol
                wrword  #BOOT_PROTOCOL, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                mov     pb, #0                          ' SetProtocol() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
                getbyte hpar2, kb_intf_num, #0
                call    #hset_idle
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hctwait, _2ms_
                call    #poll_waitx
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     ep_addr_pid, hkbd_ep_addr
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                mov     hkbd_ep_addr, ep_addr_pid
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
                mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
                mov     htmp2, #KB_READY                ' Keyboard interface configured
                jmp     #.notify_client
.gamepad_config
                cmp     hpad_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No gamepad

                mov     ep_addr_pid, hpad_ep_addr
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                mov     hpad_ep_addr, ep_addr_pid
                mov     ep_addr_pid, hpad_out_addr  wz
        if_nz   setbyte ep_addr_pid, #PID_OUT, #0
        if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
        if_nz   mov     hpad_out_addr, ep_addr_pid
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration

                cmp     hdev_class, #$FF        wz      ' XInput vendor class
        if_ne   jmp     #.noxinput                      ' No XInput, try others

                loc     ptra, #xinp_led_cmd             ' Turn on LEDs
                mov     pkt_data, #3
                bitl    hstatus, #DATAx_TGLB
                mov     ep_addr_pid, hpad_out_addr
                call    #txn_out
                mov     ep_addr_pid, hctrl_ep_addr

                mov     htmp2, #XINPUT_READY
                jmp     #.notify_client

.noxinput
                loc     ptra, #get_desc                 ' Hub start address of GetConfigurationDescriptor SETUP struct
                wrword  #$ff, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                mov     pb, gp_descr_p                  ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hpad_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     gp_descr_len, total_data
                'debug(uhex_byte_array(gp_descr,gp_descr_len))

                cmp     hdev_id, ##$054C_0268   wz      ' PS3 vendor/product
        if_ne   mov     htmp2, #GP_READY                ' No PS3, standard gamepad
        if_ne   jmp     #.notify_client                 ' No further processing needed

                getbyte htmp, gp_intf_num, #0
                loc     ptra, #set_report
                wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                wrword  #48, ptra[wLength]
                loc     pb, #ps3_command_buff           ' set LEDs
                call    #control_write

                getbyte htmp, gp_intf_num, #0
                loc     ptra, #set_report
                wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                wrword  #4, ptra[wLength]
                loc     pb, #ps3_enable_cmd             ' Enable PS3
                call    #control_write
                cmp     retval, #PID_ACK    wz
        if_nz   mov     hpad_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     htmp2, #PS3_READY               ' PS3 gamepad ready

.notify_client
                mov     hdev_ready, htmp2               ' Save device ready
        _ret_   wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured

'------------------------------------------------------------------------------
' Initialize the keyboard/mouse data area to start-up values.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
init_kbdm_data
                mov     hkbd_ep_addr, #0
                mov     hpad_ep_addr, #0

                mov     ptra, cache_start_p         ' Clear cached data buffers
                mov     pa, cache_end_p
.loop
                wrbyte  #0, ptra++
                cmp     ptra, pa                wcz
        if_b    jmp     #.loop

                mov     pa, #hdev_init_start        ' Clear device data registers
.regloop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hdev_init_end      wz
        if_nz   jmp     #.regloop
                mov     kb_next_datax, #PID_DATA0   ' Reset interrupt IN datax sequence PIDs
        _ret_   mov     gp_next_datax, #PID_DATA0

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
' function.
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'   hpar2 - index number of the target interface.
' On exit:
'------------------------------------------------------------------------------
hset_idle
                mov     hctwait, _2ms_
                call    #poll_waitx
                loc     ptra, #set_idle
                wrword  hpar1, ptra[wValue]
                wrword  hpar2, ptra[wIndex]
                jmp     #control_write

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - device address and enpoint for the request.
' On exit:
'   retval - transaction result.
'------------------------------------------------------------------------------
hset_kbdled_report
                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_report
                wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
                wrword  htmp, ptra[wIndex]
                wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
                mov     pb, urx_buff_p
                wrbyte  kb_led_states, pb
                jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for keyboard activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_kbd_in_report
                mov     ep_addr_pid, hkbd_ep_addr
                mov     hpar2, kb_cur_report_p
                setword hpar3, kb_next_datax, #0
                setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.data
                cmp     retval, #PID_NAK        wz
        if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
                ret                                     ' No auto-repeat action
.data
                drvnot  host_active_led                 ' Show keypress activity on the feedback LED
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet
                mov     hpar1, kb_next_datax
                cmp     hpar1, #PID_DATA0       wz
        if_z    mov     hpar1, #PID_DATA1               ' Txn success, so toggle DATAx
        if_nz   mov     hpar1, #PID_DATA0
                mov     kb_next_datax, hpar1
                mov     kb_max_index, hpar3             ' Save actual bytes read
                call    #hkbd_compare
.led_check
                mov     htmp, kb_led_states
                cmp     hkbd_ledstates, htmp    wz
        if_z    ret                                     ' No toggle key indicator changes, so we're done
                mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
                mov     ep_addr_pid, hctrl_ep_addr
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #host_error                     ' FIXME: on !ACK try to recover instead of fatal error
                ret

'------------------------------------------------------------------------------
' Compare current and previous keyboard data buffers for keypress changes.
'------------------------------------------------------------------------------
hkbd_compare
                mov     ptra, kb_cur_report_p

                mov     htmp, ##$7F7F7F7F

                rdbyte  hr0, ptra
                testb   hr0, #LEFT_CTRLB    wz  ' LCTRL (LEFT BUTTON)
                bitnz   htmp, #8+6
                testb   hr0, #LEFT_SHIFTB   wz  ' LSHIFT (RIGHT BUTTON)
                bitnz   htmp, #6

                add     ptra, #2
                mov     pa, #6
.l1             rdbyte  hr0, ptra++

                cmp     hr0, #$1E       wz  ' 1
        if_z    setnib  htmp, #$D,  #0
                cmp     hr0, #$1F       wz  ' 2
        if_z    setnib  htmp, #$7,  #0
                cmp     hr0, #$20       wz  ' 3
        if_z    setnib  htmp, #$C,  #0
                cmp     hr0, #$21       wz  ' 4
        if_z    setnib  htmp, #$2,  #0
                cmp     hr0, #$22       wz  ' 5
        if_z    setnib  htmp, #$3,  #0
                cmp     hr0, #$23       wz  ' 6
        if_z    setnib  htmp, #$E,  #0
                cmp     hr0, #$24       wz  ' 7
        if_z    setnib  htmp, #$5,  #0
                cmp     hr0, #$25       wz  ' 8
        if_z    setnib  htmp, #$1,  #0
                cmp     hr0, #$26       wz  ' 9
        if_z    setnib  htmp, #$B,  #0
                cmp     hr0, #$27       wz  ' 0
        if_z    setnib  htmp, #$A,  #0
                cmp     hr0, #$2D       wz  ' *
        if_z    setnib  htmp, #$9,  #0
                cmp     hr0, #$2E       wz  ' #
        if_z    setnib  htmp, #$6,  #0

                cmp     hr0, #$4F       wz  ' RIGHT
        if_z    bitl    htmp, #8+1
                cmp     hr0, #$50       wz  ' LEFT
        if_z    bitl    htmp, #8+3
                cmp     hr0, #$51       wz  ' DOWN
        if_z    bitl    htmp, #8+2
                cmp     hr0, #$52       wz  ' UP
        if_z    bitl    htmp, #8+0

                djnz    pa, #.l1

                wrlong  htmp, #@coleco_ctrls

                ret

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for gamepad activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_gp_in_report
                mov     ep_addr_pid, hpad_ep_addr
                mov     hpar2, gp_cur_report_p
                setword hpar3, gp_next_datax, #0
                setword hpar3, gp_in_max_pkt, #1        ' Always ask for max report size
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.data
                cmp     retval, #PID_NAK        wz
        if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
                ret
.data
                incmod  hpad_poll_cnt, #62      wc
        if_c    drvnot  host_active_led
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet
                mov     hpar1, gp_next_datax
                cmp     hpar1, #PID_DATA0       wz
        if_z    mov     hpar1, #PID_DATA1               ' Txn success, so toggle DATAx
        if_nz   mov     hpar1, #PID_DATA0
                mov     gp_next_datax, hpar1
                mov     gp_max_index, hpar3             ' Save actual bytes read

' Note: the following code compares the current and previous reports
' and process the data if there are changes to ease the debug output.
' Actual implementations should remove this block, along with gp_pre_report_p and
' gpPreReport buffer.

                ' ----- start of block to remove
                mov     ptra, gp_cur_report_p           ' Attempt to notify changes
                mov     ptrb, gp_pre_report_p           ' by comparing the report bytes

                cmp     hdev_ready, #PS3_READY  wz
        if_e    mov     hpar3, #10                      ' Only first 10 bytes are significant for PS3 report

                mov     pa, hpar3
                modz    _set            wz
.lp
                rdbyte  htmp1, ptra++
                rdbyte  htmp2, ptrb
        if_z    cmp     htmp1, htmp2    wz
                wrbyte  htmp1, ptrb++
                djnz    pa, #.lp
        if_z    ret                                     ' Ignore report if not changed
                ' ----- end of block to remove

'------------------------------------------------------------------------------
' Decode controller report
'------------------------------------------------------------------------------
hid_decode
                mov     htmp, #hidr_start       ' clear all hid report registers
.cl             altd    htmp
                mov     0-0, #0
                add     htmp, #1
                cmp     htmp, #hidr_end     wz
        if_nz   jmp     #.cl

                mov     ptrb, gp_cur_report_p
                cmp     hdev_ready, #XINPUT_READY   wz
        if_z    jmp     #hpad_xinput
                cmp     hdev_ready, #PS3_READY      wz
        if_z    jmp     #hpad_ps3

'------------------------------------------------------------------------------
' Handle HID controller
' On entry:
'   ptrb - controller report
'------------------------------------------------------------------------------
hpad_hid
                mov     ptra, gp_descr_p
                mov     pa, gp_descr_len
                mov     hidr_usage, ##$76543210

.next
                cmps    pa, #0      wcz
        if_be   jmp     #hpad_translate

                rdbyte  hpar1, ptra++
                sub     pa, #1
                mov     hpar2, #0

                mov     htmp, hpar1
                and     htmp, #$03
                cmp     htmp, #1    wz
        if_z    rdbyte  hpar2, ptra++
        if_z    sub     pa, #1
                cmp     htmp, #2    wz
        if_z    rdword  hpar2, ptra++
        if_z    sub     pa, #2
                cmp     htmp, #3    wz
        if_z    rdlong  hpar2, ptra++
        if_z    sub     pa, #4

                and     hpar1, #$FC
                'debug(uhex_byte(hpar1),uhex_long(hpar2))

                cmp     hpar1, #HID_REPORT_ID   wz
        if_z    jmp     #.report_id
                cmp     hpar1, #HID_USAGE_PAGE  wz
        if_z    jmp     #.usage_page
                cmp     hpar1, #HID_USAGE       wz
        if_z    jmp     #.usage
                cmp     hpar1, #HID_LOGICAL_MIN wz
        if_z    setword hidr_lminmax, hpar2, #1
                cmp     hpar1, #HID_LOGICAL_MAX wz
        if_z    setword hidr_lminmax, hpar2, #0
                cmp     hpar1, #HID_PHYSICAL_MIN wz
        if_z    setword hidr_pminmax, hpar2, #1
                cmp     hpar1, #HID_PHYSICAL_MAX wz
        if_z    setword hidr_pminmax, hpar2, #0
                cmp     hpar1, #HID_REPORT_SIZE wz
        if_z    mov     hidr_size, hpar2
                cmp     hpar1, #HID_REPORT_COUNT wz
        if_z    mov     hidr_count, hpar2
                cmp     hpar1, #HID_INPUT       wz
        if_nz   jmp     #.next

                and     hpar2, #$03
                cmp     hpar2, #HID_ITEM_VARIABLE   wz
        if_nz   jmp     #.skip

                cmp     hidr_state, #2  wz
        if_z    jmp     #.axes
                cmp     hidr_state, #3  wz
        if_z    jmp     #.hats
                cmp     hidr_state, #4  wz
        if_z    jmp     #.buttons
.skip
                mov     htmp, hidr_size
                mul     htmp, hidr_count
                add     hidr_offset, htmp
                jmp     #.next
.axes
                'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count))
                getnib  hr0, hidr_flags, #2
                mov     hr1, hidr_count
.l1
                mov     hpar1, hidr_offset
                mov     hpar2, hidr_size
                call    #hpad_getbits
                call    #hpad_normalize
                cmp     hr0, #6         wcz
        if_b    altgn   hr0, #hidr_usage
        if_b    getnib  hr2
        if_b    altsw   hr2, #hidr_axis
        if_b    setword retval
        if_b    add     hr0, #1
                add     hidr_offset, hidr_size
                djnz    hr1, #.l1

                setnib  hidr_flags, hr0, #2
                mov     hidr_state, #1
                jmp     #.next
.hats
                'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
                mov     hpar1, hidr_offset
                mov     hpar2, hidr_size
                call    #hpad_getbits
                setbyte hidr_hats, retval, #0
                setnib  hidr_flags, #1, #3
                mov     hidr_state, #1
                jmp     #.skip
.buttons
                'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
                mov     hpar1, hidr_offset
                mov     hpar2, hidr_size
                mul     hpar2, hidr_count
                call    #hpad_getbits
                getbyte htmp, hidr_flags, #0
                shl     retval, htmp
                or      hidr_buttons, retval
                add     htmp, hidr_count
                setbyte hidr_flags, htmp, #0
                mov     hidr_state, #1
                jmp     #.skip
.report_id
                cmp     hidr_id, #0     wz
        if_nz   jmp     #hpad_translate
                rdbyte  hidr_id, ptrb++
                cmp     hidr_id, hpar2  wz
        if_nz   ret
                jmp     #.next
.usage_page
                cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
        if_z    cmp     hidr_state, #1  wz
        if_z    mov     hidr_state, #4
                jmp     #.next
.usage
                cmp     hpar2, #HID_USAGE_JOYSTICK  wz
        if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
        if_z    mov     hidr_state, #1
        if_z    jmp     #.next
                cmp     hpar2, #HID_USAGE_X     wz
        if_nz   cmp     hpar2, #HID_USAGE_Y     wz
        if_nz   cmp     hpar2, #HID_USAGE_Z     wz
        if_nz   cmp     hpar2, #HID_USAGE_RX    wz
        if_nz   cmp     hpar2, #HID_USAGE_RY    wz
        if_nz   cmp     hpar2, #HID_USAGE_RZ    wz
        if_z    jmp     #.usage_axis
                cmp     hpar2, #HID_USAGE_HATSWITCH wz
        if_z    cmp     hidr_state, #1      wz
        if_z    mov     hidr_state, #3
                jmp     #.next
.usage_axis
                altsn   hidr_usage_idx, #hidr_usage
                setnib  hpar2

                sub     hpar2, #HID_USAGE_X - 16
                decod   hpar2
                or      hidr_flags, hpar2

                add     hidr_usage_idx, #1
                cmp     hidr_state, #1      wz
        if_z    mov     hidr_state, #2
                jmp     #.next

'------------------------------------------------------------------------------
' Handle XInput controller
' On entry:
'   ptrb - controller report
'------------------------------------------------------------------------------
'   Default implementation translates the report to a pseudo-defacto hid
'   standard and jumps to hpad_translate for actions.
'   Implementors may take specific actions for this kind of controller.
'------------------------------------------------------------------------------
hpad_xinput
                rdbyte  htmp, ptrb      wz
        if_nz   ret                         ' Ignore message type <> $00
                rdbyte  htmp, ptrb[1]
                cmp     htmp, #$14      wz
        if_nz   ret                         ' Ignore report length <> $14 (20)

                rdword  retval, ptrb[3]     ' X = left stick X
                signx   retval, #15
                setword hidr_axis, retval, #0
                bith    hidr_flags, #HID_AXIS_X
                rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
                not     retval
                signx   retval, #15
                setword hidr_axis, retval, #1
                bith    hidr_flags, #HID_AXIS_Y
                rdword  retval, ptrb[5]     ' Z = right stick X
                signx   retval, #15
                setword hidr_axis+1, retval, #0
                bith    hidr_flags, #HID_AXIS_Z
                rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
                not     retval
                signx   retval, #15
                setword hidr_axis+2, retval, #1
                bith    hidr_flags, #HID_AXIS_RZ

                mov     hidr_lminmax, #$0000_00FF
                rdbyte  retval, ptrb[4]     ' left analog trigger
                cmp     retval, #192    wcz
        if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
                call    #hpad_normalize
                setword hidr_axis+1, retval, #1
                bith    hidr_flags, #16+3
                rdbyte  retval, ptrb[5]     ' right analog trigger
                cmp     retval, #192    wcz
        if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
                call    #hpad_normalize
                setword hidr_axis+2, retval, #0
                bith    hidr_flags, #16+4

                rdword  retval, ptrb[1]
                testb   retval, #12     wc  ' A
                bitc    hidr_buttons, #0
                testb   retval, #13     wc  ' B
                bitc    hidr_buttons, #1
                testb   retval, #14     wc  ' X
                bitc    hidr_buttons, #2
                testb   retval, #15     wc  ' Y
                bitc    hidr_buttons, #3
                testb   retval, #8      wc  ' LB
                bitc    hidr_buttons, #4
                testb   retval, #9      wc  ' RB
                bitc    hidr_buttons, #5
                testb   retval, #5      wc  ' SELECT
                bitc    hidr_buttons, #8
                testb   retval, #4      wc  ' START
                bitc    hidr_buttons, #9
                testb   retval, #6      wc  ' L3
                bitc    hidr_buttons, #10
                testb   retval, #7      wc  ' R3
                bitc    hidr_buttons, #11
                testb   retval, #10     wc  ' XBOX
                bitc    hidr_buttons, #12

                setnib  hidr_flags, #1, #3
                setbyte hidr_hats, #$0F, #0
                getnib  htmp, retval, #0    ' map dpad buttons to hat direction
                cmp     htmp, #%0001    wz
        if_z    setbyte hidr_hats, #0, #0
                cmp     htmp, #%1001    wz
        if_z    setbyte hidr_hats, #1, #0
                cmp     htmp, #%1000    wz
        if_z    setbyte hidr_hats, #2, #0
                cmp     htmp, #%1010    wz
        if_z    setbyte hidr_hats, #3, #0
                cmp     htmp, #%0010    wz
        if_z    setbyte hidr_hats, #4, #0
                cmp     htmp, #%0110    wz
        if_z    setbyte hidr_hats, #5, #0
                cmp     htmp, #%0100    wz
        if_z    setbyte hidr_hats, #6, #0
                cmp     htmp, #%0101    wz
        if_z    setbyte hidr_hats, #7, #0

                jmp     #hpad_translate

'------------------------------------------------------------------------------
' Handle PS3 controller
' On entry:
'   ptrb - controller report
'------------------------------------------------------------------------------
'   Default implementation translates the report to a pseudo-defacto hid
'   standard and jumps to hpad_translate for actions.
'   Implementors may take specific actions for this kind of controller.
'------------------------------------------------------------------------------
hpad_ps3
                rdbyte  htmp, ptrb++
                cmp     htmp, #$01      wz
        if_nz   ret                         ' Ignore report ID <> $01

                mov     hidr_lminmax, #$0000_00FF
                rdbyte  retval, ptrb[5]         ' X = left stick X
                call    #hpad_normalize
                setword hidr_axis, retval, #0
                bith    hidr_flags, #HID_AXIS_X
                rdbyte  retval, ptrb[6]         ' Y = left stick Y
                call    #hpad_normalize
                setword hidr_axis, retval, #1
                bith    hidr_flags, #HID_AXIS_Y
                rdbyte  retval, ptrb[7]         ' Z = right stick X
                call    #hpad_normalize
                setword hidr_axis+1, retval, #0
                bith    hidr_flags, #HID_AXIS_Z
                rdbyte  retval, ptrb[8]         ' RZ = right stick Y
                call    #hpad_normalize
                setword hidr_axis+2, retval, #1
                bith    hidr_flags, #HID_AXIS_RZ

                mov     hpar1, #8
                mov     hpar2, #19
                call    #hpad_getbits

                testb   retval, #12     wc  ' A
                bitc    hidr_buttons, #0
                testb   retval, #13     wc  ' B
                bitc    hidr_buttons, #1
                testb   retval, #14     wc  ' X
                bitc    hidr_buttons, #2
                testb   retval, #15     wc  ' Y
                bitc    hidr_buttons, #3
                testb   retval, #10     wc  ' L1
                bitc    hidr_buttons, #4
                testb   retval, #11     wc  ' R1
                bitc    hidr_buttons, #5
                testb   retval, #8      wc  ' L2
                bitc    hidr_buttons, #6
                testb   retval, #9      wc  ' R2
                bitc    hidr_buttons, #7
                testb   retval, #0      wc  ' SELECT
                bitc    hidr_buttons, #8
                testb   retval, #3      wc  ' START
                bitc    hidr_buttons, #9
                testb   retval, #1      wc  ' LEFT STICK
                bitc    hidr_buttons, #10
                testb   retval, #2      wc  ' RIGHT STICK
                bitc    hidr_buttons, #11
                testb   retval, #16     wc  ' HOME
                bitc    hidr_buttons, #12

                setnib  hidr_flags, #1, #3
                setbyte hidr_hats, #$0F, #0
                getnib  htmp, retval, #1    ' map dpad buttons to hat direction
                cmp     htmp, #%0001    wz
        if_z    setbyte hidr_hats, #0, #0
                cmp     htmp, #%0011    wz
        if_z    setbyte hidr_hats, #1, #0
                cmp     htmp, #%0010    wz
        if_z    setbyte hidr_hats, #2, #0
                cmp     htmp, #%0110    wz
        if_z    setbyte hidr_hats, #3, #0
                cmp     htmp, #%0100    wz
        if_z    setbyte hidr_hats, #4, #0
                cmp     htmp, #%1100    wz
        if_z    setbyte hidr_hats, #5, #0
                cmp     htmp, #%1000    wz
        if_z    setbyte hidr_hats, #6, #0
                cmp     htmp, #%1001    wz
        if_z    setbyte hidr_hats, #7, #0

                jmp     #hpad_translate

'------------------------------------------------------------------------------
' Read bits from report data buffer
'------------------------------------------------------------------------------
' On entry:
'   PTRB - report buffer
'   hpar1 - start bit
'   hpar2 - number of bits
' On exit:
'   retval - bits
'------------------------------------------------------------------------------
hpad_getbits
                mov     htmp, hpar1
                shr     htmp, #3        ' byte offset
                add     htmp, ptrb
                rdlong  retval, htmp

                mov     htmp1, hpar1
                and     htmp1, #$07     ' shift
                shr     retval, htmp1

                cmp     hpar2, #24      wcz
        if_a    jmp     #.l1

                decod   hpar2
                sub     hpar2, #1
                and     retval, hpar2
                ret
.l1
                and     retval, ##$00_FFFFFF
                add     htmp, #3
                rdlong  htmp2, htmp
                sub     hpar2, #24
                decod   hpar2
                sub     hpar2, #1
                shr     htmp2, htmp1
                and     htmp2, hpar2
                shl     htmp2, #24
                or      retval, htmp2
                ret

'------------------------------------------------------------------------------
' Normalize value to signed word (-32768 / 32767)
'------------------------------------------------------------------------------
' On entry:
'   retval - value to normalize
'   hidr_lminmax - min (word 1) max (word 0) value range
'   - or -
'   hidr_pminmax - min (word 1) max (word 0) value range
'   hidr_size - value bits length
' On exit:
'   retval - normalized value
'------------------------------------------------------------------------------
hpad_normalize
                mov     htmp, hidr_lminmax  wz
        if_z    mov     htmp, hidr_pminmax  wz
        if_z    ret
                getword htmp1, htmp, #1     ' htmp1 = min
                getword htmp, htmp, #0      ' htmp = max
                signx   htmp1, #15      wc
        if_c    sub     hidr_size, #1
        if_c    signx   retval, hidr_size
        if_c    add     hidr_size, #1
                subs    htmp, htmp1         ' htmp = (max - min)
                subs    retval, htmp1       ' retval = (retval - min)
                shl     retval, #16         ' retval = (retval - min) << 16
                subs    retval, #1          ' retval = ((retval - min) << 16) - 1
                abs     htmp            wc
                testb   retval, #31     wz
                abs     retval
                qdiv    retval, htmp
                getqx   retval
    if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
                adds    retval, ##$8000 signx 15
                ret

'------------------------------------------------------------------------------
' Perform controller actions
' On entry:
'    hidr_id        report id
'    hidr_axis      axis value (signed word, 2 axes per long)
'                      X = hidr_axis+0, #0
'                      Y = hidr_axis+0, #1
'                      Z = hidr_axis+1, #0
'                     RX = hidr_axis+1, #1
'                     RY = hidr_axis+2, #0
'                     RZ = hidr_axis+2, #1
'    hidr_buttons   buttons state (bits 0 to 31)
'    hidr_hats      hats state (byte 0, 1, 2, 3)
'
'                     -------3 -------2 -------1 -------0 byte
'                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
'    hidr_flags       xxxxxxxx_xxrrrzyx_hhhhaaaa_bbbbbbbb
'                                zyx||| |||||||| ++++++++ n. buttons
'                                |||||| ||||++++--------- n. axes
'                                |||||| ++++------------- n. hats
'                                ++++++------------------ valid axes
'------------------------------------------------------------------------------
hpad_translate
                ' TODO
                ret

'------------------------------------------------------------------------------
' Partially populated SETUP packets
'------------------------------------------------------------------------------
get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_DEVICE << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_CONFIG << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_CONFIG
                word    0       ' Configuration value
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_CONFIG has no data stage
set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_ADDR
                word    0       ' Zero
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_ADDR has no data stage
'------------------------------------------------------------------------------
' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
' wValue field dictates which protocol should be used.
'
' When initialized, all devices default to report protocol. However the host
' should not make any assumptions about the device state and should set the
' desired protocol whenever initializing a device.
'------------------------------------------------------------------------------
set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_PROTO
                word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
                                                ' (HID 1.11 Section 7.2.6).
                word    0               ' Interface index number.
                word    0               ' Zero, as HID_SET_PROTO has no data stage.
'------------------------------------------------------------------------------
set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_IDLE
                word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
                                        ' reporting until a change is detected in the report data

                                        ' (HID 1.11 Section 7.2.4).
                word    0       ' Interface index number.
                word    0       ' Zero, as HID_SET_IDLE has no data stage.
set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_REPORT
                word    0       ' Byte1 = report type, byte0 = ReportID.
                                        ' (HID 1.11 Section 7.2.2).
                word    0       ' Interface index number.
                word    0       ' Size of the report, in bytes.
get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
                byte    REQ_GET_DESC
                word    TYPE_REPORT << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
'------------------------------------------------------------------------------
ps3_enable_cmd  byte    $42, $0C, $00, $00
ps3_command_buff
                byte    $00, $00, $00, $00, $00
                byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
                byte    $ff, $27, $10, $00, $32
                byte    $ff, $27, $10, $00, $32
                byte    $ff, $27, $10, $00, $32
                byte    $ff, $27, $10, $00, $32
                byte    $00, $00, $00, $00, $00
                byte    $00, $00, $00, $00, $00
                byte    $00, $00, $00, $00, $00
                byte    $00, $00, $00
'------------------------------------------------------------------------------
xinp_led_cmd    byte    $01, $03, $02   ' 0x00 All off
                                        ' 0x01 All blinking
                                        ' 0x02 1 flashes, then on
                                        ' 0x03 2 flashes, then on
                                        ' 0x04 3 flashes, then on
                                        ' 0x05 4 flashes, then on
                                        ' 0x06 1 on
                                        ' 0x07 2 on
                                        ' 0x08 3 on
                                        ' 0x09 4 on
                                        ' 0x0A Rotating (e.g. 1-2-4-3)
                                        ' 0x0B Blinking*
                                        ' 0x0C Slow blinking*
                                        ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
xinp_rumble_cmd byte    $00, $08, $00
                byte    $00             ' Left rumble
                byte    $00             ' Right rumble
                byte    $00, $00, $00

'------------------------------------------------------------------------------
' The USB data cache area gets zero-filled at every device disconnect
'------------------------------------------------------------------------------
usb_cache_start

' Keyboard report buffers
kb_cur_report   byte    0[KBD_IN_RPT_LEN]
kb_pre_report   byte    0[KBD_IN_RPT_LEN]

' Gamepad descriptor and report buffers
gp_descr        byte    0[HID_DESCR_LEN]
gp_cur_report   byte    0[HID_IN_RPT_LEN]
gp_pre_report   byte    0[HID_IN_RPT_LEN]

usb_cache_end

urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain

CON ' USB Host Shared constants
'------------------------------------------------------------------------------
' Smart pin configuration for "long repository" mode with output enabled,
' regardless of DIR. This allows one pin to provide a long event code via IN
' and also to control the USB port activity LED on/off state vio OUT.
    SP_REPO1_MODE = %01_00001_0 | 1 << 16    ' %TT_MMMMM_0, P[12:10] != %101
'------------------------------------------------------------------------------
' A simple event/cmd system using a smart pin configured in "long repository"
' mode. The USB_EVENT_REPO pin defined above is used to allow the USB cog to
' signal the client that a particular event has occurred. The client must poll
' this smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main"
' loop and process the event IDs you're interested in.
'------------------------------------------------------------------------------
    #0, NO_EVENT, USB_ERROR, DEV_UNKNOWN, KB_READY, M_READY, KBM_READY, GP_READY
    XINPUT_READY, PS3_READY, DEV_DISCONNECT, DBG_DATA, M_DATA, GP_DATA
    CMD_SUSPEND, CMD_RESUME, CMD_RESET
'------------------------------------------------------------------------------
' The CMD_* tokens are asynchronous USB commands available to the user, through
' the Spin2 usbCommand method of this object. This method will post the cmd
' token to the host and when the cmd is complete the host will post the CMD_*
' token to byte[0] of the event long. Byte[1] is typically set to one of the
' below protocol error codes, with bytes[2..3] available for additional cmd data.
'------------------------------------------------------------------------------
' Protocol error codes:
    #0, ERR_NONE, ERR_CMD, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY
    ERR_XFER_RETRY, ERR_NAK, ERR_DATAX_SYNC, ERR_CONFIG_FAIL, ERR_TIMEOUT
'------------------------------------------------------------------------------
' Keyboard modifier key bit positions:
    #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
    RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
' Keyboard modifier bitflags
    LEFT_CTRLF   = decod(LEFT_CTRLB)
    LEFT_SHIFTF  = decod(LEFT_SHIFTB)
    LEFT_ALTF    = decod(LEFT_ALTB)
    LEFT_GUIF    = decod(LEFT_GUIB)
    RIGHT_CTRLF  = decod(RIGHT_CTRLB)
    RIGHT_SHIFTF = decod(RIGHT_SHIFTB)
    RIGHT_ALTF   = decod(RIGHT_ALTB)
    RIGHT_GUIF   = decod(RIGHT_GUIB)
' Consolidated left/right modkeys. Add the modifier keys you want to trap
' together, then add the key scan code e.g. CTRL+ALT+"X" would be: $600 + KEY_X_x.
' The key() Spin2 method does this and the rawKey() method returns the key data
' as packed by the USB keyboard driver.
'   SHIFT = $100
'   CTRL  = $200
'   ALT   = $400
'   APP   = $800
' L|R key modifier flag combinations:
    KEYS_APP   = LEFT_GUIF + RIGHT_GUIF
    KEYS_ALT   = LEFT_ALTF + RIGHT_ALTF
    KEYS_CTRL  = LEFT_CTRLF + RIGHT_CTRLF
    KEYS_SHIFT = LEFT_SHIFTF + RIGHT_SHIFTF

CON ' USB Host constants
'------------------------------------------------------------------------------
    _1thou         = 1_000
    _1m            = 1_000_000
    _1b            = 1_000_000_000
    _12m           = 12_000_000
    LSBTns         = 672.0                  ' Low-Speed bit period, in nanoseconds
    FSBTns         = 83.54                  ' Full-Speed bit period, in nanoseconds
    LSBTns4        = round(LSBTns * 4.0)    ' Low-Speed inter-packet delay, in nanoseconds
    LSBTns22       = round(LSBTns * 22.0)   ' Low-Speed turnaround wait time, in nanoseconds
    FSBTns4        = round(FSBTns * 4.0)    ' Full-Speed inter-packet delay, in nanoseconds
    FSBTns28       = round(FSBTns * 28.0)   ' Full-Speed turnaround wait time, in nanoseconds
' NCO baud calculations for low-speed/full-speed:
'        _1_5Mbps  = round(1_500_000.0 / _FCLKFREQ * 65536.0)  ' = NCO 492 @200MHz, 614 @160
'        _12Mbps   = round(12_000_000.0 / _FCLKFREQ * 65536.0) ' = NCO 3932 @200MHz, 4915 @160
' To configure RevA silicon LS/FS NCO baud: (WXPIN _1_5Mbps, D-) or (WXPIN _12Mbps, D-)
' To configure RevA LS/FS host/device: WRPIN appropriate LS/FS mode to D- (lower) and D+ (upper) pins:
    USB_V1HMODE_LS = %1_11000_0 + 1 << 16   ' Host mode
    USB_V1DMODE_LS = %1_11010_0 + 1 << 16   ' Device mode
    USB_V1HMODE_FS = %1_11001_0 + 1 << 16
    USB_V1DMODE_FS = %1_11011_0 + 1 << 16
' On RevB+ the USB smart pin mode is set to the D- and D+ pins via (WRPIN USBMode, pin#):
    USB_V2_DRVOUT  = %1_11011_0 + 1 << 16
    USB_V2_SNIFF   = %0_11011_0 + 1 << 16   ' Disable output to create a USB "sniffer"
' To configure NCO baud, host/device for LS/FS, set the appropriate mode to the D- pin# (WXPIN NCOMode, D-)
'   USB_H_LS_NCO   = %10 << 14 + _1_5Mbps   ' Host mode at NCO baud
'   USB_D_LS_NCO   = %00 << 14 + _1_5Mbps   ' Device mode at NCO baud
'   USB_H_FS_NCO   = %11 << 14 + _12Mbps
'   USB_D_FS_NCO   = %01 << 14 + _12Mbps
'------------------------------------------------------------------------------
' Time delays and intervals
' Useful USB constants and wait intervals:
    XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
    TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
    NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
    IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
    OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
' Standard Device request maximum timeout periods (reference):
{
    TO_STANDARD  = _1ms * 5000              ' Non-specific maximum timout period
    TO_DATA      = _1ms * 500               ' Standard Device requests with a data stage
    TO_NODATA    = _1ms * 50                ' Standard Device requests without a data stage
    TO_SETADDR   = _1ms * 50                ' Device SetAddress() command processing maximum
    TO_CHGADDR   = _1ms * 2                 ' Device SetAddress() period allowed to change its address before next request sent
}
'------------------------------------------------------------------------------
' Token packet format.
'------------------------------------------------------------------------------
'                   CRC5  ENDP ADDRESS PID
    CRC_MASK     = %11111_0000_0000000_00000000
    EP_MASK      = %00000_1111_0000000_00000000
    ADDR_MASK    = %00000_0000_1111111_00000000
    EP_ADDR_MASK = %00000_1111_1111111_11111111
    EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
'------------------------------------------------------------------------------
' Packet Identifier Bytes (PID). Notice that the first two LSBits are
' identical for each group.
'------------------------------------------------------------------------------
' Token:
    PID_OUT   = %1110_0001                  ' $e1
    PID_IN    = %0110_1001                  ' $69
    PID_SOF   = %1010_0101                  ' $a5
    PID_SETUP = %0010_1101                  ' $2d
' Data:
    PID_DATA0 = %1100_0011                  ' $c3
    PID_DATA1 = %0100_1011                  ' $4b
    PID_DATA2 = %1000_0111                  ' $87
    PID_MDATA = %0000_1111                  ' $0f
' Handshake:
    PID_ACK   = %1101_0010                  ' $d2
    PID_NAK   = %0101_1010                  ' $5a
    PID_STALL = %0001_1110                  ' $1e
    PID_NYET  = %1001_0110                  ' $96
' Special:
    PID_PRE   = %0011_1100                  ' $3c
    PID_ERR   = %0011_1100                  ' $3c
    PID_SPLIT = %0111_1000                  ' $78
    PID_PING  = %1011_0100                  ' $b4
    PID_RESVD = %1111_0000                  ' $f0
' Tx, rx and host related constants
' USB transmitter WYPIN D line state options:
    OUT_IDLE = 0
    OUT_SE0  = 1
    OUT_K    = 2
    OUT_J    = 3
    OUT_EOP  = 4
    OUT_SOP  = $80
' USB receiver RDPIN status bit positions:
    #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
' USB receiver RDPIN status bitflags:
    J_IDLEF    = decod(J_IDLEB)
    K_RESUMEF  = decod(K_RESUMEB)
    SE0_RESETF = decod(SE0_RESETB)
    SE1_BADF   = decod(SE1_BADB)
    SOPF       = decod(SOPB)
    EOPF       = decod(EOPB)
    BUS_ERRF   = decod(BUS_ERRB)
    BYTE_TGLF  = decod(BYTE_TGLB)
' USB CRC constants:
    USB5_POLY      = %0_0101 rev (5 - 1)    ' USB5 polynomial is reflected when calculating CRC
    USB5_RESIDUAL  = %0_1100 rev (5 - 1)    ' Expected CRC5 residual value when checking received data
    USB16_POLY     = $8005 rev (16 - 1)     ' USB16 polynomial is reflected when calculating CRC
    USB16_RESIDUAL = $800d rev (16 - 1)     ' Expected CRC16 residual value when checking received data
' Host->class driver USB connect speed:
    #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
    #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB[4], DWNSTRM_HUBB, SUSPENDB
' Host status bitflags. Unless otherwise noted, bit states are active high:
    IDLEF        = decod(IDLEB)             ' Set when USB in idle state
    CONNECTEDF   = decod(CONNECTEDB)        ' USB device connected
    LOW_SPEEDF   = decod(LOW_SPEEDB)        ' Low-speed device connected, clear if full-speed
    DATAx_TGLF   = decod(DATAx_TGLB)        ' Cleared if sending DATA0 packet, set if sending DATA1 packet
'   EOPF         = decod(EOPB)              ' Same bit position as the USB rx RDPIN status constants defined above
'   BUS_ERRF     = decod(BUS_ERRB)          ' Same bit position as the USB rx RDPIN status constants defined above
'   BYTE_TGLF    = decod(BYTE_TGLB)         ' Same bit position as the USB rx RDPIN status constants defined above
    DWNSTRM_HUBF = decod(DWNSTRM_HUBB)      ' NYI: downstream hub(s) connected
    SUSPENDF     = decod(SUSPENDB)          ' NYI: command the host to signal a global suspend
'------------------------------------------------------------------------------
' P2 silicon revision detection:
'------------------------------------------------------------------------------
    #1, P2RevA, P2RevB
'------------------------------------------------------------------------------

CON ' USB Descriptor Definitions
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
'------------------------------------------------------------------------------
' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
' Use TYPE_STANDARD for all USB Standard Device Request codes.
'------------------------------------------------------------------------------
' D7 Data direction  | D6:5 Type    | D4:0 Recipient
'------------------------------------------------------------------------------
' 0 - Host-to-device | 0 = Standard | 0 = Device
' 1 - Device-to-host | 1 = Class    | 1 = Interface
'                    | 2 = Vendor   | 2 = Endpoint
'                    | 3 = Reserved | 3 = Other
'                    |              | 4 -31 = Reserved
'------------------------------------------------------------------------------
    DIR_HOST_TO_DEV = 0 << 7
    DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
    TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
    TYPE_CLASS      = %01 << 5
    TYPE_VENDOR     = %10 << 5
    TYPE_RESERVED   = %11 << 5
    RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
    RECIP_INTERFACE = %0_0001
    RECIP_ENDPOINT  = %0_0010
    RECIP_OTHER     = %0_0011
'    RECIP 4 - 31 = Reserved
'------------------------------------------------------------------------------
' Standard Device Request codes (Section 9.4, Table 9-4):
'------------------------------------------------------------------------------
    #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
    REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
    REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
'------------------------------------------------------------------------------
' Standard descriptor types (Section 9.4, Table 9-5):
'------------------------------------------------------------------------------
    #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
    TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
'------------------------------------------------------------------------------
' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
'------------------------------------------------------------------------------
    #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
    CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
    CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
    CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
    CLASS_DIAGNOSTIC_DEV  = $dc
    CLASS_WIRELESS_CTRL   = $e0
    CLASS_MISCELLANEOUS   = $ef
    CLASS_APP_SPECIFIC    = $fe
    CLASS_VENDOR_SPECIFIC = $ff
'------------------------------------------------------------------------------
' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
'------------------------------------------------------------------------------
    #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
    HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
' HID Descriptor types:
    #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
'------------------------------------------------------------------------------
' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
'------------------------------------------------------------------------------
    #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
'------------------------------------------------------------------------------
' HID Interface SubClasses:
'------------------------------------------------------------------------------
    #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
'------------------------------------------------------------------------------
' HID Protocol codes:
'------------------------------------------------------------------------------
    #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
    #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
'------------------------------------------------------------------------------
' Other HID buffer lengths:
'------------------------------------------------------------------------------
    MAX_HID_REPTS   = 4             ' We have this many HID report buffers
    REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
    REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
    LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
    USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
'------------------------------------------------------------------------------
' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
'------------------------------------------------------------------------------
    LANG_ENG_US  = $0409            ' English (United States)
    LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
'------------------------------------------------------------------------------
' SETUP structure member offsets.
' NOTE: These offsets are defined in terms of the structure member's data type,
'       to take advantage of PTRA/B scaled indexing, e.g.:
'         RDBYTE D,   PTRA[bRequest]
'         WRWORD D/#, PTRA[wLength]
'------------------------------------------------------------------------------
    bmRequestType = 0
    bRequest      = 1
    wValue        = 1
    wIndex        = 2
    wLength       = 3
' SETUP bmRequestType combinations:
{
    HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
    DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
    HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
    HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
}
'------------------------------------------------------------------------------
' Standard USB descriptor structure sizes in bytes. The values defined are the
' minimum size of the descriptor:
'------------------------------------------------------------------------------
    SETUP_TXN_LEN = 8
    DEV_DESC_LEN  = 18
    CON_DESC_LEN  = 9
    INTF_DESC_LEN = 9
    ENDP_DESC_LEN = 7
    STR0_DESC_LEN = 4
    USTR_DESC_LEN = 4
'------------------------------------------------------------------------------
' Other USB-related buffer sizes:
'------------------------------------------------------------------------------
    URX_BUFF_LEN = 128      ' USB receiver scratch buffer
    CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
'------------------------------------------------------------------------------
' CON_bmAttrs member bit positions:
'------------------------------------------------------------------------------
    ATTR_RESVB     = 7      ' Reserved (should always be one)
    ATTR_SELF_PWRB = 6      ' Device Self-Powered
    ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
'    bmAttributes bits 4..0 reserved and reset to zero
'------------------------------------------------------------------------------
' Standard USB descriptor struct member offset and member size, in bytes. Note
' that the DESC_bLength and DESC_bDescType members are defined in all of the
' descriptors (including HID) at the offsets shown.
'------------------+
' !!! IMPORTANT !!!|
'------------------+
' All standard descriptor member offsets are defined in bytes, so if you want
' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
'       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
' If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
' must be very careful...
'------------------------------------------------------------------------------
'       Member          Offset  Size    Value           Description
'------------------------------------------------------------------------------
    DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
    DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
' Device Descriptor (Section 9.6.1, Table 9-8):
    DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
    DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
    DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
    DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
    DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
    DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
    DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
    DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
    DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
    DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
    DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
    DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
  ' Configuration Descriptor (Section 9.6.3, Table 9-10):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
    CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
    CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
    CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
    CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
    CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
    CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
' Interface Descriptor (Section 9.6.5, Table 9-12):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
    INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
    INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
    INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
    INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
    INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
                            '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
                            '                       reserved for assignment by the USB-IF.
    INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
                            '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
                            '                       vendor-specific protocol for this interface.
    INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
' Endpoint Descriptor (Section 9.6.6, Table 9-13):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
    ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
    ENDP_bmAttrs     = 3    ' 1     Bitmap
    ENDP_wMaxPktSize = 4    ' 2     Number
    ENDP_bInterval   = 6    ' 1     Number
' String Descriptor Zero (Section 9.6.7, Table 9-15):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
' Unicode String Descriptor (Section 9.6.7, Table 9-16):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    USTR_wString     = 2    ' N     wString[(N - 2) / 2]
'------------------------------------------------------------------------------
' HID Descriptor (Section 6.2.1)
'------------------------------------------------------------------------------
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
    HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
    HID_bCountryCode = 4    ' 1     Number          Hardware target country
    HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
    HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
    HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).

' HID Report Items from HID 1.11 Section 6.2.2
    HID_USAGE_PAGE      = $04
    HID_USAGE           = $08
    HID_COLLECTION      = $A0
    HID_END_COLLECTION  = $C0
    HID_REPORT_COUNT    = $94
    HID_REPORT_SIZE     = $74
    HID_USAGE_MIN       = $18
    HID_USAGE_MAX       = $28
    HID_LOGICAL_MIN     = $14
    HID_LOGICAL_MAX     = $24
    HID_PHYSICAL_MIN    = $34
    HID_PHYSICAL_MAX    = $44
    HID_INPUT           = $80
    HID_REPORT_ID       = $84
    HID_OUTPUT          = $90

' HID Report Usage Pages from HID Usage Tables 1.12 Section 3, Table 1
    HID_USAGE_PAGE_GENERIC_DESKTOP = $01
    HID_USAGE_PAGE_KEY_CODES       = $07
    HID_USAGE_PAGE_LEDS            = $08
    HID_USAGE_PAGE_BUTTONS         = $09

' HID Report Usages from HID Usage Tables 1.12 Section 4, Table 6
    HID_USAGE_POINTER   = $01
    HID_USAGE_MOUSE     = $02
    HID_USAGE_JOYSTICK  = $04
    HID_USAGE_GAMEPAD   = $05
    HID_USAGE_KEYBOARD  = $06
    HID_USAGE_X         = $30
    HID_USAGE_Y         = $31
    HID_USAGE_Z         = $32
    HID_USAGE_RX        = $33
    HID_USAGE_RY        = $34
    HID_USAGE_RZ        = $35
    HID_USAGE_SLIDER    = $36
    HID_USAGE_WHEEL     = $38
    HID_USAGE_HATSWITCH = $39

' HID Report Collection Types from HID 1.12 6.2.2.6
    HID_COLLECTION_PHYSICAL    = 0
    HID_COLLECTION_APPLICATION = 1

' HID Input/Output/Feature Item Data (attributes) from HID 1.11 6.2.2.5
    HID_ITEM_CONSTANT = $1
    HID_ITEM_VARIABLE = $2
    HID_ITEM_RELATIVE = $4

' Keyboard report data buffer lengths (boot protocol):
    KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
    KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size
' Gamepad report and descriptor data buffer lengths:
    HID_IN_RPT_LEN   = 256
    HID_DESCR_LEN    = 256

' Gamepad axes flag bits
    HID_AXIS_X   = 16+0
    HID_AXIS_Y   = 16+1
    HID_AXIS_Z   = 16+2
    HID_AXIS_RX  = 16+3
    HID_AXIS_RY  = 16+4
    HID_AXIS_RZ  = 16+5

DAT             ' ZiKore Z80 COG resident code
                org     $000

zk_cogbase
                add     ptrb, ##@zk_lutbase - @zk_cogbase
                setq2   #511
                rdlong  0, ptrb

                getct   zk_lastwait

zk_nextop
                lockrel #0                      ' Release lock

                mul     zk_cycles, zk_cycletime
                addct1  zk_lastwait, zk_cycles
                waitct1

                locktry #0              wc      ' Acquire lock for instruction processing
    if_nc       jmp     #$-1

                mov     zk_cycles, #1

                testb   zk_ctl, #8          wc  ' C = old NMI
                rdlong  zk_ctl, #@tms_status
                testb   zk_ctl, #8          wz  ' Z = current NMI
        if_01   jmp     #\zk_donmi              ' jump if 0 -> 1 transition

                mov     zk_temphl, zk_hl
                mov     zk_hlptr, #zk_hl
                mov     zk_tempidx, zk_hl
                mov     zk_prefix, #0
                incmod  zk_refresh, #127

                call    #zk_readcode
                mov     zk_opcode, zk_tmp8
                'debug(uhex_byte(zk_opcode))
                rdlut   zk_opimpl, zk_opcode
                'debug(uhex_long(zk_opimpl))
                bitl    zk_opimpl, #10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
                push    #zk_nextop
                execf   zk_opimpl

zk_iyprefix
                mov     zk_hlptr, #zk_iy
zk_ixprefix
                mov     zk_hlptr, #zk_ix

                mov     zk_prefix, zk_opcode
                incmod  zk_refresh, #127
                add     zk_cycles, #1


                call    #zk_readcode
                mov     zk_opcode, zk_tmp8
                rdlut   zk_opimpl, zk_opcode
                bitl    zk_opimpl, #10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
        if_nc   jmp     #.nodisplace
                ' handle index displacement
                mov     zk_temphl, zk_hl
                alts    zk_hlptr
                mov     zk_tempidx, 0-0
                mov     zk_hlptr, #zk_hl
                call    #zk_readcode
                signx   zk_tmp8, #7
                add     zk_tempidx, zk_tmp8
                execf   zk_opimpl

.nodisplace
                alts    zk_hlptr
                mov     zk_temphl, 0-0
                mov     zk_tempidx, zk_temphl
                execf   zk_opimpl

zk_bitprefix
                call    #\zk_readcode
                mov     zk_opcode, zk_tmp8
                add     zk_cycles, #1
                incmod  zk_refresh, #127

                cmp     zk_prefix, #0 wz
        if_z    call    #zk_getrz
        if_nz   call    #zk_read8hl

                mov     pa, zk_opcode
                shr     pa, #3
                and     pa, #7

                testb   zk_opcode, #7 wc
                testb   zk_opcode, #6 wz
        if_00   jmp     #.shift
        if_01   jmp     #.bit
                bitz    zk_tmp8, pa
                ' write result (slightly complex)
                mov     pa, zk_opcode
                and     pa, #7
                cmp     pa, #6 wz
        if_nz   cmp     zk_prefix, #0 wz
        if_nz   push    #zk_write8hl
                jmp     #\zk_setrz

.bit
                decod   pa
                and     pa, zk_tmp8 wz
                muxz    zk_flags, #(1<<ZK_ZERO_BIT)|(1<<ZK_OVER_BIT)
                bitl    zk_flags, #ZK_NMODE_BIT
                bith    zk_flags, #ZK_HALF_BIT
                setq    #1<<ZK_SIGN_BIT
                muxq    zk_flags, pa
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags, zk_tmp8

.shift
                push    #.shiftdone
                altd    pa, #zk_shift_impl_tbl
                execf   0-0

.shiftdone
                ' write result (slightly complex)
                mov     pa, zk_opcode
                and     pa, #7
                cmp     pa, #6 wz
        if_nz   cmp     zk_prefix,#0 wz
        if_nz   push    #zk_write8hl
                jmp     #\zk_setrz

zk_shift_impl_tbl
                long    zk_shiftop + (%1_001_110_01_11110_0<<10) ' RLC
                long    zk_shiftop + (%1_001_001_01_11011_0<<10) ' RRC
                long    zk_shiftop + (%1_001_110_00_11110_0<<10) ' RL
                long    zk_shiftop + (%1_001_001_00_11011_0<<10) ' RR
                long    zk_shiftop + (%1_001_110_01_01110_0<<10) ' SLA
                long    zk_shiftop + (%1_001_011_01_11000_0<<10) ' SRA
                long    zk_shiftop + (%1_001_110_01_10110_0<<10) ' SLL
                long    zk_shiftop + (%1_001_011_01_11011_0<<10) ' SRL

zk_extprefix
                call #\zk_readcode
                mov zk_opcode,zk_tmp8
                add zk_cycles,#1
                incmod zk_refresh,#127
                'debug("extend ",uhex_byte(zk_opcode))

                cmp zk_opcode,#$A0 wc
        if_ae   jmp #.blockop
                cmp zk_opcode,#$40 wc
        if_b    ret

                mov pa,zk_opcode
                and pa,#7
                altd pa,#zk_ext_impl_tbl
                execf 0-0

.blockop
                '' The undocumented flags on these are cursed.
                test    zk_opcode,#%0100_0100 wz
        if_nz   ret     ' NOP
                rczr    zk_opcode wcz ' get operation type into cz
        if_00   add     zk_cycles,#2
        if_01   add     zk_cycles,#5
        if_1x   add     zk_cycles,#1
        if_00   skipf   ##%00000000_11111_11111_01_1111110_1110_011_111111 ' LD
        if_01   skipf   ##%00000011_01010_00000_10_0011110_1101_011_1111   ' CP
        if_10   skipf   ##%00001111_10101_11101_01_1100011_0011_100_11     ' IN
        if_11   skipf   ##%00111111_10101_11101_01_1111101_0011_011        ' OUT

                getbyte zk_ea,zk_debc,#0 ' IN
                call    #\zk_portin ' IN
                call    #\zk_read8hl ' everything else

                andn    zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT) ' LD
                bith    zk_flags,#ZK_NMODE_BIT ' CP
                testb   zk_tmp8,#7 wc ' IN/OUT
                bitc    zk_flags,#ZK_NMODE_BIT ' IN/OUT

                mov     zk_optmp0,zk_accu ' LD CP
                getbyte zk_optmp0,zk_hl,#0 ' OUT
                getbyte zk_optmp0,zk_debc,#0 ' IN
                testb   zk_opcode,#1 wc ' IN
                sumc    zk_optmp0,#1 ' IN
                mov     zk_optmp1,zk_tmp8 ' CP
                xor     zk_optmp1,zk_optmp0 ' CP

                sub     zk_optmp0,zk_tmp8 ' CP only
                add     zk_optmp0,zk_tmp8 ' LD,IN,OUT

                xor     zk_optmp1,zk_optmp0 ' CP
                and     zk_optmp0,#255 wz ' CP,IN,OUT
                bitz    zk_flags,#ZK_ZERO_BIT ' CP
                testb   zk_optmp0,#7 wc ' CP
                bitc    zk_flags,#ZK_SIGN_BIT ' CP

                testb   zk_optmp1,#4 wc   ' CP
                cmpr    zk_optmp0,#255 wc  ' IN/OUT
                bitc    zk_flags,#ZK_HALF_BIT ' CP
                muxc    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_CARRY_BIT) ' IN/OUT
        if_c    sub     zk_optmp0,#1  ' CP (subtract HF again for XY flag purposes)

                skipf   ##%000_00_000_01_11100100_11001_1111_0000_111111 ' LD
                skipf   ##%000_00_111_00_11100100_11111_1111_0000_1111 ' CP
                skipf   ##%000_00_111_01_00011001_11010_0000_1111_11   ' IN
                skipf   ##%000_00_111_01_00011001_00111_0000_1111      ' OUT


                testb   zk_optmp0,#1 wc ' LD,CP
                bitc    zk_flags,#5 'LD,CP (sets YF)
                testb   zk_optmp0,#3 wc ' LD,CP
                bitc    zk_flags,#3 'LD,CP (sets XF)

                getbyte zk_optmp1,zk_debc,#1 ' IN,OUT (get B)
                and     zk_optmp0,#7 ' IN,OUT
                xor     zk_optmp0,zk_optmp1 wc ' IN,OUT
                bitnc   zk_flags,#ZK_OVER_BIT ' IN,OUT

                mov     zk_ea,zk_hl  ' IN
                getword zk_ea,zk_debc,#1 ' LD
                call    #\zk_write8 ' LD,IN
                getbyte zk_ea,zk_debc,#0 ' OUT
                call    #\zk_portout ' OUT

                getword zk_optmp1,zk_debc,#0 ' LD,CP
                decmod  zk_optmp1,zk_ffffh wz ' all
                setbyte zk_debc,zk_optmp1,#1 ' IN/OUT
                setword zk_debc,zk_optmp1,#0 ' LD,CP
                bitnz   zk_flags,#ZK_OVER_BIT ' LD,CP
                bitz    zk_flags,#ZK_ZERO_BIT ' IN,OUT
                setq    #ZK_SIGNXYMASK ' IN,OUT
                muxq    zk_flags,zk_optmp1 ' IN,OUT

                testb   zk_flags,#ZK_ZERO_BIT orz ' CP (A==(HL) can also trigger CPxR break)
                testb   zk_opcode,#1 wc ' Get direction (C = dec)

        if_nc   incmod  zk_ea,zk_ffffh    ' LD
        if_c    decmod  zk_ea,zk_ffffh    ' LD
                setword zk_debc,zk_ea,#1 ' LD

        if_nc   incmod  zk_hl,zk_ffffh
        if_c    decmod  zk_hl,zk_ffffh

                testb   zk_opcode,#2 wc ' Is repeat code?
 if_c_and_nz    sub     zk_pc,#2
 if_c_and_nz    add     zk_cycles,#5
                'debug(uhex_byte(zk_tmp8),uhex_long(zk_debc),ubin_byte(zk_flags))
                ret

zk_ext_impl_tbl
                long    zk_cio + (%10_11_11_000000<<10) ' IN [BCDEHL0A],(C)
                long    zk_cio + (%00_01_11_000000<<10) ' OUT (C),[BCDEHL0A]
                long    zk_ext_differentiate + (%0_110_000<<10) ' ADC/SBC with HL
                long    zk_ext_differentiate + (%0_101_000<<10) ' 16 bit LD from to (imm16)
                long    zk_neg
                long    zk_irqret
                long    zk_imode
                long    zk_ext_differentiate + (%0_011_000<<10) ' miscellany

zk_ext_differentiate
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7

                altd    pa,#zk_extmath16_impl_tbl
                altd    pa,#zk_extld16_impl_tbl
                altd    pa,#zk_extmisc_impl_tbl

                execf   0-0

zk_extmath16_impl_tbl
                long    zk_cmath16 + (%0100_000_00_0011_00_1110_0<<10) ' SBC HL,BC
                long    zk_cmath16 + (%0100_000_00_1100_00_1110_0<<10) ' ADC HL,BC
                long    zk_cmath16 + (%0100_000_00_0011_00_1101_0<<10) ' SBC HL,DE
                long    zk_cmath16 + (%0100_000_00_1100_00_1101_0<<10) ' ADC HL,DE
                long    zk_cmath16 + (%0100_000_00_0011_00_1011_0<<10) ' SBC HL,HL
                long    zk_cmath16 + (%0100_000_00_1100_00_1011_0<<10) ' ADC HL,HL
                long    zk_cmath16 + (%0100_000_00_0011_00_0111_0<<10) ' SBC HL,SP
                long    zk_cmath16 + (%0100_000_00_1100_00_0111_0<<10) ' ADC HL,SP

zk_extld16_impl_tbl
                long    zk_ld_abs16 + (%01110_00<<10) ' LD (imm16),BC
                long    zk_ld_abs16 + (%00_11111_00<<10) ' LD BC,(imm16)
                long    zk_ld_abs16 + (%01101_00<<10) ' LD (imm16),DE
                long    zk_ld_abs16 + (%010_11111_00<<10) ' LD DE,(imm16)
                long    zk_ld_abs16 + (%01011_00<<10) ' LD (imm16),HL
                long    zk_ld_abs16 + (%00110_11111_00<<10) ' LD HL,(imm16)
                long    zk_ld_abs16 + (%00111_00<<10) ' LD (imm16),SP
                long    zk_ld_abs16 + (%01110_11111_00<<10) ' LD SP,(imm16)

zk_extmisc_impl_tbl
                long    zk_a2i                       ' LD I,A
                long    zk_a2r                       ' LD R,A
                long    zk_i2a                       ' LD A,I
                long    zk_r2a  + (%1_000<<10)       ' LD A,R
                long    zk_rxd + (%000_111_00<<10)   ' RRD
                long    zk_rxd + (%111_000_00<<10)   ' RLD
                long    zk_nextop                    ' NOP
                long    zk_nextop                    ' NOP

zk_rxd
                call    #\zk_read8hl
                add     zk_cycles,#4
                ' RLD
                rolnib  zk_tmp8,zk_accu,#0
                getnib  pa,zk_tmp8,#2
                setnib  zk_tmp8,#0,#2
                ' RRD
                setnib  zk_tmp8,zk_accu,#2
                getnib  pa,zk_tmp8,#0
                shr     zk_tmp8,#4

                setnib  zk_accu,pa,#0
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                and     zk_accu,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_accu
                jmp     #\zk_write8hl

zk_a2r
                mov     zk_refresh,zk_accu
                and     zk_refresh,#$7F
        _ret_   mov     zk_refreshhi,zk_accu

zk_a2i
        _ret_   mov     zk_ivector,zk_accu

zk_r2a
                mov     zk_accu,zk_refresh
                setq    #$80
                muxq    zk_accu,zk_refreshhi
zk_i2a
                mov     zk_accu,zk_ivector

                and     zk_accu,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_irqenable,#ZK_IFF2_BIT wc
                bitc    zk_flags,#ZK_OVER_BIT
                andn    zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_irqret       '' RETI/RETN
                '' These are literally the same
                testb   zk_irqenable,#ZK_IFF2_BIT wc
                bitc    zk_irqenable,#ZK_IFF1_BIT
                call    #\zk_pop16
        _ret_   mov     zk_pc,zk_tmp16


zk_imode        ' Don't care, always assume IM1
                ret

zk_irqoff
        _ret_   andn    zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)

zk_irqon
        _ret_   or      zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)

zk_donmi
                add     zk_cycles,#5
                test    zk_irqenable,#(1<<ZK_HALT_BIT)  wz
        if_nz   incmod  zk_pc,zk_ffffh
                andn    zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_HALT_BIT)
                mov     zk_tmp16,zk_pc
                call    #\zk_push16

                mov     zk_pc,#$66 ' NMI

                jmp     #\zk_nextop

zk_jump_indir
        _ret_   mov     zk_pc,zk_temphl
zk_hl_to_sp
                add     zk_cycles,#2
        _ret_   mov     zk_sp,zk_temphl

zk_jump
                call    #\zk_readcode16
zk_condret
                add     zk_cycles,#1 ' Extra cycle in conditional RET

                testb   zk_flags,#ZK_ZERO_BIT wc
                testb   zk_flags,#ZK_CARRY_BIT wc
                testb   zk_flags,#ZK_OVER_BIT wc
                testb   zk_flags,#ZK_SIGN_BIT wc

                modc    _nc wc
        if_c    call    #\zk_nextop
zk_ret
                call    #zk_pop16
                mov     zk_optmp0,zk_tmp16 ' For every op!
zk_rst
                mov     zk_optmp0,zk_opcode
                and     zk_optmp0,#%00111000
zk_pushjmp
                mov     zk_tmp16,zk_pc
                mov     zk_pc,zk_optmp0
                jmp     #\zk_push16
                ret

zk_getrz        ' Get value as indicated by opcode Z field
                mov     pa,zk_opcode
                and     pa,#7
                'debug("in zk_getrz ",uhex_byte(pa))
                add     pa,#zk_getrpa-$-1
                jmprel  pa
zk_getry        ' Get value as indicated by opcode Y field
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7
zk_getrpa
                jmprel  pa
        _ret_   getbyte zk_tmp8,zk_debc,#1   ' B register
        _ret_   getbyte zk_tmp8,zk_debc,#0   ' C register
        _ret_   getbyte zk_tmp8,zk_debc,#3   ' D register
        _ret_   getbyte zk_tmp8,zk_debc,#2   ' E register
        _ret_   getbyte zk_tmp8,zk_temphl,#1 ' H register
        _ret_   getbyte zk_tmp8,zk_temphl,#0 ' L register
                jmp     #zk_read8hl              ' (HL)
        _ret_   getbyte zk_tmp8,zk_accu,#0   ' A register

zk_setrz        ' Get value as indicated by opcode Z field
                mov     pa,zk_opcode
                and     pa,#7
                add     pa,#zk_setrpa-$-1
                jmprel  pa
zk_setry        ' Get value as indicated by opcode Y field
                mov     pa,zk_opcode
                shr     pa,#3
                and     pa,#7
                'debug("in zk_setry ",uhex_byte(pa,zk_tmp8))
zk_setrpa       jmprel  pa
        _ret_   setbyte zk_debc,zk_tmp8,#1   ' B register
        _ret_   setbyte zk_debc,zk_tmp8,#0   ' C register
        _ret_   setbyte zk_debc,zk_tmp8,#3   ' D register
        _ret_   setbyte zk_debc,zk_tmp8,#2   ' E register
                jmp     #.seth                   ' H register
                jmp     #.setl                   ' L register
                jmp     #zk_write8hl             ' (HL)
        _ret_   setbyte zk_accu,zk_tmp8,#0   ' A register

.seth
                setbyte zk_temphl,zk_tmp8,#1
                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl
.setl
                setbyte zk_temphl,zk_tmp8,#0
                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl

zk_push16
                add     zk_cycles,#1
                sub     zk_sp,#2
                setword zk_sp,#0,#1
                mov     zk_ea,zk_sp
                jmp     #zk_write16
zk_pop16
                mov     zk_ea,zk_sp
                add     zk_sp,#2
                setword zk_sp,#0,#1
                jmp     #zk_read16

zk_read16hl
                getword zk_ea,zk_tempidx,#0
zk_read16
                call    #zk_read8
                getbyte zk_tmp16,zk_tmp8,#0
                add     zk_ea,#1
                call    #zk_read8
                setbyte zk_tmp16,zk_tmp8,#1
        _ret_   sub     zk_ea,#1

zk_read8hl
                getword zk_ea,zk_tempidx,#0
                jmp     #zk_read8
zk_readcode
                mov     zk_ea,zk_pc
                incmod  zk_pc,zk_ffffh
                'setword zk_pc,#0,#1
                ' fall through
zk_read8
                add     zk_cycles,#3
                getword pa, zk_ea, #0
                cmp     pa, ram_base    wcz
         if_ae  cmp     ram_top, pa     wcz
         if_ae  and     pa, ram_mask
                add     pa, zk_ram
                rdbyte  zk_tmp8, pa
                ret     wcz

zk_readcode16
                call    #zk_readcode
                getbyte zk_tmp16,zk_tmp8,#0
                call    #zk_readcode
        _ret_   setbyte zk_tmp16,zk_tmp8,#1

zk_write16hl
                getword zk_ea,zk_tempidx,#0
zk_write16
                getbyte zk_tmp8,zk_tmp16,#0
                call    #zk_write8
                add     zk_ea,#1
                getbyte zk_tmp8,zk_tmp16,#1
                call    #zk_write8
        _ret_   sub     zk_ea,#1

zk_write8hl
                getword zk_ea,zk_tempidx,#0
zk_write8
                add     zk_cycles, #3
                getword pa, zk_ea, #0
                cmp     pa, ram_base    wcz
         if_ae  cmp     ram_top, pa     wcz
         if_ae  and     pa, ram_mask
         if_ae  add     pa, zk_ram
         if_ae  wrbyte  zk_tmp8, pa
                ret     wcz

ram_base        long    $6000
ram_top         long    $7FFF
ram_mask        long    %1110_0011_1111_1111

zk_portout
                ' zk_ea   = port
                ' zk_tmp8 = data
                add     zk_cycles, #4
                testb   zk_ea, #7       wc
        if_0x   ret     wcz                     ' 00-7F = nothing
                testb   zk_ea, #6       wc
                testb   zk_ea, #5       wz
        if_00   bitl    io_flags, #1            ' 80-9F = set keypad mode
        if_01   jmp     #\tms_wr                ' A0-BF = video
        if_10   bith    io_flags, #1            ' C0-DF = set joystick mode
        if_11   jmp     #\psg_wr                ' E0-FF = psg
                ret     wcz

zk_portin
                ' zk_ea   = port
                ' zk_tmp8 = data
                add     zk_cycles, #4
                mov     zk_tmp8, #$FF
                testb   zk_ea, #7       wc
        if_0x   ret     wcz                     ' 00-7F = nothing
                testb   zk_ea, #6       wc
                testb   zk_ea, #5       wz
        {if_00   ret     wcz}                   ' 80-9F = nothing
        if_01   jmp     #\tms_rd                ' A0-BF = video
        {if_10   ret     wcz}                   ' C0-DF = nothing
        if_11   jmp     #\ctrl_rd               ' E0-FF = controller read
                ret     wcz

io_flags        long    0                   ' bit 0 = tms reg/data
                                            '     1 = joystick/pad mode

tms_ramptr      long    0
tms_tmp0        long    0
tms_tmp1        long    0

psg_data        long    0
psg_latch       long    0

zk_ffffh        long    $FFFF
zk_18000h       long    $18000
zk_bit31        long    negx

zk_cycles       long    5
zk_pc           long    $0000

zk_flags        long    0
zk_accu         long    0
zk_debc         long    0
zk_sp           long    $F000
zk_hl           long    0
zk_ix           long    0
zk_iy           long    0
zk_altflags     long    0
zk_altaccu      long    0
zk_altdebc      long    0
zk_althl        long    0
zk_refresh      long    0
zk_refreshhi    long    0
zk_ivector      long    0
zk_irqenable    long    0

zk_ram          long    @z80_ram

zk_cycletime    long    round(float(_CLKFREQ) / float(ZK_CLOCK))
zk_lastwait     res     1

zk_opcode       res     1
zk_opimpl       res     1
zk_prefix       res     1
zk_temphl       res     1
zk_tempidx      res     1
zk_hlptr        res     1
zk_tmp16        res     1

zk_optmp0       res     1
zk_optmp1       res     1

zk_memtmp0      res     1
'zk_memtmp1      res     1
'zk_memtmp2      res     1
'zk_memtmp3      res     1
zk_tmp8         res     1 ' memory read/write value
zk_ea           res     1 ' remapped EA
zk_ctl          res     1

                fit     $1F0

DAT             ' ZiKore Z80 LUT resident code
                org     $200

zk_lutbase      '' Opcode table
                long    zk_nextop                                           ' $00: NOP
                long    zk_loadimm16 + (%0000_1_111_0<<10)                  ' $01: LD BC,imm16
                long    zk_a_and_ptr + (%001110<<10)                        ' $02: LD (BC),A
                long    zk_incdec16+(%0000_1_1111_10_1_11100<<10)           ' $03: INC BC
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $04: INC B
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $05: DEC B
                long    zk_loadimm8                                         ' $06: LD B,imm8
                long    zk_rolla+(%0_010_110_01_11110_00<<10)               ' $07: RLCA
                long    zk_ex_af                                            ' $08: EX AF,AF'
                long    zk_math16+(%0010_111_00_1100_00_1110_1_0<<10)       ' $09: ADD HL,BC
                long    zk_a_and_ptr + (%000010<<10)                        ' $0A: LD A,(BC)
                long    zk_incdec16+(%0000_1_1111_01_1_11100<<10)           ' $0B: DEC BC
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $0C: INC C
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $0D: DEC C
                long    zk_loadimm8                                         ' $0E: LD C,imm8
                long    zk_rolla+(%0_010_001_01_11011_00<<10)               ' $0F: RRCA
                long    zk_jr + (%01_11_0000_0<<10)                         ' $10: DJNZ
                long    zk_loadimm16 + (%0001_1_111_0<<10)                  ' $11: LD DE,imm16
                long    zk_a_and_ptr + (%00110 <<10)+1                      ' $12: LD (DE),A
                long    zk_incdec16+(%0001_1_1111_10_1_11010<<10)           ' $13: INC DE
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $14: INC D
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $15: DEC D
                long    zk_loadimm8                                         ' $16: LD D,imm8
                long    zk_rolla+(%0_010_110_00_11110_00<<10)               ' $17: RLA
                long    zk_jr + (%11_11_1111_0<<10)                         ' $18: JR
                long    zk_math16+(%0010_111_00_1100_00_1101_1_0<<10)       ' $19: ADD HL,DE
                long    zk_a_and_ptr + (%00000 <<10)+1                      ' $1A: LD A,(DE)
                long    zk_incdec16+(%0001_1_1111_01_1_11010<<10)           ' $1B: DEC DE
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $1C: INC E
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $1D: DEC E
                long    zk_loadimm8                                         ' $1E: LD E,imm8
                long    zk_rolla+(%0_010_001_00_11011_00<<10)               ' $1F: RRA
                long    zk_jr + (%01_10_1111_0<<10)                         ' $20: JR NZ
                long    zk_loadimm16 + (%0011_1_111_0<<10)                  ' $21: LD HL,imm16
                long    zk_ld_abs16 + (%01011_00<<10)                       ' $22: LD (imm16),HL
                long    zk_incdec16+(%0011_1_1111_10_1_10110<<10)           ' $23: INC HL
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $24: INC H
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $25: DEC H
                long    zk_loadimm8                                         ' $26: LD H,imm8
                long    zk_daa                                              ' $27: DAA
                long    zk_jr + (%00_10_1111_0<<10)                         ' $28: JR Z
                long    zk_math16+(%0010_111_00_1100_00_1011_1_0<<10)       ' $29: ADD HL,HL
                long    zk_ld_abs16 + (%00110_11111_00<<10)                 ' $2A: LD HL,(imm16)
                long    zk_incdec16+(%0011_1_1111_01_1_10110<<10)           ' $2B: DEC HL
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)   ' $2C: INC L
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)   ' $2D: DEC L
                long    zk_loadimm8                                         ' $2E: LD L,imm8
                long    zk_cpl                                              ' $2F: CPL
                long    zk_jr + (%01_01_1111_0<<10)                         ' $30: JR NC
                long    zk_loadimm16 + (%0111_1_111_0<<10)                              ' $31: LD SP,imm16
                long    zk_ld_abs + (%001111_00<<10)                                    ' $32: LD (imm16),A
                long    zk_incdec16+(%0111_1_1111_10_1_01110<<10)                       ' $33: INC SP
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)+ZK_HLOP       ' $34: INC (HL)
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)+ZK_HLOP       ' $35: DEC (HL)
                long    zk_loadimm8 + ZK_HLOP                ' $36: LD (HL),imm8
                long    zk_scf + (%10 << 10)                 ' $37: SCF
                long    zk_jr + (%00_01_1111_0<<10)          ' $38: JR C
                long    zk_math16+(%0010_111_00_1100_00_0111_1_0<<10) ' $39: ADD HL,SP
                long    zk_ld_abs + (  %0011_00<<10)         ' $3A: LD A,(imm16)
                long    zk_incdec16+(%0111_1_1111_01_1_01110<<10)' $3B: DEC SP
                long    zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $3C: INC A
                long    zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $3D: DEC A
                long    zk_loadimm8                          ' $3E: LD A,imm8
                long    zk_ccf                               ' $3F: CCF
                long    zk_nextop                            ' $40: LD B,B (NOP)
                long    zk_regmove                           ' $41: LD B,C
                long    zk_regmove                           ' $42: LD B,D
                long    zk_regmove                           ' $43: LD B,E
                long    zk_regmove                           ' $44: LD B,H
                long    zk_regmove                           ' $45: LD B,L
                long    zk_regmove + ZK_HLOP                 ' $46: LD B,(HL)
                long    zk_regmove                           ' $47: LD B,A
                long    zk_regmove                           ' $48: LD C,B
                long    zk_nextop                            ' $49: LD C,C (NOP)
                long    zk_regmove                           ' $4A: LD C,D
                long    zk_regmove                           ' $4B: LD C,E
                long    zk_regmove                           ' $4C: LD C,H
                long    zk_regmove                           ' $4D: LD C,L
                long    zk_regmove + ZK_HLOP                 ' $4E: LD C,(HL)
                long    zk_regmove                           ' $4F: LD C,A
                long    zk_regmove                           ' $50: LD D,B
                long    zk_regmove                           ' $51: LD D,C
                long    zk_nextop                            ' $52: LD D,D (NOP)
                long    zk_regmove                           ' $53: LD D,E
                long    zk_regmove                           ' $54: LD D,H
                long    zk_regmove                           ' $55: LD D,L
                long    zk_regmove + ZK_HLOP                 ' $56: LD D,(HL)
                long    zk_regmove                           ' $57: LD D,A
                long    zk_regmove                           ' $58: LD E,B
                long    zk_regmove                           ' $59: LD E,C
                long    zk_regmove                           ' $5A: LD E,D
                long    zk_nextop                            ' $5B: LD E,E (NOP)
                long    zk_regmove                           ' $5C: LD E,H
                long    zk_regmove                           ' $5D: LD E,L
                long    zk_regmove + ZK_HLOP                 ' $5E: LD E,(HL)
                long    zk_regmove                           ' $5F: LD E,A
                long    zk_regmove                           ' $60: LD H,B
                long    zk_regmove                           ' $61: LD H,C
                long    zk_regmove                           ' $62: LD H,D
                long    zk_regmove                           ' $63: LD H,E
                long    zk_nextop                            ' $64: LD H,H (NOP)
                long    zk_regmove                           ' $65: LD H,L
                long    zk_regmove + ZK_HLOP                 ' $66: LD H,(HL)
                long    zk_regmove                           ' $67: LD H,A
                long    zk_regmove                           ' $68: LD L,B
                long    zk_regmove                           ' $69: LD L,C
                long    zk_regmove                           ' $6A: LD L,D
                long    zk_regmove                           ' $6B: LD L,E
                long    zk_regmove                           ' $6C: LD L,H
                long    zk_nextop                            ' $6D: LD L,L (NOP)
                long    zk_regmove + ZK_HLOP                 ' $6E: LD L,(HL)
                long    zk_regmove                           ' $6F: LD L,A
                long    zk_regmove + ZK_HLOP                 ' $70: LD (HL),B
                long    zk_regmove + ZK_HLOP                 ' $71: LD (HL),C
                long    zk_regmove + ZK_HLOP                 ' $72: LD (HL),D
                long    zk_regmove + ZK_HLOP                 ' $73: LD (HL),E
                long    zk_regmove + ZK_HLOP                 ' $74: LD (HL),H
                long    zk_regmove + ZK_HLOP                 ' $75: LD (HL),L
                long    zk_halt                              ' $76: HALT
                long    zk_regmove + ZK_HLOP                 ' $77: LD (HL),A
                long    zk_regmove                           ' $78: LD A,B
                long    zk_regmove                           ' $79: LD A,C
                long    zk_regmove                           ' $7A: LD A,D
                long    zk_regmove                           ' $7B: LD A,E
                long    zk_regmove                           ' $7C: LD A,H
                long    zk_regmove                           ' $7D: LD A,L
                long    zk_regmove + ZK_HLOP                 ' $7E: LD A,(HL)
                long    zk_nextop                            ' $7F: LD A,A (NOP)
                long   (zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) )[6]' $80..$85: ADD A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) + ZK_HLOP ' $86: ADD A,(HL)
                long    zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) ' $87: ADD A,A
                long   (zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) )[6]' $88..$8D: ADC A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) + ZK_HLOP ' $8E: ADC A,(HL)
                long    zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) ' $8F: ADC A,A
                long   (zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) )[6]' $90..$95: SUB [BCDEHL]
                long    zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $96: SUB (HL)
                long    zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) ' $97: SUB A
                long   (zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) )[6]' $98..$9D: SBC A,[BCDEHL]
                long    zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) + ZK_HLOP ' $9E: SBC A,(HL)
                long    zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) ' $9F: SBC A,A
                long   (zk_logic + (%000000_110_0<<10))[6]   ' $A0..$A5: AND [BCDEHL]
                long    zk_logic + (%000000_110_0<<10) + ZK_HLOP ' $A6: AND (HL)
                long    zk_logic + (%000000_110_0<<10)       ' $A7: AND A
                long   (zk_logic + (%001000_011_0<<10))[6]   ' $A8..$AD: XOR [BCDEHL]
                long    zk_logic + (%001000_011_0<<10) + ZK_HLOP ' $AE: XOR (HL)
                long    zk_logic + (%001000_011_0<<10)       ' $AF: XOR A
                long   (zk_logic + (%001000_101_0<<10))[6]   ' $B0..$B5: OR [BCDEHL]
                long    zk_logic + (%001000_101_0<<10) + ZK_HLOP ' $B6: OR (HL)
                long    zk_logic + (%001000_101_0<<10)       ' $B7: OR A
                long   (zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) )[6]' $B8..$BD: CP [BCDEHL]
                long    zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $BE: CP (HL)
                long    zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) ' $BF: CP A
                long    zk_condret+(%0101_11_00_01_1110_0<<10) ' $C0: RET NZ
                long    zk_poppair+(%0_0<<10)                  ' $C1: POP BC
                long    zk_jump  + (%0101_11_01_01_1110_10<<10) ' $C2: JP NZ,imm16
                long    zk_jump  + (%0101_11_01_11_1111_10<<10) ' $C3: JP imm16
                long    zk_jump  + (%0000_11_01_01_1110_10<<10) ' $C4: CALL NZ,imm16
                long    zk_pushbc+(%0_1110<<10)              ' $C5: PUSH BC
                long    zk_immmath + (%10_11_00_0000_1100_0_10_00_0<<10) ' $C6: ADD A,imm8
                long    zk_rst                               ' $C7: RST 00h
                long    zk_condret+(%0101_11_00_00_1110_0<<10) ' $C8: RET Z
                long    zk_ret + (%0101_11_00<<10)           ' $C9: RET
                long    zk_jump  + (%0101_11_01_00_1110_10<<10)' $CA: JP Z,imm16
                long    zk_bitprefix + ZK_HLOP               ' $CB: bit op prefix
                long    zk_jump  + (%0000_11_01_00_1110_10<<10)' $CC: CALL Z,imm16
                long    zk_jump  + (%0000_11_01_11_1111_10<<10)' $CD: CALL imm16
                long    zk_immmath + (%10_11_00_0000_1100_0_01_00_0<<10) ' $CE: ADC A,imm8
                long    zk_rst                               ' $CF: RST 08h
                long    zk_condret+(%0101_11_00_01_1101_0<<10) ' $D0: RET NC
                long    zk_poppair+(%01_0<<10)                 ' $D1: POP DE
                long    zk_jump  + (%0101_11_01_01_1101_10<<10)' $D2: JP NC,imm16
                long    zk_immio + (%00_00<<10)                ' $D3: OUT (imm8),A
                long    zk_jump  + (%0000_11_01_01_1101_10<<10)' $D4: CALL NC,imm16
                long    zk_pushde+(%0_110<<10)               ' $D5: PUSH DE
                long    zk_immmath + (%10_11_00_0000_0011_0_10_00_0<<10) ' $D6: SUB imm8
                long    zk_rst                               ' $D7: RST 10h
                long    zk_condret+(%0101_11_00_00_1101_0<<10) ' $D8: RET C
                long    zk_exx                               ' $D9: EXX
                long    zk_jump  + (%0101_11_01_00_1101_10<<10)' $DA: JP C,imm16
                long    zk_immio + (%00_11_00<<10)             ' $DB: IN A,(imm8)
                long    zk_jump  + (%0000_11_01_00_1101_10<<10)' $DC: CALL C,imm16
                long    zk_ixprefix                          ' $DD: IX prefix
                long    zk_immmath + (%10_11_00_0000_0011_0_01_00_0<<10) ' $DE: SBC A,imm8
                long    zk_rst                               ' $DF: RST 18h
                long    zk_condret+(%0101_11_00_01_1011_0<<10) ' $E0: RET PO
                long    zk_poppair+(%0011_0<<10)               ' $E1: POP HL
                long    zk_jump  + (%0101_11_01_01_1011_10<<10)' $E2: JP PO,imm16
                long    zk_ex_hlstk                          ' $E3: EX (SP),HL
                long    zk_jump  + (%0000_11_01_01_1011_10<<10)' $E4: CALL PO,imm16
                long    zk_pushhl+(%0_10<<10)                  ' E5: PUSH HL
                long    zk_immlogic + (%000000_110_1_0<<10)  ' $E6: AND imm8
                long    zk_rst                               ' $E7: RST 20h
                long    zk_condret+(%0101_11_00_00_1011_0<<10) ' $E8: RET PE
                long    zk_jump_indir                          ' $E9: JP (HL)
                long    zk_jump  + (%0101_11_01_00_1011_10<<10)' $EA: JP PE,imm16
                long    zk_ex_dehl                           ' $EB: EX DE,HL
                long    zk_jump  + (%0000_11_01_00_1011_10<<10)' $EC: CALL PE,imm16
                long    zk_extprefix + ZK_HLOP               ' $ED: extension prefix
                long    zk_immlogic + (%001000_011_1_0<<10)  ' $EE: XOR imm8
                long    zk_rst                               ' $EF: RST 28h
                long    zk_condret+(%0101_11_00_01_0111_0<<10) ' $F0: RET P
                long    zk_poppair+(%00_1111_0<<10)            ' $F1: POP AF
                long    zk_jump  + (%0101_11_01_01_0111_10<<10)' $F2: JP P,imm16
                long    zk_irqoff                              ' $F3: DI
                long    zk_jump  + (%0000_11_01_01_0111_10<<10)' $F4: CALL P,imm16
                long    zk_pushaf+(%0_11111_00<<10)            ' $F5: PUSH AF
                long    zk_immlogic + (%001000_101_1_0<<10)  ' $F6: OR imm8
                long    zk_rst                               ' $F7: RST 30h
                long    zk_condret+(%0101_11_00_00_0111_0<<10) ' $F8: RET M
                long    zk_hl_to_sp                            ' $F9: LD SP,(HL)
                long    zk_jump  + (%0101_11_01_00_0111_10<<10)' $FA: JP M,imm16
                long    zk_irqon                               ' $FB: EI
                long    zk_jump  + (%0000_11_01_00_0111_10<<10)' $FC: CALL M,imm16
                long    zk_iyprefix + (%10<<10)              ' $FD: IY prefix
                long    zk_immmath + (%11_00_00_0000_0011_0_10_00_0<<10) ' $FE: CP imm8
                long    zk_rst                               ' $FF: RST 38h

zk_rolla        mov     zk_tmp8,zk_accu
zk_shiftop
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)

                bitl    zk_tmp8,#7 wcz  ' left + SRA
                bitz    zk_tmp8,#7 addbits 1 ' only SRA
                bitl    zk_tmp8,#0 wcz  ' right
                modc    _set wc ' only SLL
                modc    _clr wc ' only SLA

                testb   zk_flags,#ZK_CARRY_BIT wc' only RL/RR
                bitz    zk_flags,#ZK_CARRY_BIT

                rcl     zk_tmp8,#1 wz   ' left
                bitc    zk_tmp8,#8     ' right (not SRA/SRL)
                shr     zk_tmp8,#1 wz   ' right

                setq    #ZK_XYMASK
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8

        _ret_   mov     zk_accu,zk_tmp8

                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_tmp8,#$FF wc
        _ret_   bitnc   zk_flags,#ZK_OVER_BIT

zk_cio
                mov     zk_optmp1,zk_opcode
                and     zk_optmp1,#7<<3
                cmp     zk_optmp1,#6<<3 wz
                mov     zk_tmp8,#0
        if_nz   call    #\zk_getry
                getbyte zk_ea,zk_debc,#0
zk_immio
                call    #\zk_readcode
                mov     zk_ea,zk_tmp8

                mov     zk_tmp8,zk_accu
                jmp     #\zk_portout

                call    #\zk_portin
        _ret_   mov     zk_accu,zk_tmp8

                and     zk_tmp8,#$FF wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT
                andn    zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8

                cmp     zk_optmp1,#6<<3 wz
        if_z    ret
                jmp     #\zk_setry

zk_incdec8
                call    #\zk_getry
                mov     zk_optmp0,#1
zk_math8
                call    #\zk_getrz
zk_immmath
                call    #\zk_readcode
                mov     zk_optmp0,zk_tmp8
                mov     zk_tmp8,zk_accu

                modc    _clr wc
                testb   zk_flags,#ZK_CARRY_BIT wc

                ' Flag helper gunk
                mov     zk_optmp1,zk_tmp8

                addx    zk_tmp8,zk_optmp0
                bitl    zk_flags,#ZK_NMODE_BIT
                subx    zk_tmp8,zk_optmp0
                bith    zk_flags,#ZK_NMODE_BIT

                xor     zk_optmp1,zk_tmp8
                test    zk_tmp8,#$100 wc
                bitc    zk_flags,#ZK_CARRY_BIT
                and     zk_tmp8,#255 wz

                setq    #ZK_SIGNXYMASK
                muxq    zk_flags,zk_tmp8
                ' Special nonsense for CP
                setq    #ZK_XYMASK
                muxq    zk_flags,zk_optmp0

                mov     zk_accu,zk_tmp8
                call    #\zk_setry

                xor     zk_optmp1,zk_optmp0
                bitz    zk_flags,#ZK_ZERO_BIT
                testb   zk_optmp1,#4 wc
                bitc    zk_flags,#ZK_HALF_BIT
                test    zk_optmp1,#$180 wc
        _ret_   bitc    zk_flags,#ZK_OVER_BIT

zk_neg
                cmp     zk_accu,#$80 wz
                bitz    zk_flags,#ZK_OVER_BIT
                testb   zk_accu,#4 wz
                subr    zk_accu,#0 wc
                bitc    zk_flags,#ZK_CARRY_BIT
                testb   zk_accu,#4 xorz
                bitz    zk_flags,#ZK_HALF_BIT
                and     zk_accu,#$FF wz
                bitz    zk_flags,#ZK_ZERO_BIT
                bith    zk_flags,#ZK_NMODE_BIT
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu


zk_cpl
                xor     zk_accu,#$FF
                or      zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_math16
                modc    _clr wc
zk_cmath16
                testb   zk_flags,#ZK_CARRY_BIT wc

                getword zk_tmp16,zk_debc,#0 ' get BC
                getword zk_tmp16,zk_debc,#1 ' get DE
                mov     zk_tmp16,zk_temphl      ' get HL/I*
                mov     zk_tmp16,zk_sp          ' get SP

                mov     zk_optmp1,zk_temphl
                xor     zk_optmp1,zk_tmp16

                addx    zk_temphl,zk_tmp16
                bitl    zk_flags,#ZK_NMODE_BIT
                subx    zk_temphl,zk_tmp16
                bith    zk_flags,#ZK_NMODE_BIT

                xor     zk_optmp1,zk_temphl
                and     zk_temphl,zk_ffffh wz

                bitz    zk_flags,#ZK_ZERO_BIT
                test    zk_optmp1,zk_18000h wc
                bitc    zk_flags,#ZK_OVER_BIT

                getbyte pa,zk_temphl,#1
                setq    #ZK_SIGNXYMASK
                setq    #ZK_XYMASK
                muxq    zk_flags,pa

                testb   zk_optmp1,#12 wc
                bitc    zk_flags,#ZK_HALF_BIT
                testb   zk_optmp1,#16 wc
                bitc    zk_flags,#ZK_CARRY_BIT

                add     zk_cycles,#7

                altd    zk_hlptr
        _ret_   mov     0-0,zk_temphl

zk_daa
                mov     zk_optmp0,#$00
                mov     zk_tmp8,zk_accu
                cmpr    zk_tmp8,#$99 wc
                testb   zk_flags,#ZK_CARRY_BIT orc
        if_c    add     zk_optmp0,#$60
                bitc    zk_flags,#ZK_CARRY_BIT
                getnib  zk_optmp1,zk_tmp8,#0
                cmpr    zk_optmp1,#$9 wc
                testb   zk_flags,#ZK_HALF_BIT orc
        if_c    add     zk_optmp0,#$06
                testb   zk_flags,#ZK_NMODE_BIT wc
                sumc    zk_accu,zk_optmp0
                and     zk_accu,#255 wcz
                bitz    zk_flags,#ZK_ZERO_BIT
                bitnc   zk_flags,#ZK_OVER_BIT ' Parity?
                testb   zk_accu,#4 wc
                testb   zk_tmp8,#4 xorc
                bitc    zk_flags,#ZK_HALF_BIT
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_immlogic
                call    #\zk_readcode
zk_logic
                call    #\zk_getrz

                and     zk_accu,zk_tmp8 wcz
                or      zk_accu,zk_tmp8 wcz
                xor     zk_accu,zk_tmp8 wcz

                bitnc   zk_flags,#ZK_OVER_BIT ' parity
                bitz    zk_flags,#ZK_ZERO_BIT
                andn    zk_flags,#(1<<ZK_CARRY_BIT)|(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
                bith    zk_flags,#ZK_HALF_BIT ' Only for AND
                setq    #ZK_SIGNXYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_pushaf
                getbyte zk_tmp16,zk_accu,#0
                rolbyte zk_tmp16,zk_flags,#0

zk_incdec16
                add     zk_cycles,#2
zk_pushbc       getword zk_tmp16,zk_debc,#0 ' get BC
zk_pushde       getword zk_tmp16,zk_debc,#1 ' get DE
zk_pushhl       mov     zk_tmp16,zk_temphl      ' get HL/I*
                mov     zk_tmp16,zk_sp          ' get SP

                jmp     #\zk_push16

                add     zk_tmp16,#1
                sub     zk_tmp16,#1

zk_loadimm16
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16   ' for LDs with (imm16)
                call    #\zk_read16     ' ^^
                jmp     #\zk_write16     ' ^^
zk_poppair
                call    #\zk_pop16

        _ret_   setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_   setword zk_debc,zk_tmp16,#1 ' set DE
                altd    zk_hlptr
        _ret_   setword zk_sp,zk_tmp16,#0   ' set SP/HL/I*

                getbyte zk_accu,zk_tmp16,#1   ' set A
        _ret_   getbyte zk_flags,zk_tmp16,#0  ' set F

zk_jr           '' JR and DJNZ
                call    #\zk_readcode

                getbyte pa,zk_debc,#1
                sub     pa,#1 wz
                setbyte zk_debc,pa,#1
                add     zk_cycles,#1

                testb   zk_flags,#ZK_ZERO_BIT wz
                testb   zk_flags,#ZK_CARRY_BIT wz

                modz    _nz wz
        if_z    call    #\zk_nextop
                ' branch taken
                add     zk_cycles,#5
                signx   zk_tmp8,#7
        _ret_   add     zk_pc,zk_tmp8

zk_exx          '' EXX
                xor     zk_debc,zk_altdebc
                xor     zk_altdebc,zk_debc
                xor     zk_debc,zk_altdebc
                ' Note: not affected by IX/IY substitution
                xor     zk_hl,zk_althl
                xor     zk_althl,zk_hl
        _ret_   xor     zk_hl,zk_althl

zk_ex_dehl      '' EX DE,HL
                ' Note: not affected by IX/IY substitution
                getword zk_optmp0,zk_debc,#1
                setword zk_debc,zk_hl,#1
        _ret_   mov     zk_hl,zk_optmp0


zk_ex_af        '' EX AF,AF'
                xor     zk_accu,zk_altaccu
                xor     zk_altaccu,zk_accu
                xor     zk_accu,zk_altaccu
                xor     zk_flags,zk_altflags
                xor     zk_altflags,zk_flags
        _ret_   xor     zk_flags,zk_altflags

zk_ex_hlstk     '' EX (SP),HL
                add     zk_cycles,#3 ' Should be 19. 19 - 4 - 4*3 = 3
                mov     zk_ea,zk_sp
                call    #\zk_read16
                altd    zk_hlptr
                mov     0-0,zk_tmp16
                mov     zk_tmp16,zk_temphl
                jmp     #\zk_write16

zk_ld_abs16     '' LD HL,(imm16) and LD (imm16),HL
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16

                getword zk_tmp16,zk_debc,#0 ' get BC
                getword zk_tmp16,zk_debc,#1 ' get DE
                mov     zk_tmp16,zk_temphl ' get HL/I*
                mov     zk_tmp16,zk_sp ' get SP
                jmp     #\zk_write16

                call    #\zk_read16
        _ret_   setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_   setword zk_debc,zk_tmp16,#1 ' set DE
                altd    zk_hlptr
        _ret_   mov     zk_sp,zk_tmp16

zk_scf
                modc    _clr wc
zk_ccf
                testb   zk_flags,#ZK_CARRY_BIT wc
                bitnc   zk_flags,#ZK_CARRY_BIT
                bitc    zk_flags,#ZK_HALF_BIT
                bitl    zk_flags,#ZK_NMODE_BIT
                setq    #ZK_XYMASK
        _ret_   muxq    zk_flags,zk_accu

zk_ld_abs       '' LD A,(imm16) and LD (imm16),A
                call    #\zk_readcode16
                mov     zk_ea,zk_tmp16
zk_a_and_ptr    '' A and (BC)/(DE) ops
                getword zk_ea,zk_debc,#0 ' get BC
                getword zk_ea,zk_debc,#1 ' get DE
                call    #\zk_read8
        _ret_   mov     zk_accu,zk_tmp8
                mov     zk_tmp8,zk_accu
                jmp     #\zk_write8

zk_regmove
                push    #zk_setry
                jmp     #\zk_getrz

zk_loadimm8
                push    #zk_setry
                jmp     #\zk_readcode

zk_halt
                or      zk_irqenable,#(1<<ZK_HALT_BIT)
        _ret_   decmod  zk_pc,zk_ffffh

                fit     $400

DAT             ' I/O Hub-exec code
                orgh

'
' Controllers
'
ctrl_rd
                testb   zk_ea, #1       wc          ' A1 = select controller
                testb   io_flags, #1    wz          ' Controller mode flip/flop
         if_00  rdbyte  zk_tmp8, #@coleco_ctrls+0   ' Joystick 0
         if_01  rdbyte  zk_tmp8, #@coleco_ctrls+1   ' Keypad 0
         if_10  rdbyte  zk_tmp8, #@coleco_ctrls+2   ' Joystick 1
         if_11  rdbyte  zk_tmp8, #@coleco_ctrls+3   ' Keypad 1
                ret     wcz

'
' TMS9918
'
tms_wr
                testb   io_flags, #0    wc
                testb   zk_ea, #0       wz          ' A0 = register / ram
         if_x0  jmp     #\tms_ram_wr
         if_01  jmp     #\tms_data_wr
         if_11  jmp     #\tms_reg_wr

tms_data_wr     bith    io_flags, #0
                getbyte tms_tmp0, zk_tmp8, #0
                ret     wcz

tms_reg_wr      bitl    io_flags, #0
                testb   zk_tmp8, #7     wz
        if_x0   jmp     #tms_addr_wr
                mov     tms_tmp1, zk_tmp8
                and     tms_tmp1, #$07
                cmp     tms_tmp1, #1    wz      ' Z = Reg1 (may be INT enable)
                add     tms_tmp1, #@tms_regs
                wrbyte  tms_tmp0, tms_tmp1
        if_nz   ret     wcz
                rdlong  tms_tmp1, #@tms_status
                testb   zk_tmp8, #5     wc      ' C = INT ENABLE
                testb   tms_tmp1, #5    andc    ' FSync
                bitc    tms_tmp1, #8            ' Generate NMI if INT enable and FSync
                wrlong  tms_tmp1, #@tms_status
                ret     wcz

tms_addr_wr     mov     tms_ramptr, zk_tmp8
                and     tms_ramptr, #$3F
                shl     tms_ramptr, #8
                or      tms_ramptr, tms_tmp0
                ret     wcz

tms_rd
                testb   zk_ea, #0       wz
        if_x0   jmp     #\tms_ram_rd
        if_x1   jmp     #\tms_status_rd

tms_ram_wr      mov     tms_tmp1, tms_ramptr
                add     tms_tmp1, ##@tms_vram
                wrbyte  zk_tmp8, tms_tmp1
                incmod  tms_ramptr, ##16384-1
                ret     wcz

tms_ram_rd      mov     tms_tmp1, tms_ramptr
                add     tms_tmp1, ##@tms_vram
                rdbyte  zk_tmp8, tms_tmp1
                incmod  tms_ramptr, ##16384-1
                ret     wcz

tms_status_rd   rdlong  tms_tmp1, #@tms_status
                getbyte zk_tmp8, tms_tmp1, #0
                and     tms_tmp1, #%000_11111
                wrlong  tms_tmp1, #@tms_status
                ret     wcz

'
' SN76489
'
psg_wr
                test    zk_tmp8, #%1_000_0000   wz  ' latch or data ?
        if_z    jmp     #psg_data_wr

                mov     psg_latch, zk_tmp8
                and     psg_latch, #%0_111_0000     ' channel number
                shr     psg_latch, #2               ' point to channel registers

                mov     zk_memtmp0, #@psg_registers
                add     zk_memtmp0, psg_latch
                rdlong  psg_data, zk_memtmp0
                setnib  psg_data, zk_tmp8, #0
                wrlong  psg_data, zk_memtmp0

                ret     wcz

psg_data_wr     and     zk_tmp8, #%00_111111
                shl     zk_tmp8, #4

                mov     zk_memtmp0, #@psg_registers
                add     zk_memtmp0, psg_latch
                rdlong  psg_data, zk_memtmp0
                and     psg_data, #$0F              ' keep existing lower 4 bits
                or      psg_data, zk_tmp8           ' add upper 6 bits
                wrlong  psg_data, zk_memtmp0

                ret     wcz

CON ' ZiKore constants

    ZK_CLOCK      = VIDEO == PAL ? 3_546_893 : 3_579_545
    ZK_HLOP       = 1 << 10

    ZK_CARRY_BIT  = 0
    ZK_NMODE_BIT  = 1
    ZK_OVER_BIT   = 2 ' also parity
    ZK_HALF_BIT   = 4
    ZK_ZERO_BIT   = 6
    ZK_SIGN_BIT   = 7

    ZK_XYMASK     = %0010_1000
    ZK_SIGNXYMASK = %1010_1000

    ZK_IFF1_BIT   = 0
    ZK_IFF2_BIT   = 1
    ZK_HALT_BIT   = 2

DAT             ' TMS9918
                org     $000

tms_driver
                add     ptrb, ##@tms_palette - @tms_driver
                setq2   #511                    ' load video drivers into lut
                rdlong  0, ptrb

                call    #\(VIDEO == VGA ? vga_init : cvbs_init) ' start video driver

                mov     scol, #0
                xcont   #10,#0                  ' do streamer instruction to start interrupt sequence
'
'
' Main program
'
loop
                cmp     _cl, scnt           wcz
    if_z        jmp     #loop

                mov     scol, scol+1
                mov     scnt, _cl

                cmp     _cl, #(VIDEO == PAL ? 48 : 24) + 192      wz
    if_ne       jmp     #.skip

                locktry #0              wc
    if_nc       jmp     #$-1
                rdlong  a, #@tms_status         ' update status byte
                or      a, #TMSVSYNC            ' vsync flag
                test    regs+1, #TMSINTEN   wz  ' interrupt enable
                bitnz   a, #8                   ' NMI
                wrlong  a, #@tms_status
                lockrel #0

.skip           setq    #1                      ' read registers into temp buffer
                rdlong  sbuf, #@tms_regs        ' |

                getnib  scol+1, sbuf+1, #6      ' border color for next line
                movbyts scol+1, #0

                getbyte regs+0, sbuf, #0
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
                getbyte regs+1, sbuf, #1
                getbyte regs+2, sbuf, #2
                shl     regs+2, #10             ' name table base address * $400
                add     regs+2, _tms_vram
                getbyte regs+3, sbuf, #3
                shl     regs+3, #6              ' color table base address * $40
    if_nz       andn    regs+3, vdp_8k_mask     ' limit color table to 8k boundaries
                add     regs+3, _tms_vram
                getbyte regs+4, sbuf+1, #0
                shl     regs+4, #11             ' pattern generator base address * $800
    if_nz       andn    regs+4, vdp_8k_mask     ' limit pattern table to 8k boundaries
                add     regs+4, _tms_vram
                getbyte r4_mask, sbuf+1, #0
                and     r4_mask, #%00000011
                shl     r4_mask, #8
                getbyte regs+5, sbuf+1, #1
                shl     regs+5, #7              ' sprite attribute table base address * $80
                add     regs+5, _tms_vram
                getbyte regs+6, sbuf+1, #2
                shl     regs+6, #11             ' sprite pattern generator base address * $800
                add     regs+6, _tms_vram
                getbyte regs+7, sbuf+1, #3

                cmp     _cl, #(VIDEO == PAL ? 48 : 24)  wcz ' check if first visible line
    if_c        jmp     #loop
                cmp     _cl, #(VIDEO == PAL ? 48 : 24) + 192    wc  ' check if last visible line
    if_nc       jmp     #loop

    if_z        mov     loff, #0                ' if first line reset counters...
    if_z        mov     lcnt, #0
    if_z        mov     ptrv, _tms_bitmap       ' ...and pointers

                setq    #32-1                   ' read all sprite attribute table
                rdlong  sbuf, regs+5

scanline
                mov     ptra, ptrv

                test    regs+1, #TMSBLANK   wz  ' blank
    if_z        jmp     #blank_line

                test    regs+1, #TMSMODE1   wz  ' text mode
                mov     a, lcnt
                andn    a, #$07                 ' divide and multiply by 8
                mov     b, a
                shl     a, #2                   ' multiply by 32
    if_nz       add     a, b                    ' multiply by 40
                add     regs+2, a
    if_nz       jmp     #text_mode

                test    regs+1, #TMSMODE2   wz  ' multicolor mode
    if_nz       jmp     #multicolor_mode

                jmp     #graphics_mode

text_mode
                getnib  ctmp, regs+7, #1        ' foreground color
                shl     ctmp, #8
                setnib  ctmp, regs+7, #0        ' background color

                mov     cbuf+0, ctmp
                movbyts cbuf+0, #0
                setq    #1
                wrlong  cbuf+0, ptra++

                mov     ptrb, regs+2

                mov     ecnt, #40
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display
                shl     ptrc, #3                ' 8 bytes per tile
                add     ptrc, regs+4
                add     ptrc, loff
                rdbyte  a, ptrc                 ' pixels, 1 bit per pixel, from msb

                rev     a
                shr     a, #24
                mergew  a
                mov     cbuf+0, ctmp
                movbyts cbuf+0, a
                shr     a, #8
                mov     cbuf+1, ctmp
                movbyts cbuf+1, a

                setq    #1
                wrlong  cbuf+0, ptra++
                sub     ptra, #2

                djnz    ecnt, #.loop

                mov     cbuf+0, ctmp
                movbyts cbuf+0, #0
                setq    #1
                wrlong  cbuf+0, ptra++

                jmp     #end_scanline

blank_line
                getnib  ctmp, regs+7, #0        ' background color
                movbyts ctmp, #0

                mov     ecnt, #256/4            ' fill line with background
.l1             wrlong  ctmp, ptra++
                djnz    ecnt, #.l1

                jmp     #end_scanline

multicolor_mode
                mov     a, lcnt
                shr     a, #2
                and     a, #$07

                mov     ptrb, regs+2

                mov     ecnt, #32
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display
                shl     ptrc, #3
                add     ptrc, regs+4            ' points to color table
                add     ptrc, a

                rdbyte  cbuf+0, ptrc            ' colors

                mov     cbuf+1, cbuf+0
                and     cbuf+1, #$0F        wz
    if_z        setnib  cbuf+1, regs+7, #0
                shr     cbuf+0, #4          wz
    if_z        setnib  cbuf+0, regs+7, #0

                movbyts cbuf+0, #%%0000
                movbyts cbuf+1, #%%0000

                setq    #1
                wrlong  cbuf+0, ptra++

                djnz    ecnt, #.loop

                jmp     #sprites

graphics_mode
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
    if_nz       mov     a, lcnt
    if_nz       shr     a, #6                   ' divide by 64 (8 rows by 8 pixels)
    if_nz       shl     a, #8                   ' multiply by 2048
    if_nz       and     a, r4_mask
    if_nz       shl     a, #3                   ' multiply by 2048 (cont.)
                mov     b, loff                 ' offset into pattern table
    if_nz       add     b, a                    ' add mode II pattern table offset

                bitnz   .shlr, #21              ' patch shl(0)/shr(1)

                mov     ptrb, regs+2

                mov     ecnt, #32
.loop           rdbyte  ptrc, ptrb++            ' read tile number to display

                mov     ptrd, ptrc
.shlr           shl     ptrd, #3
                add     ptrd, regs+3            ' points to color table
                test    regs+0, #TMSMODE3   wz  ' graphics mode II
    if_nz       add     ptrd, b
                rdbyte  a, ptrd                 ' colors

                getnib  cbuf+0, a, #0
                and     cbuf+0, #$0F        wz
    if_z        setnib  cbuf+0, regs+7, #0
                getnib  cbuf+1, a, #1
                and     cbuf+1, #$0F        wz
    if_z        setnib  cbuf+1, regs+7, #0

                setbyte cbuf+0, cbuf+1, #1
                mov     cbuf+1, cbuf+0

                shl     ptrc, #3                ' 8 bytes per tile
                add     ptrc, regs+4
                add     ptrc, b
                rdbyte  a, ptrc                 ' pixels, 1 bit per pixel, from msb

                rev     a
                shr     a, #24
                mergew  a
                movbyts cbuf+0, a
                shr     a, #8
                movbyts cbuf+1, a

                setq    #1
                wrlong  cbuf+0, ptra++

                djnz    ecnt, #.loop

                ' fall through

sprites
                mov     ecnt, #9                ' clear collision buffer
.l1             altd    ecnt, #line-1           ' |
                mov     0-0, #0                 ' |
                djnz    ecnt, #.l1              ' |

                mov     b, #8                   ' calculate sprite size
                test    regs+1, #TMSSPRSIZE wz  ' |
    if_nz       shl     b, #1                   ' |
                test    regs+1, #TMSSPRMAG  wz  ' |
    if_nz       shl     b, #1                   ' b = 8/16/32

                mov     stat, #0
                mov     vcnt, #0
                mov     ccnt, #0

                mov     ecnt, #TMSSPRITES
.l2             alts    ccnt, #sbuf             ' find last sprite
                getbyte y, 0-0, #0              ' |
                cmp     y, #$D0             wz  ' |
    if_e        jmp     #.loop                  ' |
                add     y, #1                   ' |
                cmp     y, #$D0             wcz ' |
    if_a        sub     y, #$100                ' |
                                                ' |
                mov     a, lcnt                 ' | check sprite scanline visibility
                subs    a, y                wc  ' | |
    if_b        jmp     #.l3                    ' | |
                cmp     a, b                wc  ' | |
    if_ae       jmp     #.l3                    ' | |
                add     vcnt, #1                ' | vcnt = number of sprites on scanline
                                                ' |
.l3             add     ccnt, #1                ' |
                djnz    ecnt, #.l2              ' |

.loop           decmod  ccnt, #0            wc  ' loop backward to draw visible sprites
    if_c        jmp     #.end                   ' |

                alts    ccnt, #sbuf
                mov     sprt, 0-0

                getbyte y, sprt, #0
                add     y, #1
                cmp     y, #$D0             wcz
    if_a        sub     y, #$100

                mov     a, lcnt                 ' check sprite scanline visibility
                subs    a, y                wc
    if_b        jmp     #.loop
                cmp     a, b                wc
    if_ae       jmp     #.loop

                cmps    vcnt, #5            wcz
    if_e        mov     stat, ccnt              ' set 5th sprite
    if_e        or      stat, #TMS5SPRITE       ' |
                sub     vcnt, #1
'    if_ae       jmp     #.loop                  ' comment to remove sprite limit

                getbyte ptrc, sprt, #2
                test    regs+1, #TMSSPRSIZE wz
    if_nz       and     ptrc, #$FC
                shl     ptrc, #3
                add     ptrc, regs+6
                test    regs+1, #TMSSPRMAG  wz
    if_nz       shr     a, #1
                add     ptrc, a

                getnib  ctmp, sprt, #6          'set sprite color
                shl     ctmp, #8

                getbyte x, sprt, #1
                testb   sprt, #31           wz  'TMSEARLYCLK
    if_x1       sub     x, #32
                mov     ptra, ptrv
                add     ptra, x

                test    regs+1, #TMSSPRSIZE wz
    if_z        mov     ecnt, #4
    if_nz       mov     ecnt, #8

                rdbyte  sprt, ptrc
                shl     sprt, #8
    if_nz       add     ptrc, #16
    if_nz       rdbyte  a, ptrc
    if_nz       or      sprt, a

                test    regs+1, #TMSSPRMAG  wz
    if_nz       setword sprt, sprt, #1
    if_nz       mergew  sprt
    if_z        shl     sprt, #16

                cmps    x, #0       wc          ' skip left offscreen pixels
    if_c        abs     x                       ' |
    if_c        add     ptra, x                 ' |
    if_c        sub     ecnt, x                 ' |
    if_c        cmps    x, #32      wz          ' |
    if_c_and_z  mov     sprt, #0                ' |
    if_c_and_nz shl     sprt, x                 ' |
    if_c        mov     x, #0                   ' |

                mov     cbuf, sprt
                mov     cbuf+1, cbuf

                mov     y, x                    ' check sprite collision
                sar     y, #5                   ' |
                add     y, #line                ' |
                setd    .c0, y                  ' |
                setd    .c0+1, y                ' |
                add     y, #1                   ' |
                setd    .c1, y                  ' |
                setd    .c1+1, y                ' |
                mov     a, x                    ' |
                and     a, #$1F     wz          ' |
    if_z        mov     cbuf+1, #0              ' |
                shr     cbuf, a                 ' |
.c0             test    0-0, cbuf   wz          ' |
                or      0-0, cbuf               ' |
                mov     y, #32                  ' |
                sub     y, a                    ' |
                shl     cbuf+1,y                ' |
.c1 if_z        test    0-0, cbuf+1 wz          ' |
                or      0-0, cbuf+1             ' |
    if_nz       or      stat, #%0010_0000       ' update collision flag
                mov     line+8, #0              ' clear right offscreen pixels

                rev     sprt

.draw           getnib  a, sprt, #0
                mergew  a
                mov     cbuf+0, ctmp
                movbyts cbuf+0, a
                wmlong  cbuf+0, ptra++
                add     x, #4
                cmp     x, #256     wc
                shr     sprt, #4    wz
    if_c_and_nz djnz    ecnt, #.draw

                jmp     #.loop
.end

                locktry #0              wc
    if_nc       jmp     #$-1
                rdbyte  a, #@tms_status         ' update status byte
                test    stat, #TMSCOLL      wz
    if_nz       or      a, #TMSCOLL
                test    a, #TMS5SPRITE      wz
    if_z        or      a, stat
                wrbyte  a, #@tms_status
                lockrel #0

end_scanline
                add     ptrv, #256
                incmod  loff, #7
                incmod  lcnt, #192-1

                jmp     #loop
'
'
' Data
'
dacmode_s       long    P_DAC_124R_3V + P_CHANNEL ' %0000_0000_000_1011000000000_01_00000_0         'hsync is 123-ohm, 3.3V
dacmode_c       long    P_DAC_75R_2V + P_CHANNEL  ' %0000_0000_000_1011100000000_01_00000_0         'R/G/B are 75-ohm, 2.0V

cx              long    0
cy              long    0

vga_xf          long   (VGA_FPIX frac _CLKFREQ) >> 1             ' streamer frequency setting
vga_bs          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +   8    ' streamer command: before-sync
vga_ds          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  48    ' streamer command: during-sync
vga_as          long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 +  24    ' streamer command: after sync
vga_vi          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + 320    ' streamer command: visible
vga_bv          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +  32    ' streamer command: before visible
vga_dv          long    X_RFLONG_4X8_LUT|X_DACS_3_2_1_0 + 256    ' streamer command: during visible
vga_av          long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 +  32    ' streamer command: after visible
vga_pn          long    VGA_PIN & $38       ' base pin

cvbs_cb         long    VIDEO == PAL ? PAL_CB : NTSC_CB             ' colorburst reference color
cvbs_cy         long    VIDEO == PAL ? PAL_CY : NTSC_CY             ' colorspace y coefficients
cvbs_ci         long    VIDEO == PAL ? PAL_CI : NTSC_CI             ' colorspace i coefficients
cvbs_cq         long    VIDEO == PAL ? PAL_CQ : NTSC_CQ             ' colorspace q coefficients
cvbs_ca         long    VIDEO == PAL ? PAL_CA : NTSC_CQ             ' colorspace q coefficients, alt for pal
cvbs_cf         long   (VIDEO == PAL ? PAL_CF : NTSC_CF) frac _CLKFREQ ' colorspace frequency setting
cvbs_xf         long    VIDEO == PAL ? PAL_XF : NTSC_XF             ' streamer frequency setting

cvbs_bs         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  10 :  10)    ' streamer command: before-sync
cvbs_ds         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  30 :  27)    ' streamer command: during-sync
cvbs_bc         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?   6 :   4)    ' streamer command: before-colorburst
cvbs_dc         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  15 :  15)    ' streamer command: during-colorburst
cvbs_ac         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  17 :   9)    ' streamer command: after-colorburst
cvbs_db         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 338 : 313)    ' streamer command: during-blank

cvbs_bv         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + (VIDEO == PAL ?  41 :  28)    ' streamer command: before-visible
cvbs_dv         long    X_RFLONG_4X8_LUT|X_DACS_3_2_1_0 +                    256        ' streamer command: during-visible
cvbs_av         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + (VIDEO == PAL ?  41 :  29)    ' streamer command: after-visible
cvbs_vi         long    X_IMM_4X8_LUT   |X_DACS_3_2_1_0 + (VIDEO == PAL ? 338 : 313)    ' streamer command: during-blank

cvbs_hl         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  15 :  14)    ' streamer command: high-vsync-low
cvbs_hh         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 183 : 165)    ' streamer command: high-vsync-high

cvbs_ll         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ? 177 : 161)    ' streamer command: low-vsync-low
cvbs_lh         long    X_IMM_1X32_4DAC8|X_DACS_3_2_1_0 + (VIDEO == PAL ?  21 :  18)    ' streamer command: low-vsync-high

cvbs_pn         long    CVBS_PIN            ' pin(s)

_md             long    0
_lb             long    0                   ' line buffer pointer
_cl             long    0                   ' current line
_tms_vram       long    @tms_vram
_tms_bitmap     long    @tms_bitmap

vdp_8k_mask     long    $1FFF
r4_mask         long    0

a               res     1
b               res     1
x               res     1
y               res     1

scnt            res     1
scol            res     2                       'backdrop/border color

lcnt            res     1
loff            res     1
ccnt            res     1
vcnt            res     1
ecnt            res     1

ctmp            res     1
cbuf            res     2
sprt            res     1

ptrc            res     1
ptrd            res     1
ptrv            res     1

stat            res     1
regs            res     8
sbuf            res     32

line            res     8+1

DAT             ' VGA / CVBS drivers
                org     $200

tms_palette
                long    $00_00_00_00
                long    $00_00_00_00
                long    $66_CC_66_00
                long    $88_EE_88_00
                long    $44_44_DD_00
                long    $77_77_FF_00
                long    $BB_55_55_00
                long    $77_DD_DD_00
                long    $DD_66_66_00
                long    $FF_77_77_00
                long    $CC_CC_55_00
                long    $EE_EE_88_00
                long    $55_AA_55_00
                long    $BB_55_BB_00
                long    $CC_CC_CC_00
                long    $EE_EE_EE_00
'
'
' VGA Driver
'
vga_init
                setcmod #%01_0_000_1            ' enable colorspace conversion
                setcy   ##VGA_INTENSITY << 24   ' r      set colorspace for rgb
                setci   ##VGA_INTENSITY << 16   ' g
                setcq   ##VGA_INTENSITY << 08   ' b
                setxfrq vga_xf                  ' set transfer frequency

                cogid   cx                      ' insert cogid into dac modes
                setnib  dacmode_s,cx,#2
                setnib  dacmode_c,cx,#2

                wrpin   dacmode_s,vga_pn        ' enable 123-ohm 3.3V dac mode in pin +0

                xor     vga_pn,#2<<6|1          ' enable 75-ohm 2.0V dac mode in pins +1..3
                wrpin   dacmode_c,vga_pn

                xor     vga_pn,#3<<6 ^(2<<6|1)  ' make pins +0..3 outputs
                drvl    vga_pn

                xor     vga_pn,#4|(3<<6)        ' leave av_base pointing to pin +4 (vertical sync)
                drvh    vga_pn

                mov     ijmp1,##vga_field       ' set up streamer-empty interrupt
        _ret_   setint1 #10
'
'
' Field loop
'
vga_field
                mov     cy,#24                  ' before-visible blank lines
                calld   pa, #.border

                mov     _lb, _tms_bitmap

                mov     cy,#192                 ' visible lines
.line           xcont   vga_as,#0               ' do before-visible part of scan line
                add     _cl, #1

                rdfast  #4, _lb                 ' start reading pixels into fifo
                resi1
                xcont   vga_bv, scol
                resi1
                xcont   vga_dv, #0
                resi1
                xcont   vga_av, scol
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1

                ' duplicate line
                xcont   vga_as,#0               ' do before-visible part of scan line
                resi1
                xcont   vga_bv, scol
                resi1
                xcont   vga_dv, #0
                resi1
                xcont   vga_av, scol
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line

                add     _lb, #256
                resi1
                djnz    cy,#.line

                mov     cy,#24                  ' after-visible blank lines
                calld   pa, #.border

                mov     cy, #10
                calld   pa, #.blank

                drvnot  vga_pn                  ' vertical sync on
                mov     cy, #2
                calld   pa, #.blank
                drvnot  vga_pn                  ' vertical sync off

                mov     _cl, #0

                mov     cy, #33
                calld   pa, #.blank

                jmp     #vga_field              ' loop
'
'
' Subroutines
'
.border         xcont   vga_as,#0               ' do before-visible part of scan line
                add     _cl, #1
                resi1
                xcont   vga_vi,scol             ' do visible part of scan line (blank)
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1

                xcont   vga_as,#0               ' do before-visible part of scan line
                resi1
                xcont   vga_vi,scol             ' do visible part of scan line (blank)
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1
                djnz    cy,#.border
                jmp     pa

.blank          xcont   vga_as,#0               ' do before-visible part of scan line
                resi1
                xcont   vga_vi,#0               ' do visible part of scan line (blank)
                resi1
                xcont   vga_bs,#0               ' do before-sync part of scan line
                resi1
                xzero   vga_ds,#1               ' do sync part of scan line
                resi1
                djnz    cy,#.blank              ' loop if more blanks needed
                jmp     pa
'
'
' CVBS Driver
'
cvbs_init
                setcmod #%11_1_0000             ' set colorspace converter to YIQ mode (composite)
                setcy   cvbs_cy                 ' set colorspace converter y coefficients
                setci   cvbs_ci                 ' set colorspace converter i coefficients
                setcq   cvbs_cq                 ' set colorspace converter q coefficients
                setcfrq cvbs_cf                 ' set colorspace converter frequency
                setxfrq cvbs_xf                 ' set transfer frequency

                cogid   cx                      ' install cogid into dacmode
                setnib  dacmode_c,cx,#2
                wrpin   dacmode_c,cvbs_pn       ' enable dac mode in pin(s)
                drvl    cvbs_pn                 ' enable dac output(s)

                mov     ijmp1,##cvbs_field      ' set up streamer-empty interrupt
        _ret_   setint1 #10

cvbs_field
                mov     cy, #(VIDEO == PAL ? 48 : 24)                 ' before-visible blank lines
                calld   pa, #.border            ' |

                rdfast  #0, _tms_bitmap         ' start reading pixels into fifo
                mov     cy, #192                ' visible lines

.line           xcont   cvbs_bs, #1             ' horizontal sync
                add     _cl, #1
                resi1                           ' |
                xcont   cvbs_ds, #2             ' |
                resi1                           ' |
                xcont   cvbs_bc, #1             ' |
                resi1                           ' |
                xcont   cvbs_dc, cvbs_cb        ' |
                bitnot  _md, #31            wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq                 ' |
        if_c    setcq   cvbs_ca                 ' |
                resi1                           ' |
                xcont   cvbs_ac, #1             ' |
                resi1                           ' |

                xcont   cvbs_bv, scol           ' left border
                resi1
                xcont   cvbs_dv, #0             ' visible part (from streamer)
                resi1
                xcont   cvbs_av, scol           ' right border
                resi1

                djnz    cy, #.line

                mov     cy, #(VIDEO == PAL ? 48 : 24)                 ' after-visible blank lines
                calld   pa, #.border            ' |

                mov     cy, #(VIDEO == PAL ? 8 : 2)                  ' before-visible blank lines
                calld   pa, #.blank             ' |

                mov     _cl, #0

                mov     cy, #6
                calld   pa, #.vhigh             ' initial high vertical syncs
                mov     cy, #(VIDEO == PAL ? 5 : 6)
                calld   pa, #.vlow              ' low vertical syncs
                mov     cy, #(VIDEO == PAL ? 5 : 6)
                calld   pa, #.vhigh             ' final high vertical syncs

                mov     cy, #(VIDEO == PAL ? 8 : 10)                 ' before-visible blank lines
                calld   pa, #.blank             ' |

                jmp     #cvbs_field             ' loop

.border         xcont   cvbs_bs, #1             ' horizontal sync
                add     _cl, #1
                resi1                           ' |
                xcont   cvbs_ds, #2             ' |
                resi1                           ' |
                xcont   cvbs_bc, #1             ' |
                resi1                           ' |
                xcont   cvbs_dc, cvbs_cb        ' |
                bitnot  _md, #31            wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq                 ' |
        if_c    setcq   cvbs_ca                 ' |
                resi1                           ' |
                xcont   cvbs_ac, #1             ' |
                resi1                           ' |
                xcont   cvbs_vi, scol           ' border line
                resi1                           ' |
                djnz    cy, #.border
                jmp     pa

.blank          xcont   cvbs_bs, #1             ' horizontal sync
                resi1                           ' |
                xcont   cvbs_ds, #2             ' |
                resi1                           ' |
                xcont   cvbs_bc, #1             ' |
                resi1                           ' |
                xcont   cvbs_dc, cvbs_cb        ' |
                bitnot  _md, #31            wcz ' for pal, alternate phase each line
        if_nc   setcq   cvbs_cq                 ' |
        if_c    setcq   cvbs_ca                 ' |
                resi1                           ' |
                xcont   cvbs_ac, #1             ' |
                resi1                           ' |
                xcont   cvbs_db, #1             ' blank line
                resi1                           ' |
                djnz    cy, #.blank
                jmp     pa

.vhigh          xcont   cvbs_bs, #1             ' |
                resi1                           ' |
                xcont   cvbs_hl, #2             ' |
                resi1                           ' |
                xcont   cvbs_hh, #1             ' |
                resi1                           ' |
                djnz    cy, #.vhigh
                jmp     pa

.vlow           xcont   cvbs_bs, #1             ' |
                resi1                           ' |
                xcont   cvbs_ll, #2             ' |
                resi1                           ' |
                xcont   cvbs_lh, #1             ' |
                resi1                           ' |
                djnz    cy, #.vlow
                jmp     pa

                fit     $3F0

CON ' TMS9918 constants

    TMSMODE3   = %00000010      ' mode bit 3
    TMSEXTVID  = %00000001      ' external video

    ' register 1 control bits
    TMS4K16K   = %10000000      ' 4/16K RAM
    TMSBLANK   = %01000000      ' screen blank
    TMSINTEN   = %00100000      ' interrupt enable
    TMSMODE1   = %00010000      ' mode bit 1
    TMSMODE2   = %00001000      ' mode bit 2
    TMSSPRSIZE = %00000010      ' sprite size
    TMSSPRMAG  = %00000001      ' sprite magnification

    TMSVSYNC   = %10000000      ' frame sync
    TMS5SPRITE = %01000000      ' 5th sprite
    TMSCOLL    = %00100000      ' coincidence flag

    TMSSPRITES = 32

CON ' VGA constants

    VGA           = 0
    VGA_FPIX      = 12_500_000
    VGA_INTENSITY = 80    '0..128

CON ' CVBS constants

    NTSC            = 1
    NTSC_BLANK_LEV  = 40.0                                  'levels
    NTSC_BLACK_LEV  = NTSC_BLANK_LEV + 7.5
    NTSC_PEAK_LEV   = NTSC_BLANK_LEV + 140.0
    NTSC_SCALE      = 127.0 / NTSC_PEAK_LEV * 128.0
    NTSC_SCALE_COR  = NTSC_SCALE / 1.646                    'CORDIC prescale for IQ modulator

    NTSC_BLANK      = round(NTSC_SCALE * 2.0 * NTSC_BLANK_LEV / NTSC_PEAK_LEV)
    NTSC_BLACK      = round(NTSC_SCALE * 2.0 * NTSC_BLACK_LEV / NTSC_PEAK_LEV)

    NTSC_YR         = round(NTSC_SCALE     *  0.299)        'Y sums to 1
    NTSC_YG         = round(NTSC_SCALE     *  0.587)
    NTSC_YB         = round(NTSC_SCALE     *  0.114)

    NTSC_IR         = round(NTSC_SCALE_COR *  0.596)        'I sums to 0
    NTSC_IG         = round(NTSC_SCALE_COR * -0.274)
    NTSC_IB         = round(NTSC_SCALE_COR * -0.322)

    NTSC_QR         = round(NTSC_SCALE_COR *  0.212)        'Q sums to 0
    NTSC_QG         = round(NTSC_SCALE_COR * -0.523)
    NTSC_QB         = round(NTSC_SCALE_COR *  0.311)

    NTSC_CY         = (NTSC_YR & $FF) << 24 + (NTSC_YG & $FF) << 16 + (NTSC_YB & $FF) << 8 + NTSC_BLACK
    NTSC_CI         = (NTSC_IR & $FF) << 24 + (NTSC_IG & $FF) << 16 + (NTSC_IB & $FF) << 8 + NTSC_BLANK
    NTSC_CQ         = (NTSC_QR & $FF) << 24 + (NTSC_QG & $FF) << 16 + (NTSC_QB & $FF) << 8 + 128

    NTSC_CB         = $809000_01                            'colorburst reference color
    NTSC_CF         = 3_579_545                             'colorburst frequency
    NTSC_CC         = round(227.5 * 4.0)                    'color cycles per line * 4 to preserve fraction
    NTSC_X_TOTAL    = 378

    'NTSC_DOTF       = (NTSC_X_TOTAL * (NTSC_CF * 4 * 128)) / NTSC_CC
    'NTSC_I          = 31 - encod _CLKFREQ
    NTSC_XF         = $030B8EB8 ' ((NTSC_DOTF >> (7 - NTSC_I)) frac (_CLKFREQ << NTSC_I) + 1) >> 1

    PAL             = 2
    PAL_BLANK_LEV   = 43.0                                  'levels
    PAL_BLACK_LEV   = PAL_BLANK_LEV + 0.0
    PAL_PEAK_LEV    = PAL_BLANK_LEV + 140.0
    PAL_SCALE       = 127.0 / PAL_PEAK_LEV * 128.0
    PAL_SCALE_COR   = PAL_SCALE / 1.646                     'CORDIC prescale for IQ modulator

    PAL_BLANK       = round(PAL_SCALE * 2.0 * PAL_BLANK_LEV / PAL_PEAK_LEV)
    PAL_BLACK       = round(PAL_SCALE * 2.0 * PAL_BLACK_LEV / PAL_PEAK_LEV)

    PAL_YR          = round(PAL_SCALE     *  0.299)         'Y sums to 1
    PAL_YG          = round(PAL_SCALE     *  0.587)
    PAL_YB          = round(PAL_SCALE     *  0.114)

    PAL_UR          = round(PAL_SCALE_COR * -0.147)         'I sums to 0
    PAL_UG          = round(PAL_SCALE_COR * -0.289)
    PAL_UB          = round(PAL_SCALE_COR *  0.436)

    PAL_VR          = round(PAL_SCALE_COR *  0.615)         'Q sums to 0
    PAL_VG          = round(PAL_SCALE_COR * -0.515)
    PAL_VB          = round(PAL_SCALE_COR * -0.100)

    PAL_CY          = ( PAL_YR & $FF) << 24 + ( PAL_YG & $FF) << 16 + ( PAL_YB & $FF) << 8 + PAL_BLACK
    PAL_CI          = ( PAL_UR & $FF) << 24 + ( PAL_UG & $FF) << 16 + ( PAL_UB & $FF) << 8 + PAL_BLANK
    PAL_CQ          = ( PAL_VR & $FF) << 24 + ( PAL_VG & $FF) << 16 + ( PAL_VB & $FF) << 8 + 128
    PAL_CA          = (-PAL_VR & $FF) << 24 + (-PAL_VG & $FF) << 16 + (-PAL_VB & $FF) << 8 + 128

    PAL_CB          = $FFC060_01                            'colorburst reference color
    PAL_CF          = 4_433_618                             'colorburst frequency
    PAL_CC          = round(283.75 * 4.0)                   'color cycles per line * 4 to preserve fraction
    PAL_X_TOTAL     = 416

    'PAL_DOTF        = (PAL_X_TOTAL * (PAL_CF * 4 * 128)) / PAL_CC
    'PAL_I           = 31 - encod _CLKFREQ
    PAL_XF          = $0353F900 ' ((PAL_DOTF >> (7 - PAL_I)) frac (_CLKFREQ << PAL_I) + 1) >> 1

DAT             ' SN76489
                org     $000

psg_driver                                           ' Init
                fltl    leftp
                fltl    rightp
                wrpin   res1,leftp
                wrpin   res1,rightp
                wxpin   sampleRate,leftp
                wxpin   sampleRate,rightp
                wypin   dac_center,leftp
                wypin   dac_center,rightp
                drvh    leftp
                drvh    rightp

.loop           call    #sn_getRegisters            ' Main loop
                call    #sn_calcSamples
                call    #sn_mixer
                jmp     #.loop

' Read all SN registers from hub memory and convert
' them to more convenient representations.
sn_getRegisters
                setq    #7
                rdlong  frequency1,#@psg_registers
                shl     frequency1,#22
                shl     frequency2,#22
                shl     frequency3,#22
                wrbyte  #1, #@psg_registers+(6*4+1)
                mov     arg1,noiseFeedback
                and     arg1,#3
                cmp     arg1, #3                    wz      '|
        if_ne   decod   noiseFreq, #26                      '|
        if_ne   shl     noiseFreq, arg1                     '| These 4 lines handles selection of "external" noise frequency on/off
        if_e    mov     noiseFreq, frequency3               '|
                fge     noiseFreq,noiseSubValue   ' fix case where noise freq is zero

                ret

sn_calcSamples                                      ' Calculate SN samples

.AmpN
                test    noiseFeedback, #256     wz ' If bit 8 is zero; Reset noise register
        if_z    mov     noiseValue, #1
.Noise1         sub     oscCounterN, noiseSubValue wc ' Noise generator
        if_nc   waitx   #(7-1)*2 ' wait equivalent time for timing stability
        if_nc   jmp     #.Amp1
                add     oscCounterN, noiseFreq

                test    noiseFeedback, #4       wz ' Is it periodic or white noise ?
        if_nz   test    noiseValue, #NOISE_TAP  wc ' C = White noise !
        if_z    test    noiseValue, #1          wc ' C = Periodic noise !
                bitc    noiseValue, #NOISE_MSB + 1
                shr     noiseValue, #1          wc
                alts    amplitudeN,#psg_amplitudeTable
                negnc   outN, 0-0

.Amp1
.Square1        sub     oscCounter1, oscSubValue          wc ' Square wave generator 1
        if_c    add     oscCounter1, frequency1
        if_c    xor     oscState1, #1                     wz
        if_c    alts    amplitude1,#psg_amplitudeTable
        if_c    negz    out1, 0-0

.Amp2
.Square2        sub     oscCounter2, oscSubValue          wc ' Square wave generator 2
        if_c    add     oscCounter2, frequency2
        if_c    xor     oscState2, #1                     wz
        if_c    alts    amplitude2,#psg_amplitudeTable
        if_c    negz    out2, 0-0

.Amp3
.Square3        sub     oscCounter3, oscSubValue          wc ' Square wave generator 3
        if_c    add     oscCounter3, frequency3
        if_c    xor     oscState3, #1                     wz
        if_c    alts    amplitude3,#psg_amplitudeTable
        if_c    negz    out3, 0-0
                ret

' Mix channels and update FRQA/FRQB PWM-values
sn_mixer
                mov     psgOut, dac_center
                add     psgOut, out1
                add     psgOut, out2
                add     psgOut, out3
                add     psgOut, outN

                testp   rightp   wc
        'if_c    drvh #24  ' light LED if too slow
                testp   rightp   wc
        if_nc   jmp     #$-1
              'waitcnt  waitCounter, sampleRate         ' Wait until the right time to update
                wypin   psgOut, leftp                    ' the PWM values in FRQA/FRQB
                wypin   psgOut, rightp
mixer_ret       ret

' Variables, tables, masks and reference values
psg_amplitudeTable
                long    trunc(AMPLITUDE_LEVEL_0)
                long    trunc(AMPLITUDE_LEVEL_1)
                long    trunc(AMPLITUDE_LEVEL_2)
                long    trunc(AMPLITUDE_LEVEL_3)
                long    trunc(AMPLITUDE_LEVEL_4)
                long    trunc(AMPLITUDE_LEVEL_5)
                long    trunc(AMPLITUDE_LEVEL_6)
                long    trunc(AMPLITUDE_LEVEL_7)
                long    trunc(AMPLITUDE_LEVEL_8)
                long    trunc(AMPLITUDE_LEVEL_9)
                long    trunc(AMPLITUDE_LEVEL_A)
                long    trunc(AMPLITUDE_LEVEL_B)
                long    trunc(AMPLITUDE_LEVEL_C)
                long    trunc(AMPLITUDE_LEVEL_D)
                long    trunc(AMPLITUDE_LEVEL_E)
                long    trunc(AMPLITUDE_LEVEL_F)

leftp           long    AUDIO_LEFT_PIN
rightp          long    AUDIO_RIGHT_PIN
res1            long    P_DAC_75R_2V|P_OE|P_DAC_DITHER_PWM
mask10bit       long    $3ff
val31bit        long    $80000000
val22bit        long    1<<22
val26bit        long    1<<26
sampleRate      long    _CLKFREQ/SAMPLE_RATE

dac_center      long    $7F80
dac_center_hi   long    $7F80<<16

noiseValue      long    1 << NOISE_MSB
oscSubValue     long    OSC_FREQ_CALIBRATION
noiseSubValue   long    OSC_FREQ_CALIBRATION >> 1
oscState1       long    1
oscState2       long    1
oscState3       long    1
oscStateN       long    1

out1            long    0
out2            long    0
out3            long    0
outN            long    0

arg1            res     1
arg2            res     1
oscCounter1     res     1
oscCounter2     res     1
oscCounter3     res     1
oscCounterN     res     1

frequency1      res     1
amplitude1      res     1
frequency2      res     1
amplitude2      res     1
frequency3      res     1
amplitude3      res     1
noiseFeedback   res     1
amplitudeN      res     1


noiseFreq       res     1

psgOut          res     1


waitCounter     res     1
tempValue       res     1

                fit     $1F0

CON ' SN76489 constants

    PSG_FREQUENCY     = float(ZK_CLOCK)    ' Clock frequency input on the emulated SN chip
    VOLUME_CORRECTION = 0.9         ' Volume correction value (0.0 - 1.0)

'SMS, Genesis and Game Gear
'    NOISE_TAP = %1001
'    NOISE_MSB = 15

'SG-1000, OMV, SC-3000H, BBC Micro and Colecovision
    NOISE_TAP = %11
    NOISE_MSB = 14

'Tandy 1000
'    NOISE_TAP = %10001
'    NOISE_MSB = 14

    ' WARNING !!  Don't alter the constants below unless you know what you are doing

    SAMPLE_RATE           = 1_411_200 ' (32 x CD quality) ' Sample rate of SNEcog (176 kHz is maximum for an 80 Mhz propeller)
    OSC_FREQ_CALIBRATION  = trunc((PSG_FREQUENCY/16.0)/float(SAMPLE_RATE)*(float(1<<22)))          ' Calibration of the oscillator frequency
    MAX_AMPLITUDE         = float($7F7F / 4)                      ' maxDACvalue / numberOfChannels (this makes room for maximum "swing" on all channels)
    AMPLITUDE_DAMP_FACTOR = 0.7941                                ' This gives a 2db drop per amplitude level (like the real thing)

    AMPLITUDE_LEVEL_0 = MAX_AMPLITUDE     * VOLUME_CORRECTION
    AMPLITUDE_LEVEL_1 = AMPLITUDE_LEVEL_0 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_2 = AMPLITUDE_LEVEL_1 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_3 = AMPLITUDE_LEVEL_2 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_4 = AMPLITUDE_LEVEL_3 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_5 = AMPLITUDE_LEVEL_4 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_6 = AMPLITUDE_LEVEL_5 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_7 = AMPLITUDE_LEVEL_6 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_8 = AMPLITUDE_LEVEL_7 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_9 = AMPLITUDE_LEVEL_8 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_A = AMPLITUDE_LEVEL_9 * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_B = AMPLITUDE_LEVEL_A * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_C = AMPLITUDE_LEVEL_B * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_D = AMPLITUDE_LEVEL_C * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_E = AMPLITUDE_LEVEL_D * AMPLITUDE_DAMP_FACTOR
    AMPLITUDE_LEVEL_F = 0.0

' Runtime data area

DAT             ' Work area
                orgh

tms_vram        byte    0[16384]                    ' TMS9918 video ram

z80_ram         file    "COLECO.ROM"                ' BIOS rom
                byte    $FF[z80_ram + $4000 - $]    ' Expansion slot
                byte    $FF[z80_ram + $6000 - $]    ' Expansion slot
                byte    $00[z80_ram + $8000 - $]    ' RAM
                                                    ' Cartridge
                'file    "Final Test Cartridge (19xx).col"
                'file    "BC's Quest for Tires (1983) (Sierravision).col"
                'file    "Choplifter (USA, Europe).col"
                'file    "Congo Bongo (USA, Europe).col"
                'file    "Bump 'N' Jump (USA, Europe).col"
                'file    "BurgerTime (USA, Europe).col"
                'file    "Lady Bug (USA, Europe).col"
                'file    "Defender (USA).col"
                'file    "Donkey Kong (USA, Europe).col"
                'file    "Donkey Kong Jr (USA, Europe).col"
                'file    "Galaxian (USA).col"
                'file    "H.E.R.O (USA).col"
                'file    "Frogger (USA).col"
                'file    "Pitfall! (USA).col"
                'file    "Pitfall II - Lost Caverns (USA).col"
                'file    "Popeye (USA).col"
                file    "River Raid (USA).col"
                'file    "Super Cobra (USA).col"
                'file    "Time Pilot (USA, Europe).col"
                'file    "Zaxxon (USA, Europe).col"
                byte    $FF[z80_ram + $10000 - $]

tms_bitmap      ' Memory used as rendered bitmap
