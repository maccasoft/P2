{
    PC-XT 8086 Emulator
    Copyright (c) 2022-23 by Marco Maccaferri <macca@maccasoft.com>

    Memory Map:

        00000-3FFFF ram (256k)
        B8000-BBFFF cga (16k)
        FE000-FFFFF rom (8k)
}
CON

    _CLKFREQ = 320_000_000

    VGA_PIN = 48
    USB_BASE_PIN = 40

    ACTIVITY_LED  = 57
    ERROR_LED     = 56

    SD_CK = 61 ' { O } pin SD Card clock
    SD_CS = 60 ' { O } pin SD Card select
    SD_DI = 59 ' { O } pin SD Card MOSI
    SD_DO = 58 ' { I } pin SD Card MISO

    A_LED = 56 ' A drive motor LED
    B_LED = 57 ' B drive motor LED

    CPU_PIN = 7
    FDC_PIN = 6

DAT             ' Startup
                org     $000

                asmclk

                rep     #1, #16     ' allocate all locks, to be safe...
                locknew pa

                coginit #5, ##@video_driver
                coginit #4, ##@usb_host_start

                coginit #3, ##@bus_arbiter

                coginit #2, ##@nec765
                coginit #1, ##@i8254
                coginit #0, ##@i8086

                orgh

                ' DMA
dma             long    $0000_0000      ' DMA Address / Counter registers
                long    $0000_0000
                long    $0000_0000
                long    $0000_0000
                '        |||| ||||
                '        |||| ++++------- Address
                '        ++++------------ Count

dma_page        byte    $00[4]          ' DMA Page registers

dma_ctl         long    %000000000000_1111_00000100_00000000   ' DMA control registers
                '                     |||| |||||||| ||||||||
                '                     |||| |||||||| ||||++++------ Channel 3..0 has reached TC
                '                     |||| |||||||| ++++---------- Channel 3..0 request
                '                     |||| ++++++++--------------- Command register
                '                     ++++------------------------ Mask bits

dma_mode        long    %00000000_00000000_00000000_00000000    ' DMA mode registers

                ' CGA I/O registers
cga_io_03D4     byte    $00         ' MC6845 Address
cga_io_03DA     byte    %00000000   ' Read: Status Register
                                    '   0: retrace.  1=display in vert or horiz retrace.
                                    '   1: 1=light pen trigger is triggered; 0=armed
                                    '   2: 1=light pen switch is open; 0=closed
                                    '   3: 1=vertical sync pulse is occurring.  Display is
                                    '                 in vertical retrace--access won't cause "snow"
cga_io_03D8     byte    %00000000   ' Mode Select Register (BIOS keeps current value at 40:0065)
                                    '   0: width (text modes): 0=40 clms; 1=80 clms
                                    '   1: 1=enable graphics modes; 0=text modes
                                    '   2: 1=disable color burst on composite monitor
                                    '   3: 1=enable video signal; 0=disable (all black)
                                    '   4: dot resolutn: 0=320 2-bit dots; 1=640 1-bit dots
                                    '   5: enable blink: 1=text attribute bit 7 blinks fgnd
                                    '                    0=attr bit 7 is bkgd intensity
cga_io_03D9     byte    %00000000   ' Write: Color Select Register
                                    '   0-3: color. Text modes: IRGB of border
                                    '               Graphics modes: IRGB of background
                                    '   4: intensity. Text: bkgd intensity
                                    '                 Mid-res graphics: pixel intensity
                                    '   5: blue. Select grafx palette 0 or 1 (1 adds blue)

                ' MC6845 registers
cga_io_mc6845                   '         Unit        R/W         Name                  Size    40x25   80x25   Graphics
                byte    $00     ' R0      Char        Write       Hor. Total            8       38      71      38
                byte    $00     ' R1      Char        Write       Hor. Disp.            8       28      50      28
                byte    $00     ' R2      Char        Write       Hor. Sync Pos.        8       2D      5A      2D
                byte    $00     ' R3      Char        Write       Hor. Sync Width       4       0A      0A      0A
                byte    $00     ' R4      Char Row    Write       Vert. Total           7       1F      1F      7F
                byte    $00     ' R5      Scan Line   Write       Vert. Total Adj.      5       06      06      06
                byte    $00     ' R6      Char Row    Write       Vert. Disp.           7       19      19      64
                byte    $00     ' R7      Char Row    Write       Vert. Sync Pos.       7       1C      1C      70
                byte    $00     ' R8                  Write       Interlace Mode        2       02      02      02
                byte    $00     ' R9      Scan Line   Write       Max Scan Line Addr.   5       07      07      01
                byte    $00     ' R10     Scan Line   Write       Cursor Start          7 (5)   06      06      06
                byte    $07     ' R11     Scan Line   Write       Cursor End            5       07      07      07
                byte    $00     ' R12                 Write       Start Add. (H)        6       00      00      00
                byte    $00     ' R13                 Write       Start Add. (L)        8       00      00      00
                byte    $00     ' R14                 Read/Write  Cursor Add. (H)       6       XX      XX      XX
                byte    $00     ' R15                 Read/Write  Cursor Add. (L)       8       XX      XX      XX
                byte    $00     ' R16                 Read        Light Pen (H)         6       XX      XX      XX
                byte    $00     ' R17                 Read        Light Pen (L)         8       XX      XX      XX

                ' Keyboard
kbd_data        byte    $00

                ' 8259A Interrupt Lines
pic_irq         byte    %00000000
                '         | || ||
                '         | || |+-- 0: Timer0
                '         | || +--- 1: Keyboard
                '         | |+----- 3: Serial Interface 2
                '         | +------ 4: Serial Interface 1
                '         +-------- 6: Floppy Disk Controller

                alignl

                ' 8254 Programmable Interval Timer
tmr0            byte    %00110000   ' Control registers
tmr1            byte    %00110000
tmr2            byte    %00110000
                byte    %00111000
                '          ||||||
                '          |||||+------ 0: Timer0 enable
                '          ||||+------- 1: Timer1 enable
                '          |||+-------- 2: Timer2 enable
                '          ||+--------- 3: Timer0 reload
                '          |+---------- 4: Timer1 reload
                '          +----------- 5: Timer2 reload

tmr0_cnt        word    $0000       ' Counter register
tmr0_reload     word    $0000       ' Reload counter registers

tmr1_cnt        word    $0000       ' Counter register
tmr1_reload     word    $0000

tmr2_cnt        word    $0000       ' Counter register
tmr2_reload     word    $0000       ' Reload counter registers

                ' NEC765 Floppy Disk Controller
fdc_dor         byte    %00000000
fdc_msr         byte    %00000000

fdc_fifo        byte    $00[16]
fdc_fifo_head   byte    0
fdc_fifo_tail   byte    0

fdc_cmd         byte    $00[16]
fdc_cmd_len     byte    0

                alignl

DAT             ' Bus arbiter
                org     $000
bus_arbiter
                dirl    #CPU_PIN
                wrpin   ##SP_REPO1_MODE, #CPU_PIN
                setse1  #%001_000000 | CPU_PIN
                dirh    #CPU_PIN

                dirl    #FDC_PIN
                wrpin   ##SP_REPO1_MODE, #FDC_PIN
                setse2  #%001_000000 | FDC_PIN
                dirh    #FDC_PIN

                pollse1                     ' probabily doesn't matter...
                pollse2

                wrword  #0, ##@ram_00000 + $00472 ' force cold boot
                cogatn  #%00000101          ' signal we are ready to CPU and FDC

s_loop
                mov     s_source, #CPU_PIN  ' assume CPU request by default after each request returns
                setd    s_end_wait, #%000010100 ' waitse1

                rep     #2, #0
                jse1    #cpu_handler
                jse2    #fdc_handler
                nop                         ' needed to avoid instruction skip?

fdc_handler
                mov     s_source, #FDC_PIN
                setd    s_end_wait, #%000010101 ' waitse2
cpu_handler ' alias
s_request
                rdpin   s_ea, s_source
                bitl    s_ea, #31       wcz ' get write and clear it to avoid address mismatch
        if_c    jmp     #s_write

                'and     s_ea, ##$F_FFFF
                mov     pa, s_ea
                shr     pa, #12             ' get 4k-bank number
                                            ' 00000
                cmp     pa, #$40        wcz ' 3FFFF ram (256k)
        if_b    jmp     #.ram
                cmp     pa, #$B8        wcz ' B8000
        if_ae   cmpr    pa, #$BC-1      wcz ' BBFFF video ram (16k)
        if_ae   jmp     #.cga
                cmp     pa, #$F6        wcz ' F6000
        if_ae   jmp     #.rom               ' FFFFF rom (32k+8k)

                'debug("??? (R): ", uhex_long(s_ea),uhex_byte(s_tmpb))
                mov     s_tmpb, #$FF
                jmp     #s_end
.ram
                add     s_ea, s_rambase
                rdbyte  s_tmpb, s_ea
                'debug("RAM (R): ", uhex_long(s_ea),uhex_byte(s_tmpb))
                jmp     #s_end
.cga
                and     s_ea, s_3fffh
                add     s_ea, s_cgabase
                rdbyte  s_tmpb, s_ea
                'debug("CGA (R): ", uhex_long(s_ea),uhex_byte(s_tmpb))
                jmp     #s_end
.rom
                add     s_ea, s_rombase
                rdbyte  s_tmpb, s_ea
                'debug("ROM (R): ", uhex_long(s_ea),uhex_byte(s_tmpb))
                jmp     #s_end

s_write
                getbyte s_tmpb, s_ea, #0    ' get byte to write
                shr     s_ea, #8            ' shift address into position

                'and     s_ea, ##$F_FFFF
                mov     pa, s_ea
                shr     pa, #12             ' get 4k-bank number
                                            ' 00000
                cmp     pa, #$40        wcz ' 3FFFF ram (256k)
        if_b    jmp     #.ram
                cmp     pa, #$B8        wcz ' B8000
        if_ae   cmpr    pa, #$BC-1      wcz ' BBFFF video ram (16k)
        if_ae   jmp     #.cga

                'debug("??? (W): ", uhex_long(s_ea),uhex_byte(s_tmpb),dly(#500))
                jmp     #s_end
.ram
                add     s_ea, s_rambase
                wrbyte  s_tmpb, s_ea
                'debug("RAM (W): ", uhex_long(s_ea),uhex_byte(s_tmpb),dly(#500))
                jmp     #s_end
.cga
                and     s_ea, s_3fffh
                add     s_ea, s_cgabase
                wrbyte  s_tmpb, s_ea
                'debug("CGA (R): ", uhex_long(s_ea),uhex_byte(s_tmpb),dly(#500))
                jmp     #s_end

s_end
                wxpin   s_tmpb, s_source
s_end_wait      waitse1                     ' changed to waitse1/2 in the request handler
                jmp     #s_loop

s_rambase       long    @ram_00000
s_cgabase       long    @ram_00000 + RAM_SIZE
s_rombase       long    @rom_F6000 - $F6000

s_3fffh         long    $3FFF
s_ffffh         long    $FFFF
s_eamask        long    $FFFFF

s_source        res     1
s_ea            res     1
s_tmpb          res     1

DAT             ' USB Host driver
                org     $000

usb_host_start
                mov     hcog_base_addr, ptrb

                mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
                shr     htmp, #2                        ' so byte->long for the lut cell count
                loc     pb, #@hlut_start - @usb_host_start
                add     pb, hcog_base_addr
                setq2   htmp
                rdlong  0, pb                           ' Do the hub->lut copy

                loc     pb, #@usb_host_init - @usb_host_start
                add     pb, hcog_base_addr
                jmp     pb                              ' Initialize host and enter main processing loop

'------------------------------------------------------------------------------
' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
' special because the receiving function must not respond with either STALL or
' NAK, and must accept the DATAx packet that follows the SETUP token. If a
' non-control endpoint receives a SETUP token, or the function receives a
' corrupt packet, it must ignore the transaction
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data struct.
' On exit:
'   retval - PID_ACK on success, otherwise error code.
'------------------------------------------------------------------------------
txn_setup
                setbyte ep_addr_pid, #PID_SETUP, #0
                mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
                bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
                mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
                mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
.setup
                call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
                cmp     retval, #PID_ACK        wz
        if_z    ret
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    ret
                mov     ptra, pa                        ' Restore SETUP's DATAx pointer
                jmp     #.setup

'------------------------------------------------------------------------------
' IN/INTERRUPT transaction.
' Possible function response: STALL or NAK handshake, or DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
' On exit:
'------------------------------------------------------------------------------
txn_in
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                setbyte ep_addr_pid, #PID_IN, #0
                call    #utx_token                      ' Put IN request on the bus

                ' Fall through to urx_packet

'------------------------------------------------------------------------------
' Wait for a packet from a device/function. As host, the only two packet types
' received are handshakes and IN DATAx.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'     returned.
'------------------------------------------------------------------------------
urx_packet
                rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
                testb   urx, #SOPB              wc
        if_c    jmp     #urx_packet
                getct   hct2
                addct2  hct2, tat_wait                  ' Start the response turn-around timer
                bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
                mov     newb_flg, #0                    ' Initialize for multi-byte read
.wait_sop
                rdpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #.get_pid
                jnct2   #.wait_sop
        _ret_   mov     retval, #ERR_TAT
.get_pid
                call    #urx_next
                testb   urx, #BUS_ERRB          wc
        if_nc   jmp     #.chk_pid
        _ret_   mov     retval, #ERR_URX
.chk_pid
                cmp     retval, #PID_ACK        wz
        if_nz   cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
                testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
                cmp     retval, #PID_DATA0      wz
   if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
   if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
                cmp     retval, #PID_DATA1      wz
   if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
   if_z_and_nc  jmp     #.ack_resend
        _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
.ack_resend
                rqpin   urx, dm
                testb   urx, #EOPB              wc
        if_nc   jmp     #.ack_resend
                mov     retval, #PID_ACK
                call    #utx_handshake                  ' Send handshake PID and return to caller
        _ret_   mov     retval, #ERR_DATAX_SYNC
.chk_eop
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
                call    #urx_next                       ' Low-speed requires an additional read to get EOP status
                testb   hstatus, #EOPB          wc
        if_c    jmp     #.idle                          ' Low-speed EOP seen
                testb   urx, #BUS_ERRB          wz
        if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
        if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
                ret
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
                ret

'------------------------------------------------------------------------------
' Send a token packet with CRC5 checksum of address and endpoint. It is the
' responsibility of the caller to append the appropriate inter-packet delay,
' if one is required.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - packed with the PID, address and endpoint.
' On exit:
'------------------------------------------------------------------------------
utx_token
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #utx_token
                testb   hstatus, #DWNSTRM_HUBB  wc
        if_c    call    #utx_pre
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     htmp, ep_addr_pid               ' Preserve the PID and destination
                mov     pkt_cnt, #3
.next_byte
                getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
                shr     htmp, #8                        ' Shift to next byte to send
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   utx, dm
        _ret_   djnz    pkt_cnt, #.next_byte

'------------------------------------------------------------------------------
' SETUP/OUT/INTERRUPT transaction.
' Possible function response in order of precedence: STALL, ACK, NAK.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
'   PTRA - start address of the data buff/struct that has the bytes to send.
'   pkt_data - count of DATAx payload bytes to send.
' On exit:
'------------------------------------------------------------------------------
txn_out
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                call    #utx_token                      ' Put SETUP/OUT token on the bus
                rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
                mov     pkt_cnt, pkt_data

                ' Fall through to utx_data

'------------------------------------------------------------------------------
' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
' calculated while the data byte is being shifted out. Since data stage
' success/fail is not determined until the status stage of the transaction,
' this routine is only concerned about the current DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - hub start address of the data to read.
'   pkt_cnt - data payload size.
' On exit:
'------------------------------------------------------------------------------
utx_data
                rqpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #utx_data
                mov     hctwait, ip_delay
                call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
                testb   hstatus, #DWNSTRM_HUBB  wc
        if_c    call    #utx_pre
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                bmask   crc, #15                        ' Prime the CRC16 pump
                testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
        if_nc   mov     utx, #PID_DATA0
        if_c    mov     utx, #PID_DATA1
                call    #utx_byte                       ' No CRC calc done on PID
                cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
        if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
.read_byte
                rfbyte  utx                             ' Fetch data byte
                call    #utx_byte
                rev     utx                             ' Calculate CRC while the data is shifting out
                setq    utx                             ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
                djnz    pkt_cnt, #.read_byte
.send_crc
                bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
                getbyte utx, crc, #0
                call    #utx_byte
                getbyte utx, crc, #1
                call    #utx_byte                       ' Last CRC byte out
                jmp     #urx_packet                     ' Handle function response/error and back to caller

'------------------------------------------------------------------------------
' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
' payload bytes are received. The routine reads bytes until EOP is detected and
' expects that the packet includes at least the CRC word.
'
' In control transfers, it's possible to recieve fewer data bytes than what
' was requested, which makes it difficult to determine where the data stops
' and the CRC word begins. So the CRC calculation is done on every byte of the
' packet, including the CRC word. The CRC value should then be equal to the
' USB-16 expected residual value of 0xB001.
'
' The routine writes the IN packet data to a static max_packet_size buffer
' so the caller can verify IN success before writing the data to its final
' destination.
'------------------------------------------------------------------------------
' On entry:
'   pkt_data - max byte count expected to be in the packet.
'   newb_flg - signals new byte ready when toggled.
' On exit:
'   pkt_cnt - actual number of bytes read.
'------------------------------------------------------------------------------
urx_data
                mov     htmp2, pb
                mov     pb, urx_buff_p
                wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
                mov     pb, htmp2
                bmask   crc, #15                        ' Prime the CRC16 pump
                mov     pkt_cnt, #0                     ' Keep track of payload bytes received
                mov     pkt_tmp, pkt_data
                add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
.wait_byte
' In-line rx for max speed
                rqpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   jmp     #.get_byte                      ' New byte!
                testb   urx, #EOPB              wc
        if_c    jmp     #.chk_crc                       ' At end-of-packet
                jmp     #.wait_byte
.get_byte
                getbyte retval, urx, #1                 ' New byte from smart pins
                wfbyte  retval                          ' Add it to the data buffer
                rev     retval                          ' Calculate CRC while next byte is shifting in
                setq    retval                          ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
.end_crc
                add     pkt_cnt, #1
                cmp     pkt_cnt, pkt_tmp        wcz
        if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
        if_a    ret
' For full-speed at 80MHz, the time it takes to do the final byte write and
' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
' to miss it, so cheat a bit and look for SOP clear here.
                rqpin   urx, dm
                testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
        if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
.chk_crc
                sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
                xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
        if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
                mov     retval, #PID_ACK
                mov     hctwait, ip_delay
                call    #poll_waitx

                ' Fall through to utx_handshake

'------------------------------------------------------------------------------
' Transmit a handshake PID. The routine assumes that the bus is IDLE and
' the appropriate IP delay has been inserted.
'------------------------------------------------------------------------------
' On entry:
'   retval - handshake PID to send.
' On exit:
'   retval unchanged.
'------------------------------------------------------------------------------
utx_handshake
                testb   hstatus, #DWNSTRM_HUBB  wc
        if_c    call    #utx_pre
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                mov     utx, retval
                call    #utx_byte                       ' Send handshake PID
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
                mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
                jmp     #poll_waitx

'------------------------------------------------------------------------------
' Wait for the USB tx buffer to empty and feed it a new byte.
'------------------------------------------------------------------------------
' On entry:
'   utx - byte to transmit.
' On exit:
'------------------------------------------------------------------------------
utx_byte
                testp   dp                      wc
        if_nc   jmp     #utx_byte
                akpin   dp
                waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
        _ret_   wypin   utx, dm

'------------------------------------------------------------------------------
' Fetch the next data byte of a packet. Always check receiver status for EOP.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the byte read.
'   urx - the receiver status. The caller must check the hstatus reg EOP flag
'     on return. If EOP is set, the byte in reg retval remains as the last byte
'     received.
'------------------------------------------------------------------------------
urx_next
                rdpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
        if_nz   ret                                     ' New byte is priority, so return now
                testb   urx, #SOPB              wc
                testb   urx, #BUS_ERRB          wz
   if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
        if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
                ret

'------------------------------------------------------------------------------
' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
' the data used for the USB-5 CRC lookups. The token packet is three bytes in
' length, and the PID is not included in the CRC calculation:
'  CRC5  FRAME_NUMBER SOF (full-speed)
'  CRC5  ENDP ADDRESS PID
' %00000_1111_1111111_xxxxxxxx
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - stuffed with the function endpoint, address and
'     SETUP/IN/OUT/SOF PID according to the USB standard.
' On exit:
'   ep_addr_pid - CRC value appended to the packet.
'------------------------------------------------------------------------------
calc_crc5
                and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
                mov     htmp, ep_addr_pid
                shr     htmp, #8                        ' PID not included in CRC calc
                mov     crc, #$1f                       ' Initial CRC5 value
                rev     htmp                            ' Input data reflected
                setq    htmp                            ' CRCNIB setup for data bits 0..7
                crcnib  crc, #USB5_POLY
                crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
                shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
                crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                xor     crc, #$1f                       ' Final XOR value
                shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
        _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home

'------------------------------------------------------------------------------
' Full-speed/low-speed frame timing interrupt service routine.
'------------------------------------------------------------------------------
isr1_fsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                mov     utx, #PID_SOF
                wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
                call    #utx_byte                       ' Send token PID byte
                mov     icrc, #$1f                      ' Prime the CRC5 pump
                mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
                rev     sof_pkt                         ' Input data reflected
                setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
                crcnib  icrc, #USB5_POLY
                crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
                getbyte utx, frame, #0                  ' Send the low byte of the frame number
                call    #utx_byte
                shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
                rep     #2, #3                          ' Three data bits left to process
                shl     sof_pkt, #1             wc
                crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
                xor     icrc, #$1f                      ' Final XOR value
                getbyte utx, frame, #1                  ' Send remaining frame number bits
                shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
                or      utx, icrc
                call    #utx_byte                       ' Last start-of-frame byte is on the wire
                mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
                jmp     #isr1_wait
isr1_lsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
                mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
isr1_wait
                rqpin   utx, dm
                testb   utx, #SOPB                 wc
        if_c    jmp     #isr1_wait
                add     frame, #1                       ' Next frame# and check for wrap around
                zerox   frame, #10
                waitx   isrtmp1                         ' Make sure bus is idle
                reti1

'------------------------------------------------------------------------------
' Wait for a window within the 1ms frame boundary that will ensure that a
' transaction will complete before the next frame is triggered.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
wait_txn_ok
                getct   htmp2
                sub     htmp2, iframe_ct_base
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    cmp     htmp2, _txn_ok_ls_      wcz
        if_nc   cmp     htmp2, _txn_ok_fs_      wcz
        if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
                ret

'------------------------------------------------------------------------------
' A device connection was detected, or a bus reset was requested by the USB
' client. Set the appropriate smart pin FS/LS speed mode to match the device
' and perform a reset sequence prior to device enumeration.
'------------------------------------------------------------------------------
dev_reset
                rqpin   urx, dm
                testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
        if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
        if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
reset
                setint1 #0                              ' Don't want frame interrupt while in reset
                wypin   #OUT_SE0, dm                    ' Assert bus reset
                waitx   _reset_hold_                    ' Spec is >= 10ms
                wypin   #OUT_IDLE, dm
                mov     frame, #0                       ' Reset the frame timespan count
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
                add     htmp, #36
                setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
.framewait
                cmp     frame, htmp             wcz
        if_b    jmp     #.framewait
                ret

'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - source address.
'   PB - destination address.
'   hr0 - length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
hmemcpy
                rdbyte  htmp, ptra++
                wrbyte  htmp, pb
                add     pb, #1
        _ret_   djnz    hr0, #hmemcpy

'------------------------------------------------------------------------------
' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
' loop until the errant device is disconnected.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
host_error
                drvl    host_error_led
                jmp     #host_reset                     ' See if it works...

' USB commands and error codes
cmd_data        long    0
usb_err_code    long    ERR_NONE

' Parameters block assigned at cog startup
dm              long    USB_BASE_PIN + 2    ' Client defines the basepin for four consecutive USB port pins
dp              long    USB_BASE_PIN + 3
usb_event_pin   long    USB_BASE_PIN        ' Host event reporting uses a long repository smart pin
host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
hid_report_p    long    0, 0[4]
hub_descr_p     long    0
urx_buff_p      long    0
dev_desc_buff_p long    0
con_desc_buff_p long    0
cache_start_p   long    0
cache_end_p     long    0

hdev_init_start
hdev_port       long    0
hdev_next_datax long    0, 0
hub_intf_num    long    0
hub_next_datax  long    0
hub_status_chg  long    0
hub_port_status long    0
kb_intf_num     long    0
kb_interval     long    0
kb_in_max_pkt   long    0
kb_max_index    long    0
kb_led_states   long    0
hdev_init_end

' Initialized at cog startup:
save_sysclk     long    0         ' Save the current sysclock as the client may change it
hcog_base_addr  long    0         ' This object's start address in hub, read from PTRB at cog creation
iframe_ct_new   long    0
iframe_ct_base  long    0
p2rev_val       long    P2RevB
utx_tweak       long    0         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
' This register block is reset to zero when a USB device connects
hreg_init_start
hstatus         long    0         ' Host status flags
hctwait         long    0         ' Poll-based wait clocks
ip_delay        long    0         ' Inter-packet delay in bit periods for connected device speed
tat_wait        long    0         ' Maximum bus turn-around time in bit periods for connected device speed
nak_retry       long    0         ' NAK retry count, unlimited retries if zero
xfer_retry      long    0         ' Control transfer retry count
retry           long    0         ' Transaction retry count
utx             long    0         ' Byte to transmit on USB
urx             long    0         ' LSByte receiver status flags, MSByte received data
newb_flg        long    0         ' Receive "new byte" bit toggle detector
max_pkt_size    long    0         ' Maximum payload bytes allowed, likely to change on device connect.
total_data      long    0         ' Total bytes to tx/rx in a transfer data stage
stage_data      long    0         ' Count of bytes sent/received so far during a data stage.
pkt_data        long    0         ' Payload size of an OUT packet or bytes received on IN
frame           long    0         ' USB 1ms frame counter value
sof_pkt         long    0         ' ISR frame# packet and CRC5
icrc            long    0         ' Only used by the 1ms frame output ISR routine
pkt_cnt         long    0         ' Count of DATAx packet payload bytes
crc             long    0         ' Used for CRC16 calculation
ep_addr_pid     long    0         ' Endpoint and device addresses for connected device
retval          long    0         ' Global success/fail return parameter
context_retval  long    0         ' Operation contextual return parameter
' Device stuff
hdev_id         long    0
hdev_bcd        long    0
hdev_type       long    0, 0      ' Configured device indicator
' Keyboard/mouse stuff
hctrl_ep_addr   long    0
hctrl_max_pkt   long    0
hconfig_base    long    0
hcon_tot_len    long    0         ' Size of the complete config descriptor chain
hdev_intf_idx   long    0         ' Used during verbose descriptor terminal output
hdev_class      long    0
hdev_subclass   long    0
hdev_protocol   long    0
hsearch_key     long    0         ' Descriptor type to search for in the config chain
hnext_desc      long    0         ' Offset from the config descriptor start address to the next descriptor in the chain
hhub_ctrl_ep    long    0         ' Hub control endpoint address
hhub_ep_addr    long    0         ' Hub interface endpoint address
hkbd_ctrl_ep    long    0         ' Keyboard control endpoint address
hkbd_ep_addr    long    0         ' Keyboard interface endpoint address
hkbd_poll_cnt   long    0         ' Poll interval counter used for key auto-repeat
hkbd_ledstates  long    0         ' Off/on state of keyboard LEDs
hdev_ep_addr    long    0, 0[4]
hdev_out_addr   long    0
hreg_init_end
' Variables dependent on the system freqency
_var_64_lower_  res     1
_var_64_upper_  res     1
_12Mbps_        res     1
_1_5Mbps_       res     1
_1ns16fp_       res     1         ' 1ns as 32,16 fixed point
_1us_           res     1         ' 1us
_10us_          res     1         ' 10us
_33us_          res     1         ' 33us
_txn_err_       res     1         ' 250us
_500us_         res     1         ' 500us
_txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
_txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
_ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
_ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
_tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
_tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
_preamble_wait_ res     1
_1ms_           res     1         ' 1ms
_2ms_           res     1         ' 2ms
_suspend_wait_  res     1         ' 3ms
_4ms_           res     1         ' 4ms
_xfer_wait_     res     1         ' 5ms
_8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
_reset_hold_    res     1         ' 15ms
_resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
_21ms_          res     1         ' 21ms
_100ms_         res     1         ' 100ms
_500ms_         res     1         ' 500ms
_pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
_frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'------------------------------------------------------------------------------
_usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
_usb_d_ls_nco_  res     1
_usb_h_fs_nco_  res     1
_usb_d_fs_nco_  res     1
'------------------------------------------------------------------------------
' Scratch registers
htmp            res     1         ' Scratch registers whose context remains within the same code block
htmp1           res     1
htmp2           res     1
htmp3           res     1
hrep            res     1         ' Repeat count
hsave0          res     1         ' Subroutine parameter saves
hsave1          res     1
hsave2          res     1
isrtmp1         res     1
pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
hr0             res     1         ' Multi-purpose registers
hr1             res     1
hr2             res     1
hr3             res     1
hpar1           res     1         ' Routine entry/exit parameters
hpar2           res     1
hpar3           res     1
hct2            res     1         ' Function response bus turn-around timer
hct3            res     1         ' Keyboard/mouse poll timer
mod_cnt         res     1         ' Used in idle loops

                fit     $1F0

DAT             ' USB Host LUT execution
                org     $200
hlut_start

'------------------------------------------------------------------------------
' Full-speed is the host's native speed, so all that is needed is to set the FS
' settings to startup defaults.
'------------------------------------------------------------------------------
' On entry:
' On exit: Save/restore caller C flag state if C is changed in this routine!
'------------------------------------------------------------------------------
set_speed_full
                mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
'                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' When a low-speed device connects, the D-/D+ signaling is inverted. If there
' is a downstream hub connected (not yet implemented), the baud generator
' remains set at the full-speed rate, but signaling is switched to low-speed,
' which reverses the D-/D+ polarity. The polarity can be changed without
' putting the smart pins into reset.
'------------------------------------------------------------------------------
' On entry:
' On exit: CZ flags restored to caller states
'------------------------------------------------------------------------------
set_speed_low
                test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
        if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
                testb   p2rev_val, #0           wc      ' P2 Revision is either %0001 (A) or %0010 (B+)
        if_c    dirl    dm                              ' P2RevA needs to be completely reconfigured
        if_c    dirl    dp
        if_c    wrpin   ##USB_V1HMODE_LS, dm            ' Low-speed signaling is always used
        if_c    wrpin   ##USB_V1HMODE_LS, dp
        if_c    wxpin   _1_5Mbps_, dm                   ' Set 1.5Mbs baud if no downstream hub
        if_c    dirh    dm
        if_c    dirh    dp
        if_nc   wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
                bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' Perform configuration stuff required when a device intitially connects.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
on_connect
                mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
                call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
.retry
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
        if_nc   mov     hpar1, #USB_SPEED_FULL
                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.get_dev_desc
                mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
                call    #poll_waitx
                sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
        if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
                call    #reset                          ' Try another reset to see if the device responds
                jmp     #.retry
.get_dev_desc
                mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
                call    #reset
                loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
                add     ptra, hcog_base_addr
                wrword  #8, ptra[wValue]                ' Only support one device port at this time
                call    #control_write                  ' Execute SetAddress()
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctwait, _8ms_
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
                call    #calc_crc5
                loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
                add     ptra, hcog_base_addr
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
                mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
                rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
                mov     hctwait, _500us_
                call    #poll_waitx
                loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   ret
                mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
                mov     hconfig_base, ptra              ' Will need this for configuration
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    mov     retval, #ERR_CONFIG_FAIL
        if_b    jmp     #host_error
                loc     pa, #@init_kbdm_data - @usb_host_start
                add     pa, hcog_base_addr
                call    pa
                loc     pa, #@hparse_con_desc - @usb_host_start
                add     pa, hcog_base_addr
                jmp     pa

'------------------------------------------------------------------------------
' Perform a control read transaction (Section 8.5.3, Figure 8-37).
' Status reporting is always in the function-to-host direction.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data in hub.
'   PB - start address of the buffer/struct to be written to during the IN data
'     stage.
'   ep_addr_pid - device address, endpoint and CRC5.
' On exit:
'   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'     contains the count of data stage bytes actually received, which must
'     always be <= the count requested.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_read
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb                       ' Save dest buffer pointer
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                mov     nak_retry, ##IN_NAK_RETRIES
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
.nak_retry
                mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
.in_retry
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' Commit on ACK
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak_retry                     ' Function not ready to send data
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.in_retry                      ' Bus error retry
                ret                                     ' The transfer has failed
.commit
                cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
        if_z    jmp     #.pre_status                    ' and also end-of-data
                mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
                mov     hr0, pkt_cnt
                cmp     ptra, pb                wz
        if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
                add     stage_data, pkt_cnt             ' Update bytes received on commit
                cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
        if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
                cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
        if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
        if_a    mov     retval, #ERR_PACKET
        if_a    mov     context_retval, retval          ' In this case overall and context are the same
        if_a    ret                                     ' Caller must handle ERR_PACKET
                bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
                jmp     #.data                          ' Start next IN transaction
.pre_status
                mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
                setbyte ep_addr_pid, #PID_OUT, #0
                mov     pkt_data, #0
                bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
                mov     nak_retry, ##OUT_NAK_RETRIES
.out_retry
                call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
                cmp     retval, #PID_ACK        wz
        if_z    ret                                     ' All is good when ACK
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
                ret                                     ' Caller must handle transfer retirement
' I've encountered transfer STALL, even though the data looks correct, and
' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
' ControlRead() transfer gets things unstuck most of the time...
.xfer_retry
                mov     hctwait, _xfer_wait_
                call    #poll_waitx
                call    #wait_txn_ok
                mov     ep_addr_pid, hpar1
                mov     ptra, hpar2
                mov     pb, hpar3
                djnz    xfer_retry, #.xfer_start
                mov     context_retval, retval          ' Preserve the USB error code
        _ret_   mov     retval, #ERR_XFER_RETRY

'------------------------------------------------------------------------------
' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
' reporting is always in the function-to-host direction. It is assumed that
' the SETUP data struct is filled with the required values.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to the start of the struct for the SETUP data.
'   PB - the start address of the struct/buffer to be read for the OUT data
'     stage.
'   ep_addr_pid - the proper CRC'd address and endpoint to use.
' On exit:
'   retval - used to convey the success/failure of each stage.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_write
                testb   ep_addr_pid, #31        wc
        if_c    bith    hstatus, #DWNSTRM_HUBB
        if_c    bith    _usb_h_ls_nco_, #14

                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
.out_retry
                mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
                call    #txn_out
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit                        ' Function got the data
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
        if_nz   jmp     #.out_retry
                jmp     #dwnstream_reset                ' Caller must handle transfer retirement
.commit
                mov     pb, ptra                        ' Save the current buffer/struct location
                add     stage_data, pkt_data
                cmp     stage_data, total_data  wz
        if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
        if_nz   jmp     #.data                          ' More data to send
pre_status_in
                bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.status_retry
                mov     pkt_data, #0
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
        if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
        if_z    jmp     #dwnstream_reset                ' Control Write finished
                cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
        if_z    jmp     #dwnstream_reset
                call    #retry_wait                     ' NAK or bus error, so delay a bit
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.status_retry
'                ret                                     ' Caller must handle transfer retirement

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - The function address and endpoint for the IN request.
'   hpar2 - Address of the IN data buffer
'   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
' On exit:
'   retval - the result of the operation.
'   hpar3 - the count of IN data bytes actually received.
'------------------------------------------------------------------------------
do_int_in
                testb   ep_addr_pid, #31        wc
        if_c    bith    hstatus, #DWNSTRM_HUBB
        if_c    bith    _usb_h_ls_nco_, #14

                getword htmp, hpar3, #0
                cmp     htmp, #PID_DATA0        wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
                mov     retry, #TXN_RETRIES
.retry
                getword pkt_data, hpar3, #1             ' IN max packet length
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK if data received
        if_z    jmp     #.commit
                cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
        if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
        if_z    jmp     #.post_ret                      ' The caller must handle either
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    jmp     #.post_ret
                jmp     #.retry
.commit
                mov     ptra, urx_buff_p                ' Copy the rx buffer
                mov     pb, hpar2                       ' to the destination buffer
                mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
        if_nz   cmp     ptra, pb                wz
        if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
.post_ret
                mov     hpar3, pkt_cnt                  ' IN bytes actually received

'------------------------------------------------------------------------------
' Resets the downstream hub port to FS
'------------------------------------------------------------------------------
dwnstream_reset
                testb   ep_addr_pid, #31        wc
        if_nc   ret                                     ' No LS device, reset not needed
                bitl    _usb_h_ls_nco_, #14
                bitl    hstatus, #DWNSTRM_HUBB
                wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods

'------------------------------------------------------------------------------
' The one millisecond frame timer is implemented as an interrupt service
' routine. Since this timing is critical, care must be taken to avoid any
' instructions that can delay the interrupt branch, which will likely upset
' the timer. WAITX is among those instructions, so any time you're inside
' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'------------------------------------------------------------------------------
' On entry:
'   hctwait - wait interval in sysclocks.
' On exit:
'------------------------------------------------------------------------------
poll_waitx
                getct   hct2
                addct2  hct2, hctwait
.wait
                jnct2   #.wait
                ret

'------------------------------------------------------------------------------
' Transaction retry handling for NAK/STALL or bus error.
'------------------------------------------------------------------------------
' On entry:
'   retval - transaction response PID or error code.
' On exit:
'------------------------------------------------------------------------------
retry_wait
                cmp     retval, #PID_STALL      wz
        if_z    ret                                     ' STALL is special case
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak
                mov     hctwait, _txn_err_              ' Transaction error wait...
                call    #poll_waitx
.dec
                sub     retry, #1               wz
        if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
                ret                                     ' Retry result to caller
.nak
                mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
                call    #poll_waitx
                cmp     nak_retry, #NAK_NOLIMIT wz
        if_z    ret                                     ' Indefinite NAK retries
                sub     nak_retry, #1           wz
        if_z    mov     retval, #ERR_NAK
                ret

host_reset
                setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
                mov     htmp, ##_CLKFREQ                ' Get current sysclock setting
' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
                cmp     htmp, ##168_000_000     wcz
        if_be   mov     utx_tweak, #0
        if_a    mov     utx_tweak, #3   '#20
' Check to see if the system clock has been changed.
                cmp     htmp, save_sysclk       wz
        if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
        if_nz   add     pb, hcog_base_addr
        if_nz   call    pb                              ' Recalculate sysclk dependent timing values
                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                cmp     p2rev_val, #P2RevB      wz
        if_z    jmp     #.not_reva
                wrpin   ##USB_V1HMODE_FS, dm            ' The host is also the root hub, so full-speed is its native speed
                wrpin   ##USB_V1HMODE_FS, dp
                wxpin   _12Mbps_, dm                    ' Default to Full-Speed
                jmp     #.enable
.not_reva
                wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
                wrpin   ##USB_V2_DRVOUT, dp
                wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
.enable
                dirh    dm                              ' Crank them smart pins up
                dirh    dp
                waitx   _1us_
                wypin   #OUT_IDLE, dm

                ' Handle Port protection enable and startup delay
                mov     htmp, usb_event_pin             ' I/O + 1 pin is the Serial Host USB Protection enable/disable
                add     htmp, #1                        ' Protection enable is a one-time operation
                drvl    htmp                            ' disable port
                waitx   _21ms_                          ' Wait a while for everything to turn off
                drvh    htmp                            ' Enable the port
                waitx   _21ms_                          ' Hold to let the idle state get settled

                setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
                rep     @.regloop,#hreg_init_end - hreg_init_start
                alti    pa, #%000_111_000
                mov     0-0, #0
.regloop

discon_entry
                mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one

                ' Fall through to disconnected loop

'-----------------------------------------------------------------------------------------------------------------
' Device connect handling (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
' device to connect (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
disconnected
                mov     hr1, ##_CLKFREQ                 ' Check to see if the system frequency has changed
                cmp     hr1, save_sysclk        wz
        if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
                shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
                waitx   hr1                             ' it down to smaller wait chunks
                incmod  mod_cnt, #8             wc
        if_c    drvnot  host_active_led
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
        if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
        if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
.se1_test
                mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
                call    #poll_waitx
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
        if_ne   jmp     #discon_entry                   ' Back to connect detection loop
.se1            'SE1 is a fatal error condition
                mov     hctwait, _100ms_
                call    #poll_waitx
                mov     retval, #ERR_SE1
                call    #host_error                     ' Seeing SE1 for any length of time is not good...
.connect_test                                           ' Test lines until stable J/K state seen
                waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_z    jmp     #discon_entry                   ' D+ and D- low
        if_e    jmp     #.se1_test                      ' D+ and D- high
connected
                bith    hstatus, #CONNECTEDB            ' Device plugged in
                call    #on_connect                     ' Initial device configuration
                cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
        if_nz   jmp     #discon_entry
.set_pulse
                getct   _pulse_time_
                add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
' of 1ms and make a correction, if necessary.
'                mov     htmp, _1ms_
'                subs    htmp, iframe_delta
'                adds    _frame1ms_clks_, htmp
'                debug(udec(_frame1ms_clks_))

                ' Fall through to idle/processing loop

                cmp     hdev_port, #4           wcz
        if_a    mov     hdev_port, #0

hidle
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_c    jmp     #.se0_test
                pollct3                         wc
        if_nc   jmp     #.nopoll
                getct   hct3
                addct3  hct3, _2ms_                     ' Set the timer for next poll interval

                altgb   hdev_port, #hdev_type
                getbyte htmp

                cmp     htmp, #HUB_READY        wz
        if_z    loc     pa, #@hget_hub_status - @usb_host_start
        if_z    jmp     #.poll

                cmp     htmp, #KB_READY         wz
        if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
        'if_z    jmp     #.poll

.poll
        if_z    add     pa, hcog_base_addr
        if_z    call    pa

                incmod  hdev_port, #4

.nopoll
                cmp     cmd_data, #CMD_SUSPEND  wz
        if_z    jmp     #hsuspend
                cmp     cmd_data, #CMD_RESET    wz
        if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
        if_z    jmp     #host_reset                     ' See if it works...
                getct   hr0
                cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
        if_ae   drvnot  host_active_led
        if_ae   getct   _pulse_time_
        if_ae   add     _pulse_time_, _500ms_
                jmp     #hidle
' Check for extended SE0 state on the bus
.se0_test
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Wait a bit and test for SE0 again
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #hidle                          ' Bus still IDLE
                call    #wait_txn_ok
                wypin   ##OUT_IDLE, dm                  ' Float USB
                wxpin   #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
                jmp     #host_reset                     ' Device disconnected

hsuspend
                call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
                setint1 #0                              ' Stopping the 1ms frame packets signals suspend
                waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
                wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
                mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
                mov     mod_cnt, #0

                ' Fall through to resume wait loop

hwait_resume
                mov     hr1, ##_CLKFREQ                 ' Use the CLKFREQ value, as the sysclock may change
                shr     hr1, #2
                waitx   hr1                             ' Pulse the activity LED every two seconds but break
                incmod  mod_cnt, #8             wc      ' it down to smaller wait chunks
        if_c    drvnot  host_active_led
                cmp     cmd_data, #CMD_RESUME   wz
        if_nz   jmp     #hwait_resume
                mov     htmp, ##_CLKFREQ                ' Check to see if the system frequency has changed
                cmp     htmp, save_sysclk       wz
        if_z    jmp     #.resume
                loc     pb, #@hinit_usb_timings - @usb_host_start
                add     pb, hcog_base_addr
                call    pb                              ' Recalculate sysclk dependent timing values
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
        if_c    wxpin   _usb_h_ls_nco_, dm
.resume
                wypin   #OUT_K, dm
                waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
                wypin   #OUT_SE0, dm
                mov     htmp, _ip_delay_ls_
                shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
                waitx   htmp
                wypin   #OUT_J, dm
                shr     htmp, #1
                waitx   htmp
                wypin   #OUT_IDLE, dm
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                setint1 #1                              ' Enable the 1ms frame ISR
                mov     hctwait, _4ms_
                call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
        _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete

'------------------------------------------------------------------------------
' Send preamble to enable low-speed HUB ports
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   USB baud rate set to low-speed
'------------------------------------------------------------------------------
utx_pre
                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                wrpin   #0, dm                          ' Disable smartpin mode
                wrpin   #0, dp
                drvl    dm
                drvh    dp

                mov     htmp, ##OUT_SOP | (PID_PRE << 8)

                rep     @.l1, #16 + 1
                shr     htmp, #1        wc
        if_nc   setq    #1
        if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
                waitx   _preamble_wait_
.l1

                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
                wrpin   ##USB_V2_DRVOUT, dp
                wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
                dirh    dm                              ' Crank them smart pins up
                dirh    dp
                wypin   #OUT_IDLE, dm

                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods

hlut_end
                fit     $400

DAT             ' USB Host HUB execution
                orgh
'------------------------------------------------------------------------------
' Routines called from cog space.
'------------------------------------------------------------------------------
' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'------------------------------------------------------------------------------

'------------------------------------------------------------------------------
' USB host cog initialization.
'------------------------------------------------------------------------------
usb_host_init
                loc     pb, #hid_report
                mov     hid_report_p, pb
                add     pb, #KBD_IN_RPT_LEN
                mov     hid_report_p + 1, pb
                add     pb, #KBD_IN_RPT_LEN
                mov     hid_report_p + 2, pb
                add     pb, #KBD_IN_RPT_LEN
                mov     hid_report_p + 3, pb
                add     pb, #KBD_IN_RPT_LEN
                mov     hid_report_p + 4, pb

                loc     pb, #hub_descr
                mov     hub_descr_p, pb
                loc     pb, #urx_buff
                mov     urx_buff_p, pb
                loc     pb, #dev_desc_buff
                mov     dev_desc_buff_p, pb
                loc     pb, #con_desc_buff
                mov     con_desc_buff_p, pb
                loc     pb, #usb_cache_start
                mov     cache_start_p, pb
                loc     pb, #usb_cache_end
                mov     cache_end_p, pb

                drvl    host_error_led                  ' Ensure fatal error LED is inactive
'                mov     p2rev_val, ptrb                 ' Running on P2RevA or P2RevB+ silicon?
'                setq    #1
'                rdlong  $1e0, ptrb++
'                subr    p2rev_val, ptrb
'                shr     p2rev_val, #2           wz      ' RevA if shift result is zero
'        if_z    mov     p2rev_val, #P2RevA              ' 1 == RevA, 2 == RevB+
'                loc     ptrb, #p2rev_char               ' Make a revision "A" or "B" char accessible to Spin2
'                mov     htmp, p2rev_val
'                add     htmp, #"@"
'                wrbyte  htmp, ptrb
                dirl    usb_event_pin                   ' Configure the USB event mailbox smart pin
                wrpin   ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
                dirh    usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
' Configure and enable the Serial Host USB port.
                jmp     #host_reset                     ' Initialize host and enter main processing loop

'------------------------------------------------------------------------------
' Timing calculations happen before any interrupt(s) are enabled.
'------------------------------------------------------------------------------
' On entry:
'   htmp - current CLKFREQ value.
'------------------------------------------------------------------------------
hinit_usb_timings
'                getct   htmp2
                mov     save_sysclk, htmp
                qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
                getqx   _12Mbps_
                shr     _12Mbps_, #16           wc
                addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
                mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
                shl     _usb_h_fs_nco_, #14
                add     _usb_h_fs_nco_, _12Mbps_
                mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
                shl     _usb_d_fs_nco_, #14
                add     _usb_d_fs_nco_, _12Mbps_
                mov     _1_5Mbps_, _12Mbps_
                shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
                mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
                shl     _usb_h_ls_nco_, #14
                add     _usb_h_ls_nco_, _1_5Mbps_
                mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
                qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1b
                getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1m
                getqx   _1us_                           ' 1us as 32,9 fixed point
                mov     hsave0, _1us_                   ' Save it to compute other us values
                shr     _1us_, #9               wc
                addx    _1us_, #0                       ' Round to final value
                qmul    hsave0, #10                     ' Calc 10us
                getqx   _10us_
                shr     _10us_, #9              wc
                addx    _10us_, #0                      ' 10us
                qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
                getqx   _33us_
                shr     _33us_, #9              wc
                addx    _33us_, #0                      ' 33us
                qmul    hsave0, #250                    ' Calc 250us
                getqx   _txn_err_
                shr     _txn_err_, #9           wc
                addx    _txn_err_, #0                   ' 250us
                qmul    hsave0, #500                    ' Calc 500us
                getqx   _500us_
                shr     _500us_, #9             wc
                addx    _500us_, #0                     ' 500us
                qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
                getqx   _txn_ok_ls_
                shr     _txn_ok_ls_, #9         wc
                addx    _txn_ok_ls_, #0                 ' 666us
                qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
                getqx   _txn_ok_fs_
                shr     _txn_ok_fs_, #9         wc
                addx    _txn_ok_fs_, #0                 ' 850us
                mov     _ip_delay_ls_, _1ns16fp_
                mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_ls_, #16      wc
                addx    _ip_delay_ls_, #0
                mov     _tat_wait_ls_, _1ns16fp_
                mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
                shr     _tat_wait_ls_, #16      wc
                addx    _tat_wait_ls_, #0
                mov     _ip_delay_fs_, _1ns16fp_
                mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_fs_, #16      wc
                addx    _ip_delay_fs_, #0
                mov     _tat_wait_fs_, _1ns16fp_
                mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
                shr     _tat_wait_fs_, #16      wc
                addx    _tat_wait_fs_, #0
                qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
                getqx   _preamble_wait_
                sub     _preamble_wait_,# 9 - 1
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1thou
                getqx   _1ms_                           ' 1ms as 32,9 fixed point
                shr     _1ms_, #9               wc
                addx    _1ms_, #0                       ' 1ms
                mov     _frame1ms_clks_, ##-14
                adds    _frame1ms_clks_, _1ms_
                mov     _2ms_, _1ms_
                shl     _2ms_, #1                       ' 2ms
                mov     _suspend_wait_, _1ms_
                add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
                mov     _4ms_, _1ms_
                shl     _4ms_, #2                       ' 4ms
                mov     _xfer_wait_, _4ms_
                add     _xfer_wait_, _1ms_              ' 5ms
                mov     _reset_hold_, _xfer_wait_       ' 5ms
                mov     _resume_hold_, _reset_hold_
                shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
                mov     _100ms_, _resume_hold_          ' 20ms
                shl     _100ms_, #1                     ' 40ms
                mov     _8ms_, _1ms_
                shl     _8ms_, #3                       ' 8ms
                shl     _reset_hold_, #1                ' 10ms
                add     _100ms_, _reset_hold_           ' 50ms
                add     _reset_hold_, _xfer_wait_       ' 15ms
                mov     _21ms_, _xfer_wait_             ' 5ms
                shl     _21ms_, #2                      ' 20ms
                add     _21ms_, _1ms_                   ' 21ms
                mov     _500ms_, _100ms_                ' 50ms
                shl     _100ms_, #1                     ' 100ms
                shl     _500ms_, #3                     ' 400ms
        _ret_   add     _500ms_, _100ms_                ' 500ms
'        _ret_   mov     _1sec_, save_sysclk
'        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'                ret
{
                getct   htmp
                sub     htmp, htmp2
        debug("USB timing calc sysclocks: ", udec( htmp))
                ret
}

'------------------------------------------------------------------------------
' Parse a configuration descriptor chain to see if the device is a recognized
' one. If it is, start the task progression that will configure the device for
' use.
'------------------------------------------------------------------------------
' On entry:
'   hconfig_base - start address of the cached config descriptor chain.
' On exit:
'------------------------------------------------------------------------------
hparse_con_desc
                mov     ptrb, dev_desc_buff_p
                rdlong  hdev_id, ptrb[2]                ' idVendor + idProduct
                movbyts hdev_id, #%%1032                ' |
                rdword  hdev_bcd, ptrb[6]               ' bcdDevice
                debug(uhex_long(hdev_id), uhex_word(hdev_bcd))

                mov     pa, #CON_wTotalLen
                add     pa, hconfig_base
                rdword  hcon_tot_len, pa                ' Keep config chain size handy
                debug(uhex_byte_array(hconfig_base, hcon_tot_len))
' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
' that defines a keyboard and/or mouse.
                rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
.next_intf
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #hset_config
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.intf
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                jmp     #.next_intf
.intf
                mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
                mov     hpar3, #0
                rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
                rdbyte  hdev_class, ptrb[INTF_bIntfClass]
                rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
                rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
                debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))

.endp
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #.get_device
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.get_device
                cmp     htmp, #TYPE_ENDPOINT    wz
        if_z    jmp     #.get_ep
                jmp     #.endp
.get_ep
                rdbyte  hr1, ptrb[ENDP_bAddress]
                testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
                shl     hr1, #8 + 7
                mov     htmp, hctrl_ep_addr
                and     htmp, ##ADDR_MASK
                or      htmp, hr1                       ' endpoint address
                cmp     hpar2, #0               wz
 if_z_and_c     jmp     #.in_ep
                cmp     hpar3, #0               wz
 if_z_and_nc    jmp     #.out_ep
                jmp     #.endp
.in_ep
                mov     hpar2, htmp                     ' IN endpoint
                rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr2, hr0, #3
                jmp     #.endp
.out_ep
                mov     hpar3, htmp                     ' OUT endpoint
                rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr3, hr0, #3
                jmp     #.endp

.get_device
                cmp     hdev_class, #CLASS_HUB  wz
        if_z    jmp     #.hub
                cmp     hdev_class, #CLASS_HID              wz
        if_nz   jmp     #.next_intf                     ' No HID class, ignore
                cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
        if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
                cmp     hdev_protocol, #INTF_PROTO_KBD      wz
        if_nz   jmp     #.next_intf                     ' No Keyboard
.keyboard
                cmp     hkbd_ep_addr, #0    wz
        if_nz   jmp     #.next_intf
                getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
                getbyte kb_interval, hr2, #3
                getbyte kb_in_max_pkt, hr2, #0
                mov     hkbd_ep_addr, hpar2             ' IN endpoint address
                'debug(udec(kb_intf_num))
                debug(uhex_long(hkbd_ep_addr),uhex_long(hdev_out_addr),udec(kb_in_max_pkt,kb_interval))
                debug(uhex_long(hdev_ep_addr),uhex_long_(hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4))
                jmp     #.next_intf
.hub
                cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
        if_nz   jmp     #.next_intf
                cmp     hdev_protocol, #INTF_PROTO_NONE     wz
        if_nz   cmp     hdev_protocol, #2                   wz
        if_nz   jmp     #.next_intf
                cmp     hhub_ep_addr, #0    wz
        if_nz   jmp     #.next_intf
                getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
                mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
                mov     ep_addr_pid, hpar2              ' IN endpoint address
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                mov     hhub_ep_addr, ep_addr_pid
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
                debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
                debug(uhex_long(hdev_ep_addr),uhex_long_(hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4))
                jmp     #.next_intf

'------------------------------------------------------------------------------
' If a newly-connected device is recognized, do whatever is needed to configure
' it according to its function, or functions. In the case of this boot protocol
' keyboard/mouse class driver:
' - SetConfiguration(config_num)
' - SetProtocol(boot)
' - SetIdle(indefinite)
' - Enter the device interrupt IN polling task stage.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hset_config
                mov     htmp2, #DEV_UNKNOWN
                altd    hdev_port, #hdev_ep_addr
                cmp     0-0, #0                 wz
        if_z    cmp     hkbd_ep_addr, #0        wz
        if_z    cmp     hhub_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No known device
.set_config
                loc     ptra, #set_config
                mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
                add     pa, hconfig_base
                rdbyte  hpar1, pa
                wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
                mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
                mov     pb, #0                          ' SetConfiguration() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   ret
.kbd_config
                cmp     hkbd_ep_addr, #0        wz
        if_z    jmp     #.hub_config                    ' No keyboard
                mov     htmp, hkbd_ep_addr
                and     htmp, ##ADDR_MASK
                mov     htmp1, ep_addr_pid
                and     htmp1, ##ADDR_MASK
                cmp     htmp, htmp1             wz
        if_nz   jmp     #.hub_config                    ' No keyboard

                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_protocol
                wrword  #BOOT_PROTOCOL, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                mov     pb, #0                          ' SetProtocol() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
                getbyte hpar2, kb_intf_num, #0
                call    #hset_idle
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hctwait, _2ms_
                call    #poll_waitx
                mov     kb_led_states, #LED_NUMLKF
                mov     hkbd_ledstates, kb_led_states
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     ep_addr_pid, hkbd_ep_addr
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                testb   hub_port_status, #HUB_PORT_LOWSPEED wc
                bitc    ep_addr_pid, #31
                mov     hkbd_ep_addr, ep_addr_pid
                mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
                bitc    hkbd_ctrl_ep, #31
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
                mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
                mov     htmp2, #KB_READY                ' Keyboard interface configured
                jmp     #.notify_client
.hub_config
                cmp     hhub_ep_addr, #0    wz
        if_z    ret                                     ' No HUB
                mov     htmp, hhub_ep_addr
                and     htmp, ##ADDR_MASK
                mov     htmp1, ep_addr_pid
                and     htmp1, ##ADDR_MASK
                cmp     htmp, htmp1             wz
        if_nz   ret                                     ' No HUB

                loc     ptra, #get_hub_desc             ' Get HUB descriptor
                wrword  #$FF, ptra[wLength]
                mov     pb, hub_descr_p
                call    #control_read
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hhub_ep_addr, #0
        if_nz   jmp     #.notify_client
                debug(uhex_byte_array(hub_descr_p,total_data))

                loc     ptra, #set_port_feat            ' Power on ports
                wrword  #HUB_PORT_POWER, ptra[wValue]
                wrword  #1, ptra[wIndex]
                call    #control_write
                loc     ptra, #set_port_feat
                wrword  #2, ptra[wIndex]
                call    #control_write
                loc     ptra, #set_port_feat
                wrword  #3, ptra[wIndex]
                call    #control_write
                loc     ptra, #set_port_feat
                wrword  #4, ptra[wIndex]
                call    #control_write

                mov     hctwait, _500ms_
                add     hctwait, _100ms_
                call    #poll_waitx

                mov     htmp2, #HUB_READY               ' Hub ready
                'jmp     #.notify_client

.notify_client
                altsb   hdev_port, #hdev_type
                setbyte htmp2                           ' Save device ready
                debug("hdev_type = ", uhex_long_(hdev_type+1,hdev_type))
        _ret_   wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured

'------------------------------------------------------------------------------
' Initialize the keyboard/mouse data area to start-up values.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
init_kbdm_data
                mov     hkbd_ep_addr, #0
                mov     hdev_ep_addr, #0

                mov     ptra, cache_start_p         ' Clear cached data buffers
                mov     pa, cache_end_p
.loop
                wrbyte  #0, ptra++
                cmp     ptra, pa                wcz
        if_b    jmp     #.loop

                mov     pa, #hdev_init_start        ' Clear device data registers
.regloop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hdev_init_end      wz
        if_nz   jmp     #.regloop

                setbyte hdev_next_datax, #PID_DATA0, #0         ' Reset interrupt IN datax sequence PIDs
                setbyte hdev_next_datax, #PID_DATA0, #1
                setbyte hdev_next_datax, #PID_DATA0, #2
                setbyte hdev_next_datax, #PID_DATA0, #3
                setbyte hdev_next_datax + 1, #PID_DATA0, #0
                setbyte hdev_next_datax + 1, #PID_DATA0, #1
                setbyte hdev_next_datax + 1, #PID_DATA0, #2
                setbyte hdev_next_datax + 1, #PID_DATA0, #3
        _ret_   mov     hub_next_datax, #PID_DATA0

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
' function.
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'   hpar2 - index number of the target interface.
' On exit:
'------------------------------------------------------------------------------
hset_idle
                mov     hctwait, _2ms_
                call    #poll_waitx
                loc     ptra, #set_idle
                wrword  hpar1, ptra[wValue]
                wrword  hpar2, ptra[wIndex]
                jmp     #control_write

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - device address and enpoint for the request.
' On exit:
'   retval - transaction result.
'------------------------------------------------------------------------------
hset_kbdled_report
                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_report
                wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
                wrword  htmp, ptra[wIndex]
                wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
                mov     pb, urx_buff_p
                wrbyte  kb_led_states, pb
                jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for keyboard activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_kbd_in_report
                mov     ep_addr_pid, hkbd_ep_addr
                mov     hpar2, urx_buff_p
                altgb   hdev_port, #hdev_next_datax
                getbyte hpar3
                setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' No ACK, ignore
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet

                altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
                getbyte htmp                            ' |
                cmp     htmp, #PID_DATA0        wz      ' |
        if_z    mov     htmp, #PID_DATA1                ' |
        if_nz   mov     htmp, #PID_DATA0                ' |
                altsb   hdev_port, #hdev_next_datax     ' |
                setbyte htmp                            ' |

                mov     kb_max_index, hpar3             ' Save actual bytes read
                call    #hkbd_compare
.led_check
                mov     htmp, kb_led_states
                cmp     hkbd_ledstates, htmp    wz
        if_z    ret                                     ' No toggle key indicator changes, so we're done
                mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
                mov     ep_addr_pid, hkbd_ctrl_ep
                jmp     #hset_kbdled_report             ' Set report and ignore errors

'------------------------------------------------------------------------------
' Compare current and previous keyboard data buffers for keypress changes.
'------------------------------------------------------------------------------
hkbd_compare
                mov     ptra, urx_buff_p
                alts    hdev_port, #hid_report_p
                mov     ptrb, 0-0
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
                cmp     htmp1, htmp2    wz
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
        if_z    cmp     htmp1, htmp2    wz
        if_z    ret

                alts    hdev_port, #hid_report_p
                mov     ptra, 0-0

                mov     hpar1, #0
                rdbyte  hpar2, urx_buff_p
                rdbyte  hpar3, ptra
                cmp     hpar2, hpar3    wz
        if_nz   modc    _clr            wc
        if_nz   call    #hkbd_shift

.release        modc    _set            wc
                'alts    hdev_port, #hid_report_p
                'mov     ptra, 0-0
                add     ptra, #2
                mov     pa, #6
.rl1            rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.rl3
                mov     ptrb, urx_buff_p
                add     ptrb, #2
                mov     pb, #6
.rl2            rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.rl3
                djnz    pb, #.rl2
                call    #hkbd_translate
.rl3            djnz    pa, #.rl1

                mov     hpar3, #0
                bith    hpar3, #31

.press          modc    _clr    wc
                mov     ptra, urx_buff_p
                add     ptra, #2
                mov     pa, #6
.pl1            rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.pl3
                alts    hdev_port, #hid_report_p
                mov     ptrb, 0-0
                add     ptrb, #2
                mov     pb, #6
.pl2            rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.pl3
                djnz    pb, #.pl2
                call    #hkbd_translate
.pl3            djnz    pa, #.pl1

.copy           mov     ptra, urx_buff_p
                alts    hdev_port, #hid_report_p
                mov     ptrb, 0-0
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++

                ret

'------------------------------------------------------------------------------
' Translate keyboard scancode to ASCII
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - scancode
'   hpar2 - key modifiers state
'       c - pressed (0) or released (1) flag
'------------------------------------------------------------------------------
hkbd_translate
                mov     htmp, hpar1
                add     htmp, ##@kbd_table
                rdbyte  htmp, htmp      wz
        if_nz   jmp     #hkbd_out_char
                'debug(uhex_byte(hpar1),ubin_byte(hpar2),uhex_byte(htmp))
                ret

hkbd_shift
                testb   hpar3, #LEFT_SHIFTB     wc
                testb   hpar2, #LEFT_SHIFTB     wz
    if_c_ne_z   mov     htmp, #$2A
    if_c_ne_z   jmp     #hkbd_out_char

                testb   hpar3, #RIGHT_SHIFTB    wc
                testb   hpar2, #RIGHT_SHIFTB    wz
    if_c_ne_z   mov     htmp, #$36
    if_c_ne_z   jmp     #hkbd_out_char

                testb   hpar3, #LEFT_CTRLB      wc
                testb   hpar2, #LEFT_CTRLB      wz
    if_c_ne_z   mov     htmp, #$1D
    if_c_ne_z   jmp     #hkbd_out_char

                testb   hpar3, #RIGHT_CTRLB     wc
                testb   hpar2, #RIGHT_CTRLB     wz
    if_c_ne_z   mov     htmp, #$1D
    if_c_ne_z   jmp     #hkbd_out_char

                testb   hpar3, #LEFT_ALTB       wc
                testb   hpar2, #LEFT_ALTB       wz
    if_c_ne_z   mov     htmp, #$38
    if_c_ne_z   jmp     #hkbd_out_char

                testb   hpar3, #RIGHT_ALTB      wc
                testb   hpar2, #RIGHT_ALTB      wz
    if_c_ne_z   mov     htmp, #$38
    if_c_ne_z   jmp     #hkbd_out_char

                ret

hkbd_out_char
                bitc    htmp, #7
                wrbyte  htmp, #@kbd_data
                'debug(uhex_byte(hpar1),ubin_byte(hpar2),uhex_byte(htmp))

.lock           locktry #I_INT_LOCK     wc  ' acquire lock for interrupt lines
        if_nc   jmp     #.lock

                rdbyte  htmp1, #@pic_irq
                bith    htmp1, #1
                wrbyte  htmp1, #@pic_irq

        _ret_   lockrel #I_INT_LOCK         ' release lock

kbd_table ' Index is the key scan code
          {$00} byte    $00, $00, $00, $00                      ' $03
          {$04} byte    $1E, $30, $2E, $20                      ' $07: a b c d
          {$08} byte    $12, $21, $22, $23, $17, $24, $25, $26  ' $0f: e f g h i j k l
          {$10} byte    $32, $31, $18, $19, $10, $13, $1F, $14  ' $17: m n o p q r s t
          {$18} byte    $16, $2F, $11, $2D, $15, $2C, $02, $03  ' $1f: u v w x y z 1 2
          {$20} byte    $04, $05, $06, $07, $08, $09, $0A, $0B  ' $27: 3 4 5 6 7 8 9 0
          {$28} byte    $1C, $01, $0E, $0F, $39, $0C, $0D, $1A  ' $2f: Enter Esc BkSpc Tab Spc - = [
          {$30} byte    $1B, $00, $29, $27, $28, $00, $33, $34  ' $37: ] \ # ; ' ` , .
          {$38} byte    $35, $3A, $3B, $3C, $3D, $3E, $3F, $40  ' $3f: / CapsLock F1 F2 F3 F4 F5 F6
          {$40} byte    $41, $42, $43, $44, $00, $00, $54, $46  ' $47: F7 F8 F9 F10 F11 F12 PrtSc, ScrLk
          {$48} byte    $1D, $52, $47, $49, $53, $4F, $51, $4D  ' $4f: Pause, Ins, Home PgUp BkSpc_Del End PgDn Right
          {$50} byte    $4B, $50, $48, $45, $35, $37, $4A, $4E  ' $57: Left Down Up KpdNumLck Kp/ Kp* Kp- Kp+
          {$58} byte    $1C, $4F, $50, $51, $4B, $4C, $4D, $47  ' $5f: KpEnter Kp1_End Kp2_Down Kp3_PgDn Kp4_Left Kp5 Kp6_Right Kp7_Home
          {$60} byte    $48, $49, $52, $53, $2B, $00            ' $65: Kp8_Up Kp9_PgUp Kp0_Ins Kp._Del Kp\_| App

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for gamepad activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_hub_status
                mov     ep_addr_pid, hhub_ep_addr
                mov     hpar2, urx_buff_p
                setword hpar3, hub_next_datax, #0
                setword hpar3, #1, #1
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.data
                cmp     retval, #PID_NAK        wz
        if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
                ret
.data
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet

                cmp     hub_next_datax, #PID_DATA0  wz
        if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
        if_nz   mov     hub_next_datax, #PID_DATA0
                rdlong  hub_status_chg, urx_buff_p
                debug(ubin_long(hub_status_chg))

                testb   hub_status_chg, #1      wz
        if_x0   jmp     #.port2
                mov     hdev_port, #1
                call    #hub_port_handler
.port2
                testb   hub_status_chg, #2      wz
        if_x0   jmp     #.port3
                mov     hdev_port, #2
                call    #hub_port_handler
.port3
                testb   hub_status_chg, #3      wz
        if_x0   jmp     #.port4
                mov     hdev_port, #3
                call    #hub_port_handler
.port4
                testb   hub_status_chg, #4      wz
        if_x0   jmp     #.portN
                mov     hdev_port, #4
                call    #hub_port_handler
.portN
                ret

hub_port_handler
                mov     ep_addr_pid, hhub_ctrl_ep
                loc     ptra, #get_port_status          ' Get HUB port status
                mov     pb, urx_buff_p
                wrword  hdev_port, ptra[wIndex]
                call    #control_read
                rdlong  hub_port_status, urx_buff_p
                debug(udec(hdev_port), ubin_long(hub_port_status))

                testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
        if_x0   jmp     #.other
                loc     ptra, #clr_port_feat
                wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
                wrword  hdev_port, ptra[wIndex]
                call    #control_write
                testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
        if_x0   jmp     #.disconnect
                mov     hctwait, _100ms_
                call    #poll_waitx

                loc     ptra, #set_port_feat            ' reset port
                wrword  #HUB_PORT_RESET, ptra[wValue]
                wrword  hdev_port, ptra[wIndex]
                call    #control_write

                mov     htmp3, #2
.wait_reset
                mov     hctwait, _8ms_
                call    #poll_waitx
                loc     ptra, #get_port_status          ' Get HUB port status
                mov     pb, urx_buff_p
                wrword  hdev_port, ptra[wIndex]
                call    #control_read
                rdlong  hub_port_status, urx_buff_p
                testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
        if_x0   djnz    htmp3, #.wait_reset

                loc     ptra, #clr_port_feat
                wrword  #HUB_C_PORT_RESET, ptra[wValue]
                wrword  hdev_port, ptra[wIndex]
                call    #control_write

                mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
.wait_recover
                mov     hctwait, _1ms_
                call    #poll_waitx
                djnz    htmp,#.wait_recover

                testb   hub_port_status, #HUB_PORT_LOWSPEED wc
        if_c    bith    hstatus, #DWNSTRM_HUBB
        if_c    bith    _usb_h_ls_nco_, #14

                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
                wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done
.get_dev_desc
                mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
                mov     htmp, hdev_port             ' Address is hub port number
                wrword  htmp, ptra[wValue]
                call    #control_write                  ' Execute SetAddress()
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done                          ' Back to idle if not ACK
                mov     hctwait, _8ms_
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, hdev_port
                shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
                call    #calc_crc5
                loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done                          ' Back to idle if not ACK
                mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
                mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
                'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
                mov     hctwait, _500us_
                call    #poll_waitx
                loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
                wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #.done
                mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
                mov     hconfig_base, ptra              ' Will need this for configuration
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    mov     retval, #ERR_CONFIG_FAIL
        if_b    jmp     #.done
                call    #hparse_con_desc
                jmp     #.done

.other
                testb   hub_port_status, #HUB_C_PORT_RESET wz
        if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
        if_x1   jmp     #.reset_feature
                testb   hub_port_status, #HUB_C_PORT_ENABLE wz
        if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
        if_x1   jmp     #.reset_feature
                testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
        if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
        if_x1   jmp     #.reset_feature
                testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
        if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
        if_x1   jmp     #.reset_feature
                jmp     #.done
.reset_feature
                loc     ptra, #clr_port_feat
                wrword  hdev_port, ptra[wIndex]
                call    #control_write
                jmp     #.done
.disconnect
                altgb   hdev_port, #hdev_type
                getbyte htmp
                cmp     htmp, #KB_READY         wz
        if_z    mov     hkbd_ep_addr, #0
        if_z    mov     hkbd_ctrl_ep, #0
        if_z    mov     kb_led_states, #0
        if_z    mov     hkbd_ledstates, kb_led_states

                altsb   hdev_port, #hdev_type
                setbyte #0
                altd    hdev_port, #hdev_ep_addr
                mov     0-0, #0

.done
                bitl    _usb_h_ls_nco_, #14     wcz
                bitl    hstatus, #DWNSTRM_HUBB
        if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
                mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods

                loc     ptra, #get_port_status          ' Get HUB port status
                mov     pb, urx_buff_p
                wrword  hdev_port, ptra[wIndex]
                call    #control_read
                rdlong  hub_port_status, ptra
                debug(udec(hdev_port), ubin_long(hub_port_status))
                ret

'------------------------------------------------------------------------------
' Partially populated SETUP packets
'------------------------------------------------------------------------------
get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_DEVICE << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_CONFIG << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_CONFIG
                word    0       ' Configuration value
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_CONFIG has no data stage
set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_ADDR
                word    0       ' Zero
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_ADDR has no data stage
'------------------------------------------------------------------------------
' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
' wValue field dictates which protocol should be used.
'
' When initialized, all devices default to report protocol. However the host
' should not make any assumptions about the device state and should set the
' desired protocol whenever initializing a device.
'------------------------------------------------------------------------------
set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_PROTO
                word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
                                                ' (HID 1.11 Section 7.2.6).
                word    0               ' Interface index number.
                word    0               ' Zero, as HID_SET_PROTO has no data stage.
'------------------------------------------------------------------------------
set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_IDLE
                word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
                                        ' reporting until a change is detected in the report data

                                        ' (HID 1.11 Section 7.2.4).
                word    0       ' Interface index number.
                word    0       ' Zero, as HID_SET_IDLE has no data stage.
set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_REPORT
                word    0       ' Byte1 = report type, byte0 = ReportID.
                                        ' (HID 1.11 Section 7.2.2).
                word    0       ' Interface index number.
                word    0       ' Size of the report, in bytes.
get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
                byte    REQ_GET_DESC
                word    TYPE_REPORT << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
'------------------------------------------------------------------------------
get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_HUB << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
                byte    REQ_SET_FEATURE
                word    0       ' port power
                word    1       ' Port index number (1+)
                word    0       ' Number of bytes to transfer if there is a data stage
clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
                byte    REQ_CLEAR_FEATURE
                word    0       ' port power
                word    1       ' Port index number (1+)
                word    0       ' Number of bytes to transfer if there is a data stage
get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
                byte    REQ_GET_STATUS
                word    0
                word    1       ' Port index number (1+)
                word    4       ' Number of bytes to transfer if there is a data stage

'------------------------------------------------------------------------------
' The USB data cache area gets zero-filled at every device disconnect
'------------------------------------------------------------------------------
usb_cache_start

' HID descriptor and report buffers
hid_report      byte    0[KBD_IN_RPT_LEN * 5]

' HUB descriptor
hub_descr       byte    0   ' bDescLength
                byte    0   ' bDescriptorType
                byte    0   ' bNbrPorts
                word    0   ' wHubCharacteristics
                byte    0   ' bPwrOn2PwrGood
                byte    0   ' bHubContrCurrent
                byte    0   ' DeviceRemoveable
                byte    0   ' PortPwrCtrlMask

usb_cache_end

urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain

CON ' USB Host Shared constants
'------------------------------------------------------------------------------
' Smart pin configuration for "long repository" mode with output enabled,
' regardless of DIR. This allows one pin to provide a long event code via IN
' and also to control the USB port activity LED on/off state vio OUT.
    SP_REPO1_MODE = %01_00001_0 | 1 << 16    ' %TT_MMMMM_0, P[12:10] != %101
'------------------------------------------------------------------------------
' A simple event/cmd system using a smart pin configured in "long repository"
' mode. The USB_EVENT_REPO pin defined above is used to allow the USB cog to
' signal the client that a particular event has occurred. The client must poll
' this smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main"
' loop and process the event IDs you're interested in.
'------------------------------------------------------------------------------
    #0, NO_EVENT, USB_ERROR, DEV_UNKNOWN, KB_READY, M_READY, KBM_READY, HID_READY
    XINPUT_READY, PS3_READY, HUB_READY, DEV_DISCONNECT, DBG_DATA, M_DATA, GP_DATA
    CMD_SUSPEND, CMD_RESUME, CMD_RESET
'------------------------------------------------------------------------------
' The CMD_* tokens are asynchronous USB commands available to the user, through
' the Spin2 usbCommand method of this object. This method will post the cmd
' token to the host and when the cmd is complete the host will post the CMD_*
' token to byte[0] of the event long. Byte[1] is typically set to one of the
' below protocol error codes, with bytes[2..3] available for additional cmd data.
'------------------------------------------------------------------------------
' Protocol error codes:
    #0, ERR_NONE, ERR_CMD, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY
    ERR_XFER_RETRY, ERR_NAK, ERR_DATAX_SYNC, ERR_CONFIG_FAIL, ERR_TIMEOUT
'------------------------------------------------------------------------------
' Keyboard LED output report toggle key bit postions:
    #0, LED_NUMLKB, LED_CAPSLKB, LED_SCRLKB, LED_COMPOSEB
    LED_KANAB, LED_CONST0B, LED_CONST1B, LED_CONST2B
' Keyboard LED output report toggle key bitflags:
    LED_NUMLKF   = decod(LED_NUMLKB)
    LED_CAPSLKF  = decod(LED_CAPSLKB)
    LED_SCRLKF   = decod(LED_SCRLKB)
    LED_COMPOSEF = decod(LED_COMPOSEB)
    LED_KANAF    = decod(LED_KANAB)
    LED_CONST0F  = decod(LED_CONST0B)
    LED_CONST1F  = decod(LED_CONST1B)
    LED_CONST2F  = decod(LED_CONST2B)
' Keyboard modifier key bit positions:
    #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
    RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
' Keyboard modifier bitflags
    LEFT_CTRLF   = decod(LEFT_CTRLB)
    LEFT_SHIFTF  = decod(LEFT_SHIFTB)
    LEFT_ALTF    = decod(LEFT_ALTB)
    LEFT_GUIF    = decod(LEFT_GUIB)
    RIGHT_CTRLF  = decod(RIGHT_CTRLB)
    RIGHT_SHIFTF = decod(RIGHT_SHIFTB)
    RIGHT_ALTF   = decod(RIGHT_ALTB)
    RIGHT_GUIF   = decod(RIGHT_GUIB)
' Consolidated left/right modkeys. Add the modifier keys you want to trap
' together, then add the key scan code e.g. CTRL+ALT+"X" would be: $600 + KEY_X_x.
' The key() Spin2 method does this and the rawKey() method returns the key data
' as packed by the USB keyboard driver.
'   SHIFT = $100
'   CTRL  = $200
'   ALT   = $400
'   APP   = $800
' L|R key modifier flag combinations:
    KEYS_APP   = LEFT_GUIF + RIGHT_GUIF
    KEYS_ALT   = LEFT_ALTF + RIGHT_ALTF
    KEYS_CTRL  = LEFT_CTRLF + RIGHT_CTRLF
    KEYS_SHIFT = LEFT_SHIFTF + RIGHT_SHIFTF
'-------------
' Keyboard keys
' The first four scancodes are info/error indicators:
    #$00, KEY_NO_KEY, KEY_ERR_ROLLOVER, KEY_POST_FAIL, KEY_ERR_UNDEF
' Letters:
    KEY_A         = $04
    KEY_B         = $05
    KEY_C         = $06
    KEY_D         = $07
    KEY_E         = $08
    KEY_F         = $09
    KEY_G         = $0a
    KEY_H         = $0b
    KEY_I         = $0c
    KEY_J         = $0d
    KEY_K         = $0e
    KEY_L         = $0f
    KEY_M         = $10
    KEY_N         = $11
    KEY_O         = $12
    KEY_P         = $13
    KEY_Q         = $14
    KEY_R         = $15
    KEY_S         = $16
    KEY_T         = $17
    KEY_U         = $18
    KEY_V         = $19
    KEY_W         = $1a
    KEY_X         = $1b
    KEY_Y         = $1c
    KEY_Z         = $1d
' Number Row:
    KEY_1         = $1e
    KEY_2         = $1f
    KEY_3         = $20
    KEY_4         = $21
    KEY_5         = $22
    KEY_6         = $23
    KEY_7         = $24
    KEY_8         = $25
    KEY_9         = $26
    KEY_0         = $27
' Keyboard return (ENTER), tab, space, etc.:
    KEY_ENTER     = $28
    KEY_ESC       = $29
    KEY_BACKSPACE = $2a   ' Delete (backspace)
    KEY_TAB       = $2b
    KEY_SPACE     = $2c
    KEY_MINUS     = $2d   ' - and _
    KEY_EQUAL     = $2e   ' = and +
    KEY_LBRACE    = $2f   ' [ and {
    KEY_RBRACE    = $30   ' ] and }
    KEY_BACKSLASH = $31   ' \ and |
    KEY_HASHTILDE = $32   ' None-US # and ~
    KEY_SEMICOLON = $33   ' ; and :
    KEY_APOST     = $34   ' ' and "
    KEY_GRAVE     = $35   ' ` and ~
    KEY_COMMA     = $36   ' , and <
    KEY_DOT       = $37   ' . and >
    KEY_SLASH     = $38   ' / and ?
    KEY_CAPSLOCK  = $39
' Function key scancodes:
    KEY_F1        = $3a
    KEY_F2        = $3b
    KEY_F3        = $3c
    KEY_F4        = $3d
    KEY_F5        = $3e
    KEY_F6        = $3f
    KEY_F7        = $40
    KEY_F8        = $41
    KEY_F9        = $42
    KEY_F10       = $43
    KEY_F11       = $44
    KEY_F12       = $45
' Special, toggle and movement keys:
    KEY_PRINTSCREEN = $46
    KEY_SCROLLLOCK  = $47
    KEY_PAUSE       = $48
    KEY_INSERT      = $49
    KEY_HOME        = $4a
    KEY_PAGEUP      = $4b
    KEY_DELETE      = $4c
    KEY_END         = $4d
    KEY_PAGEDOWN    = $4e
    KEY_RIGHT       = $4f
    KEY_LEFT        = $50
    KEY_DOWN        = $51
    KEY_UP          = $52
' Keypad keys:
    KEY_NUMLOCK   = $53
    KEY_NUMSLASH  = $54
    KEY_NUMASTER  = $55
    KEY_NUMMINUS  = $56
    KEY_NUMPLUS   = $57
    KEY_NUMENTER  = $58
    KEY_NUM1      = $59
    KEY_NUM2      = $5a
    KEY_NUM3      = $5b
    KEY_NUM4      = $5c
    KEY_NUM5      = $5d
    KEY_NUM6      = $5e
    KEY_NUM7      = $5f
    KEY_NUM8      = $60
    KEY_NUM9      = $61
    KEY_NUM0      = $62
    KEY_DOT_DEL   = $63
    KEY_NOUS_SP   = $64   ' Non-US \ and |
    KEY_APP       = $65   ' Application key
' Modifier keys:
    KEY_LCTRL     = $E0
    KEY_LSHIFT    = $E1
    KEY_LALT      = $E2
    KEY_LMETA     = $E3 ' The left "Windows" key
    KEY_RCTRL     = $E4
    KEY_RSHIFT    = $E5
    KEY_RALT      = $E6
    KEY_RMETA     = $E7 ' The right "Windows" key

CON ' USB Host constants
'------------------------------------------------------------------------------
    _1thou         = 1_000
    _1m            = 1_000_000
    _1b            = 1_000_000_000
    _12m           = 12_000_000
    LSBTns         = 672.0                  ' Low-Speed bit period, in nanoseconds
    FSBTns         = 83.54                  ' Full-Speed bit period, in nanoseconds
    LSBTns4        = round(LSBTns * 4.0)    ' Low-Speed inter-packet delay, in nanoseconds
    LSBTns22       = round(LSBTns * 22.0)   ' Low-Speed turnaround wait time, in nanoseconds
    FSBTns4        = round(FSBTns * 4.0)    ' Full-Speed inter-packet delay, in nanoseconds
    FSBTns28       = round(FSBTns * 28.0)   ' Full-Speed turnaround wait time, in nanoseconds
' NCO baud calculations for low-speed/full-speed:
'        _1_5Mbps  = round(1_500_000.0 / _FCLKFREQ * 65536.0)  ' = NCO 492 @200MHz, 614 @160
'        _12Mbps   = round(12_000_000.0 / _FCLKFREQ * 65536.0) ' = NCO 3932 @200MHz, 4915 @160
' To configure RevA silicon LS/FS NCO baud: (WXPIN _1_5Mbps, D-) or (WXPIN _12Mbps, D-)
' To configure RevA LS/FS host/device: WRPIN appropriate LS/FS mode to D- (lower) and D+ (upper) pins:
    USB_V1HMODE_LS = %1_11000_0 + 1 << 16   ' Host mode
    USB_V1DMODE_LS = %1_11010_0 + 1 << 16   ' Device mode
    USB_V1HMODE_FS = %1_11001_0 + 1 << 16
    USB_V1DMODE_FS = %1_11011_0 + 1 << 16
' On RevB+ the USB smart pin mode is set to the D- and D+ pins via (WRPIN USBMode, pin#):
    USB_V2_DRVOUT  = %1_11011_0 + 1 << 16
    USB_V2_SNIFF   = %0_11011_0 + 1 << 16   ' Disable output to create a USB "sniffer"
' To configure NCO baud, host/device for LS/FS, set the appropriate mode to the D- pin# (WXPIN NCOMode, D-)
'   USB_H_LS_NCO   = %10 << 14 + _1_5Mbps   ' Host mode at NCO baud
'   USB_D_LS_NCO   = %00 << 14 + _1_5Mbps   ' Device mode at NCO baud
'   USB_H_FS_NCO   = %11 << 14 + _12Mbps
'   USB_D_FS_NCO   = %01 << 14 + _12Mbps
'------------------------------------------------------------------------------
' Time delays and intervals
' Useful USB constants and wait intervals:
    XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
    TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
    NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
    IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
    OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
' Standard Device request maximum timeout periods (reference):
{
    TO_STANDARD  = _1ms * 5000              ' Non-specific maximum timout period
    TO_DATA      = _1ms * 500               ' Standard Device requests with a data stage
    TO_NODATA    = _1ms * 50                ' Standard Device requests without a data stage
    TO_SETADDR   = _1ms * 50                ' Device SetAddress() command processing maximum
    TO_CHGADDR   = _1ms * 2                 ' Device SetAddress() period allowed to change its address before next request sent
}
'------------------------------------------------------------------------------
' Token packet format.
'------------------------------------------------------------------------------
'                   CRC5  ENDP ADDRESS PID
    CRC_MASK     = %11111_0000_0000000_00000000
    EP_MASK      = %00000_1111_0000000_00000000
    ADDR_MASK    = %00000_0000_1111111_00000000
    EP_ADDR_MASK = %00000_1111_1111111_11111111
    EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
'------------------------------------------------------------------------------
' Packet Identifier Bytes (PID). Notice that the first two LSBits are
' identical for each group.
'------------------------------------------------------------------------------
' Token:
    PID_OUT   = %1110_0001                  ' $e1
    PID_IN    = %0110_1001                  ' $69
    PID_SOF   = %1010_0101                  ' $a5
    PID_SETUP = %0010_1101                  ' $2d
' Data:
    PID_DATA0 = %1100_0011                  ' $c3
    PID_DATA1 = %0100_1011                  ' $4b
    PID_DATA2 = %1000_0111                  ' $87
    PID_MDATA = %0000_1111                  ' $0f
' Handshake:
    PID_ACK   = %1101_0010                  ' $d2
    PID_NAK   = %0101_1010                  ' $5a
    PID_STALL = %0001_1110                  ' $1e
    PID_NYET  = %1001_0110                  ' $96
' Special:
    PID_PRE   = %0011_1100                  ' $3c
    PID_ERR   = %0011_1100                  ' $3c
    PID_SPLIT = %0111_1000                  ' $78
    PID_PING  = %1011_0100                  ' $b4
    PID_RESVD = %1111_0000                  ' $f0
' Tx, rx and host related constants
' USB transmitter WYPIN D line state options:
    OUT_IDLE = 0
    OUT_SE0  = 1
    OUT_K    = 2
    OUT_J    = 3
    OUT_EOP  = 4
    OUT_SOP  = $80
' USB receiver RDPIN status bit positions:
    #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
' USB receiver RDPIN status bitflags:
    J_IDLEF    = decod(J_IDLEB)
    K_RESUMEF  = decod(K_RESUMEB)
    SE0_RESETF = decod(SE0_RESETB)
    SE1_BADF   = decod(SE1_BADB)
    SOPF       = decod(SOPB)
    EOPF       = decod(EOPB)
    BUS_ERRF   = decod(BUS_ERRB)
    BYTE_TGLF  = decod(BYTE_TGLB)
' USB CRC constants:
    USB5_POLY      = %0_0101 rev (5 - 1)    ' USB5 polynomial is reflected when calculating CRC
    USB5_RESIDUAL  = %0_1100 rev (5 - 1)    ' Expected CRC5 residual value when checking received data
    USB16_POLY     = $8005 rev (16 - 1)     ' USB16 polynomial is reflected when calculating CRC
    USB16_RESIDUAL = $800d rev (16 - 1)     ' Expected CRC16 residual value when checking received data
' Host->class driver USB connect speed:
    #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
    #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB[4], DWNSTRM_HUBB, SUSPENDB, KBM_TOGGLEB
' Host status bitflags. Unless otherwise noted, bit states are active high:
    IDLEF        = decod(IDLEB)             ' Set when USB in idle state
    CONNECTEDF   = decod(CONNECTEDB)        ' USB device connected
    LOW_SPEEDF   = decod(LOW_SPEEDB)        ' Low-speed device connected, clear if full-speed
    DATAx_TGLF   = decod(DATAx_TGLB)        ' Cleared if sending DATA0 packet, set if sending DATA1 packet
'   EOPF         = decod(EOPB)              ' Same bit position as the USB rx RDPIN status constants defined above
'   BUS_ERRF     = decod(BUS_ERRB)          ' Same bit position as the USB rx RDPIN status constants defined above
'   BYTE_TGLF    = decod(BYTE_TGLB)         ' Same bit position as the USB rx RDPIN status constants defined above
    DWNSTRM_HUBF = decod(DWNSTRM_HUBB)      ' NYI: downstream hub(s) connected
    SUSPENDF     = decod(SUSPENDB)          ' NYI: command the host to signal a global suspend
'------------------------------------------------------------------------------
' P2 silicon revision detection:
'------------------------------------------------------------------------------
    #1, P2RevA, P2RevB
'------------------------------------------------------------------------------

CON ' USB Descriptor Definitions
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
'------------------------------------------------------------------------------
' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
' Use TYPE_STANDARD for all USB Standard Device Request codes.
'------------------------------------------------------------------------------
' D7 Data direction  | D6:5 Type    | D4:0 Recipient
'------------------------------------------------------------------------------
' 0 - Host-to-device | 0 = Standard | 0 = Device
' 1 - Device-to-host | 1 = Class    | 1 = Interface
'                    | 2 = Vendor   | 2 = Endpoint
'                    | 3 = Reserved | 3 = Other
'                    |              | 4 -31 = Reserved
'------------------------------------------------------------------------------
    DIR_HOST_TO_DEV = 0 << 7
    DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
    TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
    TYPE_CLASS      = %01 << 5
    TYPE_VENDOR     = %10 << 5
    TYPE_RESERVED   = %11 << 5
    RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
    RECIP_INTERFACE = %0_0001
    RECIP_ENDPOINT  = %0_0010
    RECIP_OTHER     = %0_0011
'    RECIP 4 - 31 = Reserved
'------------------------------------------------------------------------------
' Standard Device Request codes (Section 9.4, Table 9-4):
'------------------------------------------------------------------------------
    #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
    REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
    REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
'------------------------------------------------------------------------------
' Standard descriptor types (Section 9.4, Table 9-5):
'------------------------------------------------------------------------------
    #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
    TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
'------------------------------------------------------------------------------
' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
'------------------------------------------------------------------------------
    #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
    CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
    CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
    CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
    CLASS_DIAGNOSTIC_DEV  = $dc
    CLASS_WIRELESS_CTRL   = $e0
    CLASS_MISCELLANEOUS   = $ef
    CLASS_APP_SPECIFIC    = $fe
    CLASS_VENDOR_SPECIFIC = $ff
'------------------------------------------------------------------------------
' HUB Class Requests
'------------------------------------------------------------------------------
    #0, HUB_PORT_CONNECTION, HUB_PORT_ENABLE, HUB_PORT_SUSPEND, HUB_PORT_OVERCURRENT
    HUB_PORT_RESET[4], HUB_PORT_POWER, HUB_PORT_LOWSPEED[7]
    HUB_C_PORT_CONNECTION, HUB_C_PORT_ENABLE, HUB_C_PORT_SUSPEND, HUB_C_PORT_OVERCURRENT
    HUB_C_PORT_RESET, HUB_PORT_TEST, HUB_PORT_INDICATOR
'------------------------------------------------------------------------------
' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
'------------------------------------------------------------------------------
    #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
    HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
' HID Descriptor types:
    #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
    #$29, TYPE_HUB
'------------------------------------------------------------------------------
' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
'------------------------------------------------------------------------------
    #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
'------------------------------------------------------------------------------
' HID Interface SubClasses:
'------------------------------------------------------------------------------
    #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
'------------------------------------------------------------------------------
' HID Protocol codes:
'------------------------------------------------------------------------------
    #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
    #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
'------------------------------------------------------------------------------
' Other HID buffer lengths:
'------------------------------------------------------------------------------
    MAX_HID_REPTS   = 4             ' We have this many HID report buffers
    REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
    REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
    LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
    USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
'------------------------------------------------------------------------------
' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
'------------------------------------------------------------------------------
    LANG_ENG_US  = $0409            ' English (United States)
    LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
'------------------------------------------------------------------------------
' SETUP structure member offsets.
' NOTE: These offsets are defined in terms of the structure member's data type,
'       to take advantage of PTRA/B scaled indexing, e.g.:
'         RDBYTE D,   PTRA[bRequest]
'         WRWORD D/#, PTRA[wLength]
'------------------------------------------------------------------------------
    bmRequestType = 0
    bRequest      = 1
    wValue        = 1
    wIndex        = 2
    wLength       = 3
' SETUP bmRequestType combinations:
{
    HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
    DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
    HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
    HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
}
'------------------------------------------------------------------------------
' Standard USB descriptor structure sizes in bytes. The values defined are the
' minimum size of the descriptor:
'------------------------------------------------------------------------------
    SETUP_TXN_LEN = 8
    DEV_DESC_LEN  = 18
    CON_DESC_LEN  = 9
    INTF_DESC_LEN = 9
    ENDP_DESC_LEN = 7
    STR0_DESC_LEN = 4
    USTR_DESC_LEN = 4
'------------------------------------------------------------------------------
' Other USB-related buffer sizes:
'------------------------------------------------------------------------------
    URX_BUFF_LEN = 128      ' USB receiver scratch buffer
    CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
'------------------------------------------------------------------------------
' CON_bmAttrs member bit positions:
'------------------------------------------------------------------------------
    ATTR_RESVB     = 7      ' Reserved (should always be one)
    ATTR_SELF_PWRB = 6      ' Device Self-Powered
    ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
'    bmAttributes bits 4..0 reserved and reset to zero
'------------------------------------------------------------------------------
' Standard USB descriptor struct member offset and member size, in bytes. Note
' that the DESC_bLength and DESC_bDescType members are defined in all of the
' descriptors (including HID) at the offsets shown.
'------------------+
' !!! IMPORTANT !!!|
'------------------+
' All standard descriptor member offsets are defined in bytes, so if you want
' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
'       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
' If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
' must be very careful...
'------------------------------------------------------------------------------
'       Member          Offset  Size    Value           Description
'------------------------------------------------------------------------------
    DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
    DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
' Device Descriptor (Section 9.6.1, Table 9-8):
    DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
    DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
    DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
    DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
    DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
    DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
    DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
    DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
    DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
    DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
    DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
    DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
  ' Configuration Descriptor (Section 9.6.3, Table 9-10):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
    CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
    CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
    CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
    CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
    CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
    CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
' Interface Descriptor (Section 9.6.5, Table 9-12):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
    INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
    INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
    INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
    INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
    INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
                            '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
                            '                       reserved for assignment by the USB-IF.
    INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
                            '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
                            '                       vendor-specific protocol for this interface.
    INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
' Endpoint Descriptor (Section 9.6.6, Table 9-13):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
    ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
    ENDP_bmAttrs     = 3    ' 1     Bitmap
    ENDP_wMaxPktSize = 4    ' 2     Number
    ENDP_bInterval   = 6    ' 1     Number
' String Descriptor Zero (Section 9.6.7, Table 9-15):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
' Unicode String Descriptor (Section 9.6.7, Table 9-16):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    USTR_wString     = 2    ' N     wString[(N - 2) / 2]
'------------------------------------------------------------------------------
' HID Descriptor (Section 6.2.1)
'------------------------------------------------------------------------------
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
    HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
    HID_bCountryCode = 4    ' 1     Number          Hardware target country
    HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
    HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
    HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).

' Keyboard report data buffer lengths (boot protocol):
    KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
    KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size

DAT             ' CGA
                org     $000

video_driver
                setcmod #%01_0_000_1            ' enable colorspace conversion
                '                  ^------------- horizontal polarity (1=negative, 0=positive)
                setcy   ##CGA_INTENSITY << 24   ' r      set colorspace for rgb
                setci   ##CGA_INTENSITY << 16   ' g
                setcq   ##CGA_INTENSITY << 08   ' b
                setxfrq cga_xf                  ' set transfer frequency

                cogid   pa                      ' insert cogid into dac modes
                setnib  cga_dacmode_s, pa, #2
                setnib  cga_dacmode_c, pa, #2

                wrpin   cga_dacmode_s, cga_pin_base ' enable 123-ohm 3.3V dac mode in pin +0

                xor     cga_pin_base, #2 << 6 | 1   ' enable 75-ohm 2.0V dac mode in pins +1..3
                wrpin   cga_dacmode_c, cga_pin_base

                xor     cga_pin_base, #3 << 6 ^ (2 << 6 | 1) ' make pins +0..3 outputs
                drvl    cga_pin_base

                xor     cga_pin_base, #4 | (3 << 6) ' leave av_base pointing to pin +4 (vertical sync)
                drvl    cga_pin_base                ' vertical polarity (drvh=negative, drvl=positive)

                mov     ptra, cga_chr_p             ' adjust font bitmap for rendering
                rep     @.chloop, #(8 * 256 / 4) -1 ' |
                rdlong  cga_tmp0, ptra              ' |
                rev     cga_tmp0                    ' |
                movbyts cga_tmp0, #%%0123           ' |
                wrlong  cga_tmp0, ptra++            ' |
.chloop

.frame_loop
                rdword  cga_tmp0, #@cga_io_03D8
                getbyte cga_03D8, cga_tmp0, #0      ' Mode Select Register
                getbyte cga_03D9, cga_tmp0, #1      ' Color Select Register

                testb   cga_03D8, #CGA_MODE_ENABLE  wz
        if_x0   setword cga_flags, #cga_blank, #0
        if_x0   jmp     #.end_config

                testb   cga_03D8, #CGA_MODE_GRAPH   wz
        if_x0   jmp     #.text_mode

                getnib  cga_lut0, cga_03D9, #0
                altd    cga_lut0, #cga_palette
                wrlut   0-0, #0 ' Background

                testb   cga_03D8, #CGA_MODE_640     wz
        if_x1   jmp     #.graphics_640x200

                testb   cga_03D9, #CGA_COLOR_BLUE   wz
        if_x0   mov     cga_lut1, cga_palette + %0010 ' Green
        if_x0   mov     cga_lut2, cga_palette + %0100 ' Red
        if_x0   mov     cga_lut3, cga_palette + %0110 ' Brown
        if_x1   mov     cga_lut1, cga_palette + %0011 ' Light Cyan
        if_x1   mov     cga_lut2, cga_palette + %0101 ' Light Magenta
        if_x1   mov     cga_lut3, cga_palette + %0111 ' High Intensity White
                testb   cga_03D8, #CGA_MODE_CBURST  wz
        if_x1   mov     cga_lut1, cga_palette + %0011 ' Light Cyan
        if_x1   mov     cga_lut2, cga_palette + %0100 ' Light Red
        if_x1   mov     cga_lut3, cga_palette + %0111 ' High Intensity White

                testb   cga_03D9, #CGA_COLOR_HIGH   wz
        if_x1   add     cga_lut1, #%1000
        if_x1   add     cga_lut2, #%1000
        if_x1   add     cga_lut3, #%1000
                wrlut   cga_lut1, #1
                wrlut   cga_lut2, #2
                wrlut   cga_lut3, #3

                setword cga_flags, #cga_graphics_320x200, #0

                jmp     #.end_config

.graphics_640x200
                testb   cga_03D9, #CGA_COLOR_HIGH   wz
        if_x0   wrlut   cga_palette + %0111, #1 ' White
        if_x1   wrlut   cga_palette + %1111, #1 ' White

                setword cga_flags, #cga_graphics_640x200, #0

                jmp     #.end_config

.text_mode
                rdword  cga_tmp0, #@cga_io_mc6845 + 10
                getbyte cga_mc6845_10, cga_tmp0, #0         ' cursor start scanline
                getbyte cga_mc6845_11, cga_tmp0, #1         ' cursor end scanline

                testb   cga_03D8, #CGA_MODE_80COL   wz
        if_x0   setword cga_flags, #cga_text_40x25, #0
        if_x1   setword cga_flags, #cga_text_80x25, #0

.end_config
                incmod  cga_bcnt, #32       wc
        if_c    bitnot  cga_flags, #CGA_BLINK1_ON

                mov     cga_tmp0, cga_mc6845_10
                and     cga_tmp0, #%00000_11_0  wz
        if_z    bith    cga_flags, #CGA_BLINK2_ON
                cmp     cga_tmp0, #%00000_01_0  wz
        if_z    bitl    cga_flags, #CGA_BLINK2_ON
                cmp     cga_tmp0, #%00000_10_0  wz
        if_z    incmod  cga_ccnt, #16 - 1   wc
  if_z_and_c    bitnot  cga_flags, #CGA_BLINK2_ON
                cmp     cga_tmp0, #%00000_11_0  wz
        if_z    incmod  cga_ccnt, #32 - 1   wc
  if_z_and_c    bitnot  cga_flags, #CGA_BLINK2_ON

                and     cga_mc6845_10, #%000_11111
                and     cga_mc6845_11, #%000_11111

                rdlong  cga_tmp0, #@cga_io_mc6845 + 12
                movbyts cga_tmp0, #%%2301

                getword cga_ramptr, cga_tmp0, #0        ' start of displayed page
                and     cga_ramptr, ##%00_111111_11111111
                add     cga_ramptr, cga_ram_p

                getword cga_cpos, cga_tmp0, #1          ' cursor offset address in vid mem
                and     cga_cpos, ##%00_111111_11111111

                drvnot  cga_pin_base                ' vertical sync on
                callpa  #2, #.blank
                drvnot  cga_pin_base                ' vertical sync off

                callpa  #35, #.blank             ' back porch + top border
                bitl    cga_03DA, #3

                mov     cga_cptr, #0
                mov     cga_lcnt, #200

.line_loop
                bith    cga_flags, #CGA_CURSOR_SCANLINE
                cmp     cga_lofs, cga_mc6845_10 wcz
        if_b    bitl    cga_flags, #CGA_CURSOR_SCANLINE
                cmp     cga_lofs, cga_mc6845_11 wcz
        if_a    bitl    cga_flags, #CGA_CURSOR_SCANLINE

                call    cga_flags
                djnz    cga_lcnt, #.line_loop

                bith    cga_03DA, #3
                callpa  #12, #.blank              ' bottom border + front porch

                jmp     #.frame_loop

.blank
                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xzero   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_db, #0                  ' do visible part of scan line
        _ret_   djnz    pa, #.blank                 ' loop if more blanks needed

' Blank Screen

cga_blank
                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xzero   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_db, #0                  ' do visible part of scan line

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xzero   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
        _ret_   xcont   cga_db, #0                  ' do visible part of scan line

' Text 80x25

cga_text_80x25
                mov     pb, #2
.l1
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xzero   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #80 / 4
.l2
                mov     cga_lut0, #%0000_00000
                mov     cga_lut1, #%0000_00001
                setnib  cga_dv8, #%0000, #4

                rep     @.l3, #4
                rfword  cga_chattr

                getbyte cga_tmp0, cga_chattr, #0
                shl     cga_tmp0, #3
                add     cga_tmp0, cga_chr_p
                rdbyte  cga_bmp, cga_tmp0

                testb   cga_03D9, #CGA_MODE_BLINK   wc
        if_1x   bitl    cga_chattr, #15             wcz
                testb   cga_flags, #CGA_BLINK1_ON   andc
        if_c    mov     cga_bmp, #0

                cmp     cga_cptr, cga_cpos              wz
                testb   cga_flags, #CGA_BLINK2_ON       andz
                testb   cga_flags, #CGA_CURSOR_SCANLINE andz
        if_z    or      cga_bmp, #%11111111

                getnib  cga_tmp0, cga_chattr, #3    ' background
                altd    cga_tmp0, #cga_palette      '
                wrlut   0-0, cga_lut0             '
                getnib  cga_tmp0, cga_chattr, #2    ' foreground
                altd    cga_tmp0, #cga_palette      '
                wrlut   0-0, cga_lut1    '
                xcont   cga_dv8, cga_bmp

                add     cga_cptr, #1
                add     cga_lut0, #%0001_00000
                add     cga_lut1, #%0001_00000
                add     cga_dv8, ##$1_0000
.l3
                djnz    pa, #.l2

                sub     cga_cptr, #80
                djnz    pb, #.l1

                add     cga_chr_p, #1

                incmod  cga_lofs, #8 - 1   wc
        if_c    add     cga_cptr, #80
        if_c    add     cga_ramptr, #80 * 2
        if_c    sub     cga_chr_p, #8

                ret

' Text 40x25

cga_text_40x25
                mov     pb, #2
.l1
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xzero   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #40 / 4
.l2
                mov     cga_lut0, #%0000_00000
                mov     cga_lut1, #%0000_00001
                setnib  cga_dv16, #%0000, #4

                rep     @.l3, #4
                rfword  cga_chattr

                getbyte cga_tmp0, cga_chattr, #0
                shl     cga_tmp0, #3
                add     cga_tmp0, cga_chr_p
                rdbyte  cga_bmp, cga_tmp0

                testb   cga_03D9, #CGA_MODE_BLINK   wc
        if_1x   bitl    cga_chattr, #15             wcz
                testb   cga_flags, #CGA_BLINK1_ON   andc
        if_c    mov     cga_bmp, #0

                cmp     cga_cptr, cga_cpos              wz
                testb   cga_flags, #CGA_BLINK2_ON       andz
                testb   cga_flags, #CGA_CURSOR_SCANLINE andz
        if_z    or      cga_bmp, #%11111111

                setword cga_bmp, cga_bmp, #1
                mergew  cga_bmp

                getnib  cga_tmp0, cga_chattr, #3    ' background
                altd    cga_tmp0, #cga_palette      '
                wrlut   0-0, cga_lut0               '
                getnib  cga_tmp0, cga_chattr, #2    ' foreground
                altd    cga_tmp0, #cga_palette      '
                wrlut   0-0, cga_lut1               '
                xcont   cga_dv16, cga_bmp

                add     cga_cptr, #1
                add     cga_lut0, #%0001_00000
                add     cga_lut1, #%0001_00000
                add     cga_dv16, ##$1_0000
.l3
                djnz    pa, #.l2

                sub     cga_cptr, #40
                djnz    pb, #.l1

                add     cga_chr_p, #1

                incmod  cga_lofs, #8 - 1    wc
        if_c    add     cga_cptr, #40
        if_c    add     cga_ramptr, #40 * 2
        if_c    sub     cga_chr_p, #8

                ret

' Graphics 320x200x2bpp

cga_graphics_320x200
                mov     pb, #2
.l1
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xzero   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #320 / 4
.l2
                rfbyte  cga_tmp0
                testb   cga_tmp0, #7  wc
                testb   cga_tmp0, #6  wz
                muxc    cga_bmp, cga_muxc00
                muxz    cga_bmp, cga_muxz00

                testb   cga_tmp0, #5  wc
                testb   cga_tmp0, #4  wz
                muxc    cga_bmp, cga_muxc11
                muxz    cga_bmp, cga_muxz11

                testb   cga_tmp0, #3  wc
                testb   cga_tmp0, #2  wz
                muxc    cga_bmp, cga_muxc22
                muxz    cga_bmp, cga_muxz22

                testb   cga_tmp0, #1  wc
                testb   cga_tmp0, #0  wz
                muxc    cga_bmp, cga_muxc33
                muxz    cga_bmp, cga_muxz33

                xcont   cga_dv8b, cga_bmp
                djnz    pa, #.l2

                djnz    pb, #.l1

                sub     cga_ramptr, cga_ram_p
                bitnot  cga_ramptr, #13     wcz
        if_x1   add     cga_ramptr, #320 / 4
        _ret_   add     cga_ramptr, cga_ram_p

cga_muxc00      long    %0000__0000__0000__1010
cga_muxz00      long    %0000__0000__0000__0101
cga_muxc11      long    %0000__0000__1010__0000
cga_muxz11      long    %0000__0000__0101__0000
cga_muxc22      long    %0000__1010__0000__0000
cga_muxz22      long    %0000__0101__0000__0000
cga_muxc33      long    %1010__0000__0000__0000
cga_muxz33      long    %0101__0000__0000__0000

' Graphics 640x200x1bpp

cga_graphics_640x200
                mov     pb, #2
.l1
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xzero   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #640 / 8
.l2
                rfbyte  cga_bmp
                rev     cga_bmp
                shr     cga_bmp, #24
                xcont   cga_dv8, cga_bmp
                djnz    pa, #.l2

                djnz    pb, #.l1

                sub     cga_ramptr, cga_ram_p
                bitnot  cga_ramptr, #13     wcz
        if_x1   add     cga_ramptr, #640 / 8
        _ret_   add     cga_ramptr, cga_ram_p

cga_reg_p       long    0
cga_ram_p       long    @ram_00000 + RAM_SIZE
cga_chr_p       long    @cga_charrom

cga_03D8        long    0
cga_03D9        long    0
cga_03DA        long    0

cga_mc6845_10   long    0
cga_mc6845_11   long    0

cga_palette
                                    ' h rgb
                long    $000000_00  ' 0 000     0
                long    $0000AA_00  ' 0 001     1
                long    $00AA00_00  ' 0 010     2
                long    $00AAAA_00  ' 0 011     3
                long    $AA0000_00  ' 0 100     4
                long    $AA00AA_00  ' 0 101     5
                long    $AA5500_00  ' 0 110     6
                long    $AAAAAA_00  ' 0 111     7
                long    $555555_00  ' 1 000     8
                long    $5555FF_00  ' 1 001     9
                long    $55FF55_00  ' 1 010     A
                long    $55FFFF_00  ' 1 011     B
                long    $FF5555_00  ' 1 100     C
                long    $FF55FF_00  ' 1 101     D
                long    $FFFF55_00  ' 1 110     E
                long    $FFFFFF_00  ' 1 111     F

cga_pin_base    long    VGA_PIN & $38                    ' base pin
cga_dacmode_s   long    P_DAC_124R_3V + P_CHANNEL        ' hsync is 123-ohm, 3.3V
cga_dacmode_c   long    P_DAC_75R_2V + P_CHANNEL         ' R/G/B are 75-ohm, 2.0V

cga_xf          long    (CGA_FPIX frac _CLKFREQ) >> 1           ' streamer frequency setting
cga_bs          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  16 ' streamer command: before-sync
cga_ds          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  96 ' streamer command: during-sync
cga_as          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  48 ' streamer command: after sync
cga_db          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 + 640 ' streamer command: during-blank

cga_dv8         long    X_IMM_32X1_LUT | X_DACS_3_2_1_0 | %0000 << 16 + 8 ' streamer command: during visible
cga_dv8b        long    X_IMM_16X2_LUT | X_DACS_3_2_1_0 | %0000 << 16 + 8 ' streamer command: during visible
cga_dv16        long    X_IMM_32X1_LUT | X_DACS_3_2_1_0 | %0000 << 16 + 16 ' streamer command: during visible

cga_cpos        long    0               ' cursor position (from MC6845)
cga_flags       long    cga_blank       ' 31..20 flags
                                        '  19..0 line handler routine

cga_cptr        long    0
cga_ramptr      long    0

cga_chattr      long    0
cga_bmp         long    0
cga_lut0        long    0
cga_lut1        long    0
cga_lut2        long    0
cga_lut3        long    0

cga_bcnt        long    0
cga_ccnt        long    0
cga_lcnt        long    0
cga_lofs        long    0

cga_tmp0        res     1

CON ' CGA constants

    CGA_FPIX = 25_175_000
    CGA_INTENSITY = 80      '0..128

    CGA_BLINK1_ON = 31
    CGA_BLINK2_ON = 30
    CGA_CURSOR_SCANLINE = 29

    CGA_MODE_80COL  = 0
    CGA_MODE_GRAPH  = 1
    CGA_MODE_CBURST = 2
    CGA_MODE_ENABLE = 3
    CGA_MODE_640    = 4
    CGA_MODE_BLINK  = 5

    CGA_COLOR_BG    = %00_001111
    CGA_COLOR_HIGH  = 4
    CGA_COLOR_BLUE  = 5

DAT             ' 8086
                org     $000

i8086
                add     ptrb, ##@i8086_lut - @i8086
                setq2   #(@i8086_lut_end - @i8086_lut) / 4 -1
                rdlong  0, ptrb

                setse1  #%001_000000 | CPU_PIN  ' setup events from CPU arbiter pin
                waitatn                         ' wait arbiter COG ready
                pollse1                         ' clear stale the event

                'call    #\@i_system_init

                mov     i_optable, ##@i8086_optable
                getct   i_lastwait

.nextop
                getct   i_total
                sub     i_total, i_lastwait

                'add     i_total, i_cycles
                bitl    i_flags, #I_SEG_BIT

                call    #\@i_system_run

                bitl    i_flags, #I_NO_INT_BIT  wcz
                testb   i_flags, #I_TF_BIT      wz
        if_01   mov     i_temp0, #1
        if_01   call    #\@i_trap

                getct   i_lastwait
                mov     i_cycles, #0
                getword i_ip_start, i_ip, #0

.loop
                call    #\i_readcodeb
                mov     i_opcode, i_tmpb

                cmp     i_opcode, #$26      wz
        if_ne   cmp     i_opcode, #$2E      wz
        if_ne   cmp     i_opcode, #$36      wz
        if_ne   cmp     i_opcode, #$3E      wz
        if_e    jmp     #.seg

                cmp     i_opcode, #$F2      wz
        if_ne   cmp     i_opcode, #$F3      wz
        if_e    jmp     #.rep

                shl     i_tmpb, #2
                add     i_tmpb, i_optable
                rdlong  i_opimpl, i_tmpb

                bitl    i_flags, #I_REP_BIT wcz
        if_11   call    #.rep_valid
        if_11   jmp     #.repeat

                push    #.nextop
                jmp     i_opimpl

.seg
                cmp     i_opcode, #$26      wz
        if_e    mov     i_override, i_es
                cmp     i_opcode, #$2E      wz
        if_e    mov     i_override, i_cs
                cmp     i_opcode, #$36      wz
        if_e    mov     i_override, i_ss
                cmp     i_opcode, #$3E      wz
        if_e    mov     i_override, i_ds
                bith    i_flags, #I_SEG_BIT
                add     i_cycles, #2
                jmp     #.loop

.rep
                bith    i_flags, #I_REP_BIT

                testb   i_opcode, #0        wz
                bitz    i_flags, #I_REP_ZF_BIT

                add     i_cycles, #2
                jmp     #.loop

.rep_valid
                cmp     i_opcode, #$A4        wz
        if_ne   cmp     i_opcode, #$A5        wz
        if_ne   cmp     i_opcode, #$AA        wz
        if_ne   cmp     i_opcode, #$AB        wz
        if_ne   cmp     i_opcode, #$AC        wz
        if_ne   cmp     i_opcode, #$AD        wz
        if_ne   cmp     i_opcode, #$A6        wz
        if_ne   cmp     i_opcode, #$A7        wz
        if_ne   cmp     i_opcode, #$AE        wz
        if_ne   cmp     i_opcode, #$AF        wz
                ret

.repeat
                cmp     i_cx, #0            wz
        if_z    jmp     #.nextop

                call    i_opimpl
                sub     i_cx, #1

                cmp     i_opcode, #$A4      wz
        if_ne   cmp     i_opcode, #$A5      wz
        if_ne   cmp     i_opcode, #$AA      wz
        if_ne   cmp     i_opcode, #$AB      wz
        if_ne   cmp     i_opcode, #$AC      wz
        if_ne   cmp     i_opcode, #$AD      wz
        if_e    jmp     #.repeat

                testb   i_flags, #I_REP_ZF_BIT  wc
                testb   i_flags, #I_ZF_BIT      wz
    if_c_eq_z   jmp     #.repeat

                jmp     #.nextop

i_esc_op
                ' fall-through
i_readcodeb
                getword i_ea, i_cs, #0
                shl     i_ea, #4
                add     i_ea, i_ip
                incmod  i_ip, i_ffffh
                jmp     #\i_readmemb

i_readimmb
                call    #\i_readcodeb
        _ret_   getbyte i_data, i_tmpb, #0

i_readimmw
                call    #\i_readcodeb
                getbyte i_data, i_tmpb, #0
                call    #\i_readcodeb
        _ret_   setbyte i_data, i_tmpb, #1

' +-----+---------------+------------------+-------------------+---------+---------+
' | mod |      00       |       01         |        10         |   11    |         |
' +-----+---------------+------------------+-------------------+---------+---------+
' | r/m |               |                  |                   |         |   reg   |
' +-----+---------------+------------------+-------------------+---------+----+----+
' | 000 | [DS:BX+SI]    | [DS:BX+SI+disp8] | [DS:BX+SI+disp16] | [DS:AX] | AL | AX |
' | 001 | [DS:BX+DI]    | [DS:BX+DI+disp8] | [DS:BX+DI+disp16] | [DS:CX] | CL | CX |
' | 010 | [SS:BP+SI]    | [SS:BP+SI+disp8] | [SS:BP+SI+disp16] | [DS:DX] | DL | DX |
' | 011 | [SS:BP+DI]    | [SS:BP+DI+disp8] | [SS:BP+DI+disp16] | [DS:BX] | BL | BX |
' | 100 | [DS:SI]       | [DS:SI+disp8]    | [DS:SI+disp16]    | [DS:SP] | AH | SP |
' | 101 | [DS:DI]       | [DS:DI+disp8]    | [DS:DI+disp16]    | [DS:BP] | CH | BP |
' | 110 | [DS:disp16]   | [SS:BP+disp8]    | [SS:BP+disp16]    | [DS:SI] | DH | SI |
' | 111 | [DS:BX]       | [DS:BX+disp8]    | [DS:BX+disp16]    | [DS:DI] | BH | DI |
' +-----+---------------+------------------+-------------------+---------+----+----+

'   setup i_ea based on i_modrm bits

i_setupmodrm
                call    #\i_readcodeb
                mov     i_modrm, i_tmpb
i_setupmodrm2
                getword i_segment, i_ds, #0
                mov     i_offset, #0
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
                mov     i_modrm0, i_modrm
                and     i_modrm0, #%00_000_111
        if_00   call    #\_mod00
        if_01   call    #\_mod01
        if_10   call    #\_mod10
        if_11   call    #\_mod11
        _ret_   getword i_offset, i_offset, #0

i_setupea
                add     i_cycles, #2
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_segment, #0
                shl     i_ea, #4
        _ret_   add     i_ea, i_offset

_mod00
                altgw   i_modrm0, #i_modrm_00
                getword i_modrm0
                jmp     i_modrm0
_mod01
                add     i_cycles, #4
                call    #\i_readcodeb
                signx   i_tmpb, #7
                add     i_offset, i_tmpb
                jmp     #_modxx
_mod10
                add     i_cycles, #4
                call    #\i_readcodeb
                getbyte i_temp0, i_tmpb, #0
                call    #\i_readcodeb
                setbyte i_temp0, i_tmpb, #1
                add     i_offset, i_temp0
_modxx
                altgw   i_modrm0, #i_modrm_xx
                getword i_modrm0
                jmp     i_modrm0
_mod11
                jmprel  i_modrm0
        _ret_   getword i_offset, i_ax, #0
        _ret_   getword i_offset, i_cx, #0
        _ret_   getword i_offset, i_dx, #0
        _ret_   getword i_offset, i_bx, #0
        _ret_   getword i_offset, i_sp, #0
        _ret_   getword i_offset, i_bp, #0
        _ret_   getword i_offset, i_si, #0
        _ret_   getword i_offset, i_di, #0

i_modrm_00      word    i_modrm_00_xxx_000, i_modrm_00_xxx_001, i_modrm_00_xxx_010, i_modrm_00_xxx_011
                word    i_modrm_00_xxx_100, i_modrm_00_xxx_101, i_modrm_00_xxx_110, i_modrm_00_xxx_111

i_modrm_xx      word    i_modrm_00_xxx_000, i_modrm_00_xxx_001, i_modrm_00_xxx_010, i_modrm_00_xxx_011
                word    i_modrm_00_xxx_100, i_modrm_00_xxx_101, i_modrm_xx_xxx_110, i_modrm_00_xxx_111

i_modrm_00_xxx_000
                add     i_cycles, #7
                add     i_offset, i_bx
        _ret_   add     i_offset, i_si
i_modrm_00_xxx_001
                add     i_cycles, #8
                add     i_offset, i_bx
        _ret_   add     i_offset, i_di
i_modrm_00_xxx_010
                add     i_cycles, #8
                getword i_segment, i_ss, #0
                add     i_offset, i_bp
        _ret_   add     i_offset, i_si
i_modrm_00_xxx_011
                add     i_cycles, #7
                getword i_segment, i_ss, #0
                add     i_offset, i_bp
        _ret_   add     i_offset, i_di
i_modrm_00_xxx_100
                add     i_cycles, #5
        _ret_   add     i_offset, i_si
i_modrm_00_xxx_101
                add     i_cycles, #5
        _ret_   add     i_offset, i_di
i_modrm_00_xxx_110
                add     i_cycles, #6 + 4
                call    #\i_readcodeb
                getbyte i_temp0, i_tmpb, #0
                call    #\i_readcodeb
                setbyte i_temp0, i_tmpb, #1
        _ret_   add     i_offset, i_temp0
i_modrm_00_xxx_111
                add     i_cycles, #5
        _ret_   add     i_offset, i_bx

i_modrm_xx_xxx_110
                add     i_cycles, #5
                getword i_segment, i_ss, #0
        _ret_   add     i_offset, i_bp

' get 8-bit register based on i_modrm bits 5..3

i_getmodr8
                mov     pa, i_modrm
                shr     pa, #3
i_getr8
                and     pa, #7
                jmprel  pa
        _ret_   getbyte i_data, i_ax, #0
        _ret_   getbyte i_data, i_cx, #0
        _ret_   getbyte i_data, i_dx, #0
        _ret_   getbyte i_data, i_bx, #0
        _ret_   getbyte i_data, i_ax, #1
        _ret_   getbyte i_data, i_cx, #1
        _ret_   getbyte i_data, i_dx, #1
        _ret_   getbyte i_data, i_bx, #1

' get 16-bit register based on i_modrm bits 5..3

i_getmodr16
                mov     pa, i_modrm
                shr     pa, #3
i_getr16
                and     pa, #7
                jmprel  pa
        _ret_   getword i_data, i_ax, #0
        _ret_   getword i_data, i_cx, #0
        _ret_   getword i_data, i_dx, #0
        _ret_   getword i_data, i_bx, #0
        _ret_   getword i_data, i_sp, #0
        _ret_   getword i_data, i_bp, #0
        _ret_   getword i_data, i_si, #0
        _ret_   getword i_data, i_di, #0


' set 8-bit register based on i_modrm bits 5..3

i_setmodr8
                mov     pa, i_modrm
                shr     pa, #3
i_setr8
                and     pa, #7
                jmprel  pa
        _ret_   setbyte i_ax, i_data, #0
        _ret_   setbyte i_cx, i_data, #0
        _ret_   setbyte i_dx, i_data, #0
        _ret_   setbyte i_bx, i_data, #0
        _ret_   setbyte i_ax, i_data, #1
        _ret_   setbyte i_cx, i_data, #1
        _ret_   setbyte i_dx, i_data, #1
        _ret_   setbyte i_bx, i_data, #1

' set 16-bit register based on i_modrm bits 5..3

i_setmodr16
                mov     pa, i_modrm
                shr     pa, #3
i_setr16
                and     pa, #7
                jmprel  pa
        _ret_   getword i_ax, i_data, #0
        _ret_   getword i_cx, i_data, #0
        _ret_   getword i_dx, i_data, #0
        _ret_   getword i_bx, i_data, #0
        _ret_   getword i_sp, i_data, #0
        _ret_   getword i_bp, i_data, #0
        _ret_   getword i_si, i_data, #0
        _ret_   getword i_di, i_data, #0

' get segment register based on i_modrm bits 5..3

i_getmodsreg
                mov     pa, i_modrm
i_getsreg
                shr     pa, #3
                and     pa, #3
                jmprel  pa
        _ret_   getword i_data, i_es, #0
        _ret_   getword i_data, i_cs, #0
        _ret_   getword i_data, i_ss, #0
        _ret_   getword i_data, i_ds, #0

' set segment register based on i_modrm bits 5..3

i_setmodsreg
                mov     pa, i_modrm
i_setsreg
                shr     pa, #3
                and     pa, #3
                jmprel  pa
        _ret_   getword i_es, i_data, #0
        _ret_   getword i_cs, i_data, #0
        _ret_   getword i_ss, i_data, #0
        _ret_   getword i_ds, i_data, #0

' --------------------------------------------------------------------

i_readopb
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_getr8
                call    #\i_setupea
                jmp     #\i_readb

i_writeopb
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_setr8
                call    #\i_setupea
                jmp     #\i_writeb

' --------------------------------------------------------------------

i_readopw
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_getr16
                call    #\i_setupea
                jmp     #\i_readw

i_writeopw
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_setr16
                call    #\i_setupea
                jmp     #\i_writew

' --------------------------------------------------------------------

i_readb
                add     i_cycles, #4
                call    #\i_readmemb
        _ret_   getbyte i_data, i_tmpb, #0

i_writeb
                add     i_cycles, #4
                getbyte i_tmpb, i_data, #0
                jmp     #\i_writememb

i_readw
                add     i_cycles, #4
                testb   i_ea, #0            wc
        if_c    add     i_cycles, #4
                call    #\i_readmemb
                getbyte i_data, i_tmpb, #0
                add     i_ea, #1
                call    #\i_readmemb
                setbyte i_data, i_tmpb, #1
        _ret_   add     i_ea, #1

i_writew
                add     i_cycles, #4
                testb   i_ea, #0            wc
        if_c    add     i_cycles, #4
                getbyte i_tmpb, i_data, #0
                call    #\i_writememb
                add     i_ea, #1
                getbyte i_tmpb, i_data, #1
                jmp     #\i_writememb

' --------------------------------------------------------------------

i_add_flags16
                testb   i_data0, #15        wc      ' (resultDst ^ resultSrc)
                testb   i_data1, #15        xorc    ' |
                testb   i_data1, #15        wz      ' (resultSrc ^ resultArith)
                testb   i_data, #15         xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                testb   i_data0, #15        xorz    ' (resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith)))
                bitz    i_flags, #I_CF_BIT
i_add_flags16_nc
                testb   i_data0, #15        wc      ' (resultDst ^ resultArith)
                testb   i_data, #15         xorc    ' |
                testb   i_data1, #15        wz      ' (resultSrc ^ resultArith)
                testb   i_data, #15         xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                bitz    i_flags, #I_OF_BIT

                testb   i_data0, #4         wz
                testb   i_data1, #4         xorz
                testb   i_data, #4          xorz
                bitz    i_flags, #I_AF_BIT

                test    i_data, #$FF        wcz
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, i_ffffh     wcz
        _ret_   bitz    i_flags, #I_ZF_BIT

i_sub_flags16
                testb   i_data, #15         wc      ' (resultDst ^ resultSrc)
                testb   i_data1, #15        xorc    ' |
                testb   i_data1, #15        wz      ' (resultSrc ^ resultArith)
                testb   i_data0, #15        xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                testb   i_data, #15         xorz    ' (resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith)))
                bitz    i_flags, #I_CF_BIT
i_sub_flags16_nc
                testb   i_data, #15         wc      ' (resultDst ^ resultArith)
                testb   i_data0, #15        xorc    ' |
                testb   i_data1, #15        wz      ' (resultSrc ^ resultArith)
                testb   i_data0, #15        xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                bitz    i_flags, #I_OF_BIT

                testb   i_data0, #4         wz
                testb   i_data1, #4         xorz
                testb   i_data, #4          xorz
                bitz    i_flags, #I_AF_BIT

                test    i_data, #$FF        wcz
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, i_ffffh     wcz
        _ret_   bitz    i_flags, #I_ZF_BIT

i_add_flags8
                testb   i_data0, #7         wc      ' (resultDst ^ resultSrc)
                testb   i_data1, #7         xorc    ' |
                testb   i_data1, #7         wz      ' (resultSrc ^ resultArith)
                testb   i_data, #7          xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                testb   i_data0, #7         xorz    ' (resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith)))
                bitz    i_flags, #I_CF_BIT
i_add_flags8_nc
                testb   i_data0, #7         wc      ' (resultDst ^ resultArith)
                testb   i_data, #7          xorc    ' |
                testb   i_data1, #7         wz      ' (resultSrc ^ resultArith)
                testb   i_data, #7          xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                bitz    i_flags, #I_OF_BIT

                testb   i_data0, #4         wz
                testb   i_data1, #4         xorz
                testb   i_data, #4          xorz
                bitz    i_flags, #I_AF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_sub_flags8
                testb   i_data, #7          wc      ' (resultDst ^ resultSrc)
                testb   i_data1, #7         xorc    ' |
                testb   i_data1, #7         wz      ' (resultSrc ^ resultArith)
                testb   i_data0, #7         xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                testb   i_data, #7          xorz    ' (resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith)))
                bitz    i_flags, #I_CF_BIT
i_sub_flags8_nc
                testb   i_data, #7          wc      ' (resultDst ^ resultArith)
                testb   i_data0, #7         xorc    ' |
                testb   i_data1, #7         wz      ' (resultSrc ^ resultArith)
                testb   i_data0, #7         xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                bitz    i_flags, #I_OF_BIT

                testb   i_data0, #4         wz
                testb   i_data1, #4         xorz
                testb   i_data, #4          xorz
                bitz    i_flags, #I_AF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_logic_flags8
                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_logic_flags16
                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT

                test    i_data, #$FF        wcz
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, i_ffffh     wcz
        _ret_   bitz    i_flags, #I_ZF_BIT

' --------------------------------------------------------------------

i_ax            long    $0000
i_bx            long    $0000
i_cx            long    $0000
i_dx            long    $0000

i_sp            long    $0000
i_bp            long    $0000
i_si            long    $0000
i_di            long    $0000

i_cs            long    $FFFF
i_ds            long    $0000
i_es            long    $0000
i_ss            long    $0000

i_flags         long    $0000
i_flags_pre     long    $F002
i_ip            long    $0000

i_cycles        long    0
i_total         long    0

i_3fffh         long    $3FFF
i_ffffh         long    $FFFF
i_eamask        long    $FFFFF
i_optable       long    @i8086_optable

i_rambase       long    @ram_00000
i_cgabase       long    @ram_00000 + RAM_SIZE

i_ppi           long    %00000000_00000000_00000000_00000000
                '        |||||||| |||||||| |||||||| ||||||||
                '        |||||||| |||||||| |||||||| ++++++++-- I=KB. Scancode / O=Diagnostic
                '        |||||||| |||||||| |||||||+----------- Timer 2 Gate Speaker
                '        |||||||| |||||||| ||||||+------------ Speaker Data
                '        |||||||| |||||||| |||||+------------- Spare
                '        |||||||| |||||||| ||||+-------------- Read High / Low switched
                '        |||||||| |||||||| |||+--------------- 0=Enable RAM parity check
                '        |||||||| |||||||| ||+---------------- 0=Enable I/O channel check
                '        |||||||| |||||||| |+----------------- 0=Hold keyboard clock low
                '        |||||||| |||||||| +------------------ 0=Enable keyboard, 1=Clear keyboard
                '        |||||||| ||||++++-------------------- Switches
                '        |||||||| |||+------------------------ Spare
                '        |||||||| ||+------------------------- Timer channel 2 out
                '        |||||||| |+-------------------------- 1=I/O channel check
                '        |||||||| +--------------------------- 1=Ram parity check
                '        ++++++++----------------------------- CONTROL

i_pic_icw       long    %00000000_00000000_00000000_00000000
                '        |||||||| |||||||| |||||||| ||||||||
                '        |||||||| |||||||| |||||||| ++++++++-- ICW1
                '        |||||||| |||||||| ++++++++----------- ICW2
                '        |||||||| ++++++++-------------------- ICW3
                '        ++++++++----------------------------- ICW4

i_pic_ocw       long    %00000000_00000000_00000000_00000000
                '        |||      |||||||| |||||||| ||||||||
                '        |||      |||||||| |||||||| ++++++++--   7..0: OCW1 (IMR)
                '        |||      |||||||| ++++++++-----------  15..8: OCW2
                '        |||      ++++++++-------------------- 23..16: OCW3
                '        ||+---------------------------------      29: ICW2 received
                '        |+-----------------------------------     30: ICW3 received
                '        +------------------------------------     31: ICW4 received

i_pic_irr       long    %00000000_00000000_00000000_00000000
                '        |    |||          |||||||| ||||||||
                '        |    |||          |||||||| ++++++++--   7..0: IRR
                '        |    |||          ++++++++-----------  15..8: ISR
                '        |    +++----------------------------- 26..24:  # served
                '        +------------------------------------     31: IS

i_pit           long    %00111000_00110000_00110000_00110000
                '          ||||||
                '          |||||+------------------------------ 24: Timer0 enable
                '          ||||+------------------------------- 25: Timer1 enable
                '          |||+-------------------------------- 26: Timer2 enable
                '          ||+--------------------------------- 27: Timer0 reload
                '          |+---------------------------------- 28: Timer1 reload
                '          +----------------------------------- 29: Timer2 reload
i_pit_latches   long    $0000_0000, $0000_0000

i_dma_ctl       long    0

i_sys_flags     long    %000_000
                '        ||| +++ Timer H/L flags
                '        +++---- Timer latches

i_opcode        res     1
i_modrm         res     1
i_modrm0        res     1

i_override      res     1
i_segment       res     1
i_offset        res     1
i_ea            res     1

i_tmpb          res     1
i_data          res     1
i_data0         res     1
i_data1         res     1

i_temp0         res     1
i_temp1         res     1
i_temp2         res     1
i_opimpl        res     1
i_rep_cnt       res     1
i_ip_start      res     1
i_lastwait      res     1

DAT             ' 8086 LUT
                org     $200
i8086_lut

i_readmemb
                and     i_ea, i_eamask
                wxpin   i_ea, #CPU_PIN      ' send read request (bit31=0)
                waitse1                     ' | clear our own event (why pollseX doesn't work here ?)
                waitse1                     ' | wait read complete
                rdpin   i_tmpb, #CPU_PIN    ' | read byte
                ret     wcz

i_writememb
                and     i_ea, i_eamask

                mov     pa, i_ea
                shl     pa, #8              ' shift address to bits [27:8]
                setbyte pa, i_tmpb, #0      ' set data to write to bits [7:0]
                bith    pa, #31             ' send write request (bit31=1)
                wxpin   pa, #CPU_PIN        ' |
                waitse1                     ' | clear our own event (why pollseX doesn't work here ?)
                waitse1                     ' | wait write complete
                ret     wcz

i_readiob
                ' i_ea   = address
                ' i_tmpb = data
                mov     i_tmpb, #$FF

                cmp     i_ea, ##$03DA   wcz
        if_e    rdbyte  i_tmpb, #@cga_io_03DA

                cmp     i_ea, #$60      wcz
        if_e    jmp     #\ppi_60_rd
                cmp     i_ea, #$61      wcz
        if_e    getbyte i_tmpb, i_ppi, #PPI_PB_BYTE
                cmp     i_ea, #$62      wcz
        if_e    jmp     #\ppi_62_rd
                cmp     i_ea, #$63      wcz
        if_e    getbyte i_tmpb, i_ppi, #PPI_CTL_BYTE

                cmp     i_ea, #$07      wcz
        if_be   jmp     #\dma_addr_rd
                cmp     i_ea, #$08      wcz
        if_e    rdbyte  i_tmpb, #@dma_ctl
                cmp     i_ea, #$81      wcz
        if_e    rdbyte  i_tmpb, #@dma_page + 2
                cmp     i_ea, #$82      wcz
        if_e    rdbyte  i_tmpb, #@dma_page + 3
                cmp     i_ea, #$83      wcz
        if_e    rdbyte  i_tmpb, #@dma_page + 1
                cmp     i_ea, #$87      wcz
        if_e    rdbyte  i_tmpb, #@dma_page + 0

                cmp     i_ea, #$20      wcz
        if_e    jmp     #\pic_20_rd
                cmp     i_ea, #$21      wcz
        if_e    jmp     #\pic_21_rd

                cmp     i_ea, #$40      wcz
        if_e    jmp     #\pit_40_rd
                cmp     i_ea, #$41      wcz
        if_e    jmp     #\pit_41_rd
                cmp     i_ea, #$42      wcz
        if_e    jmp     #\pit_42_rd

                cmp     i_ea, ##$03F1   wcz
        if_e    mov     i_tmpb, #%01010000
                cmp     i_ea, ##$03F4   wcz
        if_e    jmp     #\fdc_status_rd
                cmp     i_ea, ##$03F5   wcz
        if_e    jmp     #\fdc_data_rd

                ret     wcz

i_writeiob
                ' i_ea   = address
                ' i_tmpb = data

                cmp     i_ea, ##$03D4   wcz
        if_e    wrbyte  i_tmpb, #@cga_io_03D4
                cmp     i_ea, ##$03D5   wcz
        if_e    jmp     #\cga_03D5_wr
                cmp     i_ea, ##$03D8   wcz
        if_e    wrbyte  i_tmpb, #@cga_io_03D8
                cmp     i_ea, ##$03D9   wcz
        if_e    wrbyte  i_tmpb, #@cga_io_03D9
                cmp     i_ea, ##$03DA   wcz
        if_e    wrbyte  i_tmpb, #@cga_io_03DA

                cmp     i_ea, #$60      wcz
        if_e    setbyte i_ppi, i_tmpb, #PPI_PA_BYTE
                cmp     i_ea, #$61      wcz
        if_e    jmp     #\ppi_61_wr
                cmp     i_ea, #$62      wcz
        if_e    setbyte i_ppi, i_tmpb, #PPI_PC_BYTE
                cmp     i_ea, #$63      wcz
        if_e    setbyte i_ppi, i_tmpb, #PPI_CTL_BYTE

                cmp     i_ea, #$07      wcz
        if_be   jmp     #\dma_addr_wr
                cmp     i_ea, #$0F      wcz
        if_be   jmp     #\dma_wr
                cmp     i_ea, #$81      wcz
        if_e    wrbyte  i_tmpb, #@dma_page + 2
                cmp     i_ea, #$82      wcz
        if_e    wrbyte  i_tmpb, #@dma_page + 3
                cmp     i_ea, #$83      wcz
        if_e    wrbyte  i_tmpb, #@dma_page + 1
                cmp     i_ea, #$87      wcz
        if_e    wrbyte  i_tmpb, #@dma_page + 0

                cmp     i_ea, #$20      wcz
        if_e    jmp     #\pic_20_wr
                cmp     i_ea, #$21      wcz
        if_e    jmp     #\pic_21_wr

                cmp     i_ea, #$40      wcz
        if_e    jmp     #\pit_40_wr
                cmp     i_ea, #$41      wcz
        if_e    jmp     #\pit_41_wr
                cmp     i_ea, #$42      wcz
        if_e    jmp     #\pit_42_wr
                cmp     i_ea, #$43      wcz
        if_e    jmp     #\pit_43_wr

                cmp     i_ea, ##$03F2   wcz
        if_e    jmp     #\fdc_dor_wr
                cmp     i_ea, ##$03F5   wcz
        if_e    jmp     #\fdc_data_wr

                ret     wcz

' CGA

cga_03D5_wr
                rdbyte  pa, #@cga_io_03D4
                cmp     pa, #17         wcz
        if_a    ret     wcz
                add     pa, #@cga_io_mc6845
                wrbyte  i_tmpb, pa
                ret     wcz
i_system_run

                ' 8259A PIC Interrupts

.lock           locktry #I_INT_LOCK     wc  ' acquire lock for interrupt lines
        if_nc   jmp     #.lock

                rdbyte  i_temp0, #@pic_irq
                or      i_pic_irr, i_temp0
                wrbyte  #0, #@pic_irq

                lockrel #I_INT_LOCK         ' release lock

                getbyte i_temp0, i_pic_irr, #PIC_ISR_BYTE
                getbyte i_temp1, i_pic_irr, #PIC_IRR_BYTE

                or      i_temp0, i_temp1
                getbyte i_temp1, i_pic_ocw, #PIC_OCW1_BYTE
                andn    i_temp0, i_temp1

                setbyte i_pic_irr, i_temp0, #PIC_ISR_BYTE
                setbyte i_pic_irr, #0, #PIC_IRR_BYTE

                testb   i_pic_irr, #PIC_IS_BIT  wc
                testb   i_flags, #I_IF_BIT      wz
   if_not_01    ret

                call    #\pic_intack

                getbyte i_temp0, i_pic_icw, #PIC_ICW2_BYTE
                testb   i_pic_irr, #PIC_IS_BIT  wz
        if_x1   getnib  i_temp1, i_pic_irr, #PIC_IR_NIB
        if_x1   add     i_temp0, i_temp1
        if_x1   jmp     #\i_trap

                ret

pic_intack
                testb   i_pic_irr, #(PIC_ISR_BYTE * 8) + 0    wz
        if_x1   setnib  i_pic_irr, #0, #PIC_IR_NIB
        if_x1   bith    i_pic_irr, #PIC_IS_BIT
        if_x1   ret

                testb   i_pic_irr, #(PIC_ISR_BYTE * 8) + 1    wz
        if_x1   setnib  i_pic_irr, #1, #PIC_IR_NIB
        if_x1   bith    i_pic_irr, #PIC_IS_BIT
        if_x1   ret

                testb   i_pic_irr, #(PIC_ISR_BYTE * 8) + 2    wz
        if_x1   setnib  i_pic_irr, #2, #PIC_IR_NIB
        if_x1   bith    i_pic_irr, #PIC_IS_BIT
        if_x1   ret

                testb   i_pic_irr, #(PIC_ISR_BYTE * 8) + 3    wz
        if_x1   setnib  i_pic_irr, #3, #PIC_IR_NIB
        if_x1   bith    i_pic_irr, #PIC_IS_BIT
        if_x1   ret

                testb   i_pic_irr, #(PIC_ISR_BYTE * 8) + 4    wz
        if_x1   setnib  i_pic_irr, #4, #PIC_IR_NIB
        if_x1   bith    i_pic_irr, #PIC_IS_BIT
        if_x1   ret

                testb   i_pic_irr, #(PIC_ISR_BYTE * 8) + 5    wz
        if_x1   setnib  i_pic_irr, #5, #PIC_IR_NIB
        if_x1   bith    i_pic_irr, #PIC_IS_BIT
        if_x1   ret

                testb   i_pic_irr, #(PIC_ISR_BYTE * 8) + 6    wz
        if_x1   setnib  i_pic_irr, #6, #PIC_IR_NIB
        if_x1   bith    i_pic_irr, #PIC_IS_BIT
        if_x1   ret

                testb   i_pic_irr, #(PIC_ISR_BYTE * 8) + 7    wz
                setnib  i_pic_irr, #7, #PIC_IR_NIB
        if_x1   bith    i_pic_irr, #PIC_IS_BIT

                ret

i8086_lut_end

DAT             ' 8086 HUB
                orgh

i8086_optable
                long    @i_math_modrm_r8        ' 00 rm                 add [rm], r8
                long    @i_math_modrm_r16       ' 01 rm                 add [rm], r16
                long    @i_math_r8_modrm        ' 02 rm                 add r16, [rm]
                long    @i_math_r16_modrm       ' 03 rm                 add r8, [rm]
                long    @i_math_al_imm8         ' 04 nn                 add al, nn
                long    @i_math_ax_imm16        ' 05 ll hh              add ax, hhll
                long    @i_push_sreg            ' 06                    push es
                long    @i_pop_sreg             ' 07                    pop es
                long    @i_math_modrm_r8        ' 08 rm                 or  [rm], r8
                long    @i_math_modrm_r16       ' 09 rm                 or  [rm], r16
                long    @i_math_r8_modrm        ' 0A rm                 or  r16, [rm]
                long    @i_math_r16_modrm       ' 0B rm                 or  r8, [rm]
                long    @i_math_al_imm8         ' 0C nn                 or  al, nn
                long    @i_math_ax_imm16        ' 0D ll hh              or  ax, hhll
                long    @i_push_sreg            ' 0E                    push cs
                long    @i_pop_sreg             ' 0F                    pop cs

                long    @i_math_modrm_r8        ' 10 rm                 adc [rm], r8
                long    @i_math_modrm_r16       ' 11 rm                 adc [rm], r16
                long    @i_math_r8_modrm        ' 12 rm                 adc r16, [rm]
                long    @i_math_r16_modrm       ' 13 rm                 adc r8, [rm]
                long    @i_math_al_imm8         ' 14 nn                 adc al, nn
                long    @i_math_ax_imm16        ' 15 ll hh              adc ax, hhll
                long    @i_push_sreg            ' 16                    push ss
                long    @i_pop_sreg             ' 17                    pop ss
                long    @i_math_modrm_r8        ' 18 rm                 sbb [rm], r8
                long    @i_math_modrm_r16       ' 19 rm                 sbb [rm], r16
                long    @i_math_r8_modrm        ' 1A rm                 sbb r16, [rm]
                long    @i_math_r16_modrm       ' 1B rm                 sbb r8, [rm]
                long    @i_math_al_imm8         ' 1C nn                 sbb al, nn
                long    @i_math_ax_imm16        ' 1D ll hh              sbb ax, hhll
                long    @i_push_sreg            ' 1E                    push ds
                long    @i_pop_sreg             ' 1F                    pop ds

                long    @i_math_modrm_r8        ' 20 rm                 and [rm], r8
                long    @i_math_modrm_r16       ' 21 rm                 and [rm], r16
                long    @i_math_r8_modrm        ' 22 rm                 and r16, [rm]
                long    @i_math_r16_modrm       ' 23 rm                 and r8, [rm]
                long    @i_math_al_imm8         ' 24 nn                 and al, nn
                long    @i_math_ax_imm16        ' 25 ll hh              and ax, hhll
                long    @i_hlt                  ' 26                    es:
                long    @i_daas                 ' 27                    daa
                long    @i_math_modrm_r8        ' 28 rm                 sub [rm], r8
                long    @i_math_modrm_r16       ' 29 rm                 sub [rm], r16
                long    @i_math_r8_modrm        ' 2A rm                 sub r16, [rm]
                long    @i_math_r16_modrm       ' 2B rm                 sub r8, [rm]
                long    @i_math_al_imm8         ' 2C nn                 sub al, nn
                long    @i_math_ax_imm16        ' 2D ll hh              sub ax, hhll
                long    @i_hlt                  ' 2E                    cs:
                long    @i_daas                 ' 2F                    das

                long    @i_math_modrm_r8        ' 30 rm                 xor [rm], r8
                long    @i_math_modrm_r16       ' 31 rm                 xor [rm], r16
                long    @i_math_r8_modrm        ' 32 rm                 xor r16, [rm]
                long    @i_math_r16_modrm       ' 33 rm                 xor r8, [rm]
                long    @i_math_al_imm8         ' 34 nn                 xor al, nn
                long    @i_math_ax_imm16        ' 35 ll hh              xor ax, hhll
                long    @i_hlt                  ' 26                    ss:
                long    @i_aaas                 ' 37                    aaa
                long    @i_math_modrm_r8        ' 38 rm                 cmp [rm], r8
                long    @i_math_modrm_r16       ' 39 rm                 cmp [rm], r16
                long    @i_math_r8_modrm        ' 3A rm                 cmp r16, [rm]
                long    @i_math_r16_modrm       ' 3B rm                 cmp r8, [rm]
                long    @i_math_al_imm8         ' 3C nn                 cmp al, nn
                long    @i_math_ax_imm16        ' 3D ll hh              cmp ax, hhll
                long    @i_hlt                  ' 3E                    ds:
                long    @i_aaas                 ' 3F                    aas

                long    @i_inc16                ' 40                    inc ax
                long    @i_inc16                ' 41                    inc cx
                long    @i_inc16                ' 42                    inc dx
                long    @i_inc16                ' 43                    inc bx
                long    @i_inc16                ' 44                    inc sp
                long    @i_inc16                ' 45                    inc bp
                long    @i_inc16                ' 46                    inc si
                long    @i_inc16                ' 47                    inc di
                long    @i_dec16                ' 48                    dec ax
                long    @i_dec16                ' 49                    dec cx
                long    @i_dec16                ' 4A                    dec dx
                long    @i_dec16                ' 4B                    dec bx
                long    @i_dec16                ' 4C                    dec sp
                long    @i_dec16                ' 4D                    dec bp
                long    @i_dec16                ' 4E                    dec si
                long    @i_dec16                ' 4F                    dec di

                long    @i_push_r16             ' 50                    push ax
                long    @i_push_r16             ' 51                    push cx
                long    @i_push_r16             ' 52                    push dx
                long    @i_push_r16             ' 53                    push bx
                long    @i_push_r16             ' 54                    push sp
                long    @i_push_r16             ' 55                    push bp
                long    @i_push_r16             ' 56                    push si
                long    @i_push_r16             ' 57                    push di
                long    @i_pop_r16              ' 58                    pop ax
                long    @i_pop_r16              ' 59                    pop cx
                long    @i_pop_r16              ' 5A                    pop dx
                long    @i_pop_r16              ' 5B                    pop bx
                long    @i_pop_r16              ' 5C                    pop sp
                long    @i_pop_r16              ' 5D                    pop bp
                long    @i_pop_r16              ' 5E                    pop si
                long    @i_pop_r16              ' 5F                    pop di

                long    @i_jo                   ' 60 dd                 jo dd   60 - 6F are aliases to 70 - 7F
                long    @i_jo                   ' 61 dd                 jno dd
                long    @i_jc                   ' 62 dd                 jc dd
                long    @i_jc                   ' 63 dd                 jnc dd
                long    @i_jz                   ' 64 dd                 jz dd
                long    @i_jz                   ' 65 dd                 jnz dd
                long    @i_jce                  ' 66 dd                 jce dd
                long    @i_jce                  ' 67 dd                 jnce dd
                long    @i_js                   ' 68 dd                 js dd
                long    @i_js                   ' 69 dd                 jns dd
                long    @i_jp                   ' 6A dd                 jp dd
                long    @i_jp                   ' 6B dd                 jnp dd
                long    @i_jl                   ' 6C dd                 jl dd
                long    @i_jnl                  ' 6D dd                 jnl dd
                long    @i_jle                  ' 6E dd                 jle dd
                long    @i_jnle                 ' 6F dd                 jnle dd

                long    @i_jo                   ' 70 dd                 jo dd   60 - 6F are aliases to 70 - 7F
                long    @i_jo                   ' 71 dd                 jno dd
                long    @i_jc                   ' 72 dd                 jc dd
                long    @i_jc                   ' 73 dd                 jnc dd
                long    @i_jz                   ' 74 dd                 jz dd
                long    @i_jz                   ' 75 dd                 jnz dd
                long    @i_jce                  ' 76 dd                 jce dd
                long    @i_jce                  ' 77 dd                 jnce dd
                long    @i_js                   ' 78 dd                 js dd
                long    @i_js                   ' 79 dd                 jns dd
                long    @i_jp                   ' 7A dd                 jp dd
                long    @i_jp                   ' 7B dd                 jnp dd
                long    @i_jl                   ' 7C dd                 jl dd
                long    @i_jnl                  ' 7D dd                 jnl dd
                long    @i_jle                  ' 7E dd                 jle dd
                long    @i_jnle                 ' 7F dd                 jnle dd

                long    @i_math_imm8            ' 80 rm nn              add/or/adc/sbb/and/sub/xor/cmp [rm8], nn
                long    @i_math_imm16           ' 81 rm ll hh           add/or/adc/sbb/and/sub/xor/cmp [rm16], hhll
                long    @i_math_imm8s           ' 82 rm sn              add/or/adc/sbb/and/sub/xor/cmp [rm8], sn
                long    @i_math_imm16s          ' 83 rm sn              add/or/adc/sbb/and/sub/xor/cmp [rm16], sn
                long    @i_test_r8_modrm        ' 84 rm                 test r8, [mm]
                long    @i_test_r16_modrm       ' 85 rm                 test r16, [mm]
                long    @i_xchg_modrm8          ' 86 rm                 xchg r8, [mm]
                long    @i_xchg_modrm16         ' 87 rm                 xchg r16, [mm]
                long    @i_mov_modrm_r8         ' 88 rm                 mov [rm], r8
                long    @i_mov_modrm_r16        ' 89 rm                 mov [rm], r16
                long    @i_mov_r8_modrm         ' 8A rm                 mov r8, [rm]
                long    @i_mov_r16_modrm        ' 8B rm                 mov r16, [rm]
                long    @i_mov_modrm_sreg       ' 8C rm                 mov [rm], sreg
                long    @i_lea                  ' 8D oo                 lea r16, oo
                long    @i_mov_sreg_modrm       ' 8E rm                 mov sregs, [rm]
                long    @i_pop_modrm            ' 8F mm                 pop [rm]

                long    @i_xchg                 ' 90                    xchg ax, cx
                long    @i_xchg                 ' 91                    xchg ax, cx
                long    @i_xchg                 ' 92                    xchg ax, dx
                long    @i_xchg                 ' 93                    xchg ax, bx
                long    @i_xchg                 ' 94                    xchg ax, sp
                long    @i_xchg                 ' 95                    xchg ax, bp
                long    @i_xchg                 ' 96                    xchg ax, si
                long    @i_xchg                 ' 97                    xchg ax, di
                long    @i_cbw                  ' 98                    cbw
                long    @i_cwd                  ' 99                    cwd
                long    @i_call_far             ' 9A ol oh sl sh        call shsl:ohol
                long    @i_wait                 ' 9B                    wait
                long    @i_pushf                ' 9C                    pushf
                long    @i_popf                 ' 9C                    popf
                long    @i_sahf                 ' 9E                    sahf
                long    @i_lahf                 ' 9F                    lahf

                long    @i_mov_al_offs          ' A0 ol oh              mov al, [DS:ohol]
                long    @i_mov_ax_offs          ' A1 ol oh              mov ax, [DS:ohol]
                long    @i_mov_offs_al          ' A2 ol oh              mov [DS:ohol], al
                long    @i_mov_offs_ax          ' A3 ol oh              mov [DS:ohol], ax
                long    @i_movsb                ' A4                    movsb
                long    @i_movsw                ' A5                    movsw
                long    @i_cmpsb                ' A6                    cmpsb
                long    @i_cmpsw                ' A7                    cmpsw
                long    @i_test_al_imm          ' A8 nn                 test al, nn
                long    @i_test_ax_imm          ' A9 ll hh              test ax, hhll
                long    @i_stosb                ' AA                    stosb
                long    @i_stosw                ' AB                    stosw
                long    @i_lodsb                ' AC                    lodsb
                long    @i_lodsw                ' AD                    lodsw
                long    @i_scasb                ' AE                    scasb
                long    @i_scasw                ' AF                    scasw

                long    @i_mov_immb             ' B0 nn                 mov al, nn
                long    @i_mov_immb             ' B1 nn                 mov cl, nn
                long    @i_mov_immb             ' B2 nn                 mov dl, nn
                long    @i_mov_immb             ' B3 nn                 mov bl, nn
                long    @i_mov_immb             ' B4 nn                 mov ah, nn
                long    @i_mov_immb             ' B5 nn                 mov ch, nn
                long    @i_mov_immb             ' B6 nn                 mov dh, nn
                long    @i_mov_immb             ' B7 nn                 mov bh, nn
                long    @i_mov_immw             ' B8 ll hh              mov ax, hhll
                long    @i_mov_immw             ' B9 ll hh              mov cx, hhll
                long    @i_mov_immw             ' BA ll hh              mov dx, hhll
                long    @i_mov_immw             ' BB ll hh              mov bx, hhll
                long    @i_mov_immw             ' BC ll hh              mov sp, hhll
                long    @i_mov_immw             ' BD ll hh              mov bp, hhll
                long    @i_mov_immw             ' BE ll hh              mov si, hhll
                long    @i_mov_immw             ' BF ll hh              mov di, hhll

                long    @i_ret_near_sp          ' C0 dl dh              ret (SP+dhdl)
                long    @i_ret_near             ' C1                    ret
                long    @i_ret_near_sp          ' C2 dl dh              ret (SP+dhdl)
                long    @i_ret_near             ' C3                    ret
                long    @i_les                  ' C4 rm                 les [rm]
                long    @i_lds                  ' C5 rm                 lds [rm]
                long    @i_mov_modrm_imm8       ' C6 rm nn              mov byte [rm], nn
                long    @i_mov_modrm_imm16      ' C7 rm ll hh           mov word [rm], hhll
                long    @i_ret_far_sp           ' C8 dl dh              retf (SP+dhdl)
                long    @i_ret_far              ' C9                    retf
                long    @i_ret_far_sp           ' CA dl dh              retf (SP+dhdl)
                long    @i_ret_far              ' CB                    retf
                long    @i_int3                 ' CC                    int3
                long    @i_int                  ' CD                    int
                long    @i_into                 ' CE                    into
                long    @i_iret                 ' CF                    iret

                long    @i_d0_prefix            ' D0 rm                 rol/ror/rolc/rorc/shl/shr/shra byte[rm]
                long    @i_d1_prefix            ' D1 rm                 rol/ror/rolc/rorc/shl/shr/shraw word[rm]
                long    @i_d2_prefix            ' D2 rm                 rol/ror/rolc/rorc/shl/shr/shrab byte[rm], cl
                long    @i_d3_prefix            ' D3 rm                 rol/ror/rolc/rorc/shl/shr/shraw word[rm], cl
                long    @i_aam                  ' D4                    aam
                long    @i_aad                  ' D5                    aad
                long    @i_salc                 ' D6                    salc
                long    @i_xlatb                ' D7                    xlatb
                long    i_esc_op                ' D8 rm                 esc rm
                long    i_esc_op                ' D9 rm                 esc rm
                long    i_esc_op                ' DA rm                 esc rm
                long    i_esc_op                ' DB rm                 esc rm
                long    i_esc_op                ' DC rm                 esc rm
                long    i_esc_op                ' DD rm                 esc rm
                long    i_esc_op                ' DE rm                 esc rm
                long    i_esc_op                ' DF rm                 esc rm

                long    @i_loopne               ' E0 dd                 loopne dd
                long    @i_loope                ' E1 dd                 loope dd
                long    @i_loop                 ' E2 dd                 loop dd
                long    @i_jcxz                 ' E3 dd                 jcxz dd
                long    @i_in_al_imm            ' E4 pp                 in al, [pp]
                long    @i_in_ax_imm            ' E5 pp                 in ax, [pp]
                long    @i_out_imm_al           ' E6 pp                 out [pp], al
                long    @i_out_imm_ax           ' E7 pp                 out [pp], ax
                long    @i_call_displ           ' E8 dl dh              call +dhdl
                long    @i_jmp_displ            ' E9 dl dh              jmp +dhdl
                long    @i_jmp_far              ' EA ol oh sl sh        jmp shsl:ohol
                long    @i_jmp_displ8           ' EB dd                 jmp +dd
                long    @i_in_al_dx             ' EC pp                 in al, [dx]
                long    @i_in_ax_dx             ' ED pp                 in ax, [dx]
                long    @i_out_dx_al            ' EE pp                 out [dx], al
                long    @i_out_dx_ax            ' EF pp                 out [dx], ax

                long    @i_lock                 ' F0                    lock
                long    @i_lock                 ' F1                    lock
                long    @i_hlt                  ' F2                    repne
                long    @i_hlt                  ' F3                    repe
                long    @i_hlt                  ' F4                    hlt
                long    @i_cmc                  ' F5                    cmc
                long    @i_f6_prefix            ' F6 rm                 test/not/net/mul/imul/div/idiv [rm8]
                long    @i_f7_prefix            ' F7 rm                 test/not/net/mul/imul/div/idiv [rm16]
                long    @i_clc                  ' F8                    clc
                long    @i_stc                  ' F9                    stc
                long    @i_cli                  ' FA                    cli
                long    @i_sti                  ' FB                    sti
                long    @i_cld                  ' FC                    cld
                long    @i_std                  ' FD                    std
                long    @i_fe_prefix            ' FF rm                 inc/dec [rm]
                long    @i_ff_prefix            ' FF rm                 inc/dec/call/call far/jmp/jmp far/push/cmp [rm]

i_hlt
                bith    i_flags, #I_HALT_BIT
        {_ret_}   decmod  i_ip, i_ffffh
                debug("**** i_hlt ****")
                debug(uhex_word(i_cs, i_ip))
                cogid   pa
                cogstop pa

'   add [modrm], r8
'   or  [modrm], r8
'   adc [modrm], r8
'   sbb [modrm], r8
'   and [modrm], r8
'   sub [modrm], r8
'   xor [modrm], r8
'   cmp [modrm], r8

i_math_modrm_r8
                call    #\i_setupmodrm
                call    #\i_getmodr8
                mov     i_data1, i_data
                call    #\i_readopb
                mov     i_data0, i_data
                mov     i_temp0, i_opcode
_do_modrm_op8
                and     i_temp0, #%00_111_000   wz
        if_z    jmp     #.add
                cmp     i_temp0, #%00_001_000   wz
        if_z    jmp     #.or
                cmp     i_temp0, #%00_010_000   wz
        if_z    jmp     #.adc
                cmp     i_temp0, #%00_011_000   wz
        if_z    jmp     #.sbb
                cmp     i_temp0, #%00_100_000   wz
        if_z    jmp     #.and
                cmp     i_temp0, #%00_101_000   wz
        if_z    jmp     #.sub
                cmp     i_temp0, #%00_110_000   wz
        if_z    jmp     #.xor
                cmp     i_temp0, #%00_111_000   wz
        if_z    jmp     #.cmp
                ret

.add
                add     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_add_flags8
.or
                or      i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_logic_flags8
.adc
                testb   i_flags, #I_CF_BIT      wc
                addx    i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_add_flags8
.sbb
                testb   i_flags, #I_CF_BIT      wc
                subx    i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_sub_flags8
.and
                and     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_logic_flags8
.sub
                sub     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_sub_flags8
.xor
                xor     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_logic_flags8
.cmp
                sub     i_data, i_data1
                jmp     #\i_sub_flags8

i_math_imm8s
                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data0, i_data
                call    #\i_readcodeb
                getbyte i_data1, i_tmpb, #0
                signx   i_data1, #7
                mov     i_temp0, i_modrm
                jmp     #_do_modrm_op8

i_math_imm8
                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data0, i_data
                call    #\i_readcodeb
                getbyte i_data1, i_tmpb, #0
                mov     i_temp0, i_modrm
                jmp     #_do_modrm_op8

' --------------------------------------------------------------------

'   add r8, [modrm]
'   or  r8, [modrm]
'   adc r8, [modrm]
'   sbb r8, [modrm]
'   and r8, [modrm]
'   sub r8, [modrm]
'   xor r8, [modrm]
'   cmp r8, [modrm]

i_math_al_imm8
                call    #\i_readimmb
                mov     i_data1, i_data
                mov     i_modrm, #%00_000_110
                skipf   #%111
i_math_r8_modrm
                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data1, i_data
                call    #\i_getmodr8
                mov     i_data0, i_data
                mov     i_temp0, i_opcode

                and     i_temp0, #%00_111_000   wz
        if_z    jmp     #.add
                cmp     i_temp0, #%00_001_000   wz
        if_z    jmp     #.or
                cmp     i_temp0, #%00_010_000   wz
        if_z    jmp     #.adc
                cmp     i_temp0, #%00_011_000   wz
        if_z    jmp     #.sbb
                cmp     i_temp0, #%00_100_000   wz
        if_z    jmp     #.and
                cmp     i_temp0, #%00_101_000   wz
        if_z    jmp     #.sub
                cmp     i_temp0, #%00_110_000   wz
        if_z    jmp     #.xor
                cmp     i_temp0, #%00_111_000   wz
        if_z    jmp     #.cmp
                ret

.add
                add     i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_add_flags8
.or
                or      i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_logic_flags8
.adc
                testb   i_flags, #I_CF_BIT      wc
                addx    i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_add_flags8
.sbb
                testb   i_flags, #I_CF_BIT      wc
                subx    i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_sub_flags8
.and
                and     i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_logic_flags8
.sub
                sub     i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_sub_flags8
.xor
                xor     i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_logic_flags8
.cmp
                sub     i_data, i_data1
                jmp     #\i_sub_flags8

i_test_r8_modrm
                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data1, i_data
                call    #\i_getmodr8
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags8

i_test_al_imm
                call    #\i_readimmb
                mov     i_data1, i_data
                getbyte i_data, i_ax, #0
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags8

' --------------------------------------------------------------------

'   add [modrm], r16
'   or  [modrm], r16
'   adc [modrm], r16
'   sbb [modrm], r16
'   and [modrm], r16
'   sub [modrm], r16
'   xor [modrm], r16
'   cmp [modrm], r16

i_math_modrm_r16
                call    #\i_setupmodrm
                call    #\i_getmodr16
                mov     i_data1, i_data
                call    #\i_readopw
                mov     i_data0, i_data
                mov     i_temp0, i_opcode
_do_modrm_op16
                and     i_temp0, #%00_111_000   wz
        if_z    jmp     #.add16
                cmp     i_temp0, #%00_001_000   wz
        if_z    jmp     #.or16
                cmp     i_temp0, #%00_010_000   wz
        if_z    jmp     #.adc16
                cmp     i_temp0, #%00_011_000   wz
        if_z    jmp     #.sbb16
                cmp     i_temp0, #%00_100_000   wz
        if_z    jmp     #.and16
                cmp     i_temp0, #%00_101_000   wz
        if_z    jmp     #.sub16
                cmp     i_temp0, #%00_110_000   wz
        if_z    jmp     #.xor16
                cmp     i_temp0, #%00_111_000   wz
        if_z    jmp     #.cmp16
                ret

.add16
                add     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_add_flags16
.or16
                or      i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_logic_flags16
.adc16
                testb   i_flags, #I_CF_BIT      wc
                addx    i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_add_flags16
.sbb16
                testb   i_flags, #I_CF_BIT      wc
                subx    i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_sub_flags16
.and16
                and     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_logic_flags16
.sub16
                sub     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_sub_flags16
.xor16
                xor     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_logic_flags16
.cmp16
                sub     i_data, i_data1
                jmp     #\i_sub_flags16

i_math_imm16s
                call    #\i_setupmodrm
                call    #\i_readopw
                mov     i_data0, i_data
                call    #\i_readcodeb
                getbyte i_data1, i_tmpb, #0
                signx   i_data1, #7
                mov     i_temp0, i_modrm
                jmp     #_do_modrm_op16

i_math_imm16
                call    #\i_setupmodrm
                call    #\i_readopw
                mov     i_data0, i_data
                call    #\i_readcodeb
                getbyte i_data1, i_tmpb, #0
                call    #\i_readcodeb
                setbyte i_data1, i_tmpb, #1
                mov     i_temp0, i_modrm
                jmp     #_do_modrm_op16

' --------------------------------------------------------------------

'   add r16, [modrm]
'   or  r16, [modrm]
'   adc r16, [modrm]
'   sbb r16, [modrm]
'   and r16, [modrm]
'   sub r16, [modrm]
'   xor r16, [modrm]
'   cmp r16, [modrm]

i_math_ax_imm16
                call    #\i_readimmw
                mov     i_data1, i_data
                mov     i_modrm, #%00_000_110
                skipf   #%111
i_math_r16_modrm
                call    #\i_setupmodrm
                call    #\i_readopw
                mov     i_data1, i_data
                call    #\i_getmodr16
                mov     i_data0, i_data
                mov     i_temp0, i_opcode

                and     i_temp0, #%00_111_000   wz
        if_z    jmp     #.add16
                cmp     i_temp0, #%00_001_000    wz
        if_z    jmp     #.or16
                cmp     i_temp0, #%00_010_000    wz
        if_z    jmp     #.adc16
                cmp     i_temp0, #%00_011_000    wz
        if_z    jmp     #.sbb16
                cmp     i_temp0, #%00_100_000    wz
        if_z    jmp     #.and16
                cmp     i_temp0, #%00_101_000    wz
        if_z    jmp     #.sub16
                cmp     i_temp0, #%00_110_000    wz
        if_z    jmp     #.xor16
                cmp     i_temp0, #%00_111_000    wz
        if_z    jmp     #.cmp16
                ret

.add16
                add     i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_add_flags16
.or16
                or      i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_logic_flags16
.adc16
                testb   i_flags, #I_CF_BIT      wc
                addx    i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_add_flags16
.sbb16
                testb   i_flags, #I_CF_BIT      wc
                subx    i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_sub_flags16
.and16
                and     i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_logic_flags16
.sub16
                sub     i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_sub_flags16
.xor16
                xor     i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_logic_flags16
.cmp16
                sub     i_data, i_data1
                jmp     #\i_sub_flags16

i_test_r16_modrm
                call    #\i_setupmodrm
                call    #\i_readopw
                mov     i_data1, i_data
                call    #\i_getmodr16
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags16

i_test_ax_imm
                call    #\i_readimmw
                mov     i_data1, i_data
                getword i_data, i_ax, #0
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags16

' --------------------------------------------------------------------

i_inc16
                mov     pa, i_opcode
                call    #\i_getr16
                mov     i_data0, i_data
                mov     i_data1, #1
                add     i_data, i_data1
                call    #\i_setr16
                jmp     #\i_add_flags16_nc

i_dec16
                mov     pa, i_opcode
                call    #\i_getr16
                mov     i_data0, i_data
                mov     i_data1, #1
                sub     i_data, i_data1
                call    #\i_setr16
                jmp     #\i_sub_flags16_nc

' --------------------------------------------------------------------

i_mov_modrm_sreg
                call    #\i_setupmodrm
                call    #\i_getmodsreg
                jmp     #\i_writeopw

i_mov_sreg_modrm
                call    #\i_setupmodrm
                call    #\i_readopw
                jmp     #\i_setmodsreg

i_mov_modrm_r16
                call    #\i_setupmodrm
                call    #\i_getmodr16
                jmp     #\i_writeopw

i_mov_r16_modrm
                call    #\i_setupmodrm
                call    #\i_readopw
                jmp     #\i_setmodr16

i_mov_modrm_r8
                call    #\i_setupmodrm
                call    #\i_getmodr8
                jmp     #\i_writeopb

i_mov_r8_modrm
                call    #\i_setupmodrm
                call    #\i_readopb
                jmp     #\i_setmodr8

i_mov_immb
                call    #\i_readimmb
                mov     pa, i_opcode
                jmp     #\i_setr8

i_mov_immw
                call    #\i_readimmw
                mov     pa, i_opcode
                jmp     #\i_setr16

i_mov_al_offs
                mov     i_modrm, #%00_000_110
                call    #\i_setupmodrm2
                call    #\i_readopb
                jmp     #\i_setmodr8

i_mov_ax_offs
                mov     i_modrm, #%00_000_110
                call    #\i_setupmodrm2
                call    #\i_readopw
                jmp     #\i_setmodr16

i_mov_offs_al
                mov     i_modrm, #%00_000_110
                call    #\i_setupmodrm2
                call    #\i_getmodr8
                jmp     #\i_writeopb

i_mov_offs_ax
                mov     i_modrm, #%00_000_110
                call    #\i_setupmodrm2
                call    #\i_getmodr16
                jmp     #\i_writeopw

i_mov_modrm_imm8
                call    #\i_setupmodrm
                call    #\i_readimmb
                jmp     #\i_writeopb

i_mov_modrm_imm16
                call    #\i_setupmodrm
                call    #\i_readimmw
                jmp     #\i_writeopw

' --------------------------------------------------------------------

i_push
                decmod  i_sp, i_ffffh
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                getbyte i_tmpb, i_data, #1
                call    #\i_writememb
                decmod  i_sp, i_ffffh
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                getbyte i_tmpb, i_data, #0
                jmp     #\i_writememb

i_pop
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                call    #\i_readmemb
                getbyte i_data, i_tmpb, #0
                incmod  i_sp, i_ffffh
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                call    #\i_readmemb
                setbyte i_data, i_tmpb, #1
        _ret_   incmod  i_sp, i_ffffh

i_pop_modrm
                call    #\i_setupmodrm
                call    #i_pop
                jmp     #\i_writeopw

i_pushf
                getword i_data, i_flags, #0
                and     i_data, ##ALL_FLAGS
                or      i_data, i_flags_pre
                jmp     #i_push

i_popf
                call    #i_pop
                and     i_data, ##ALL_FLAGS
                or      i_data, i_flags_pre
        _ret_   setword i_flags, i_data, #0

' --------------------------------------------------------------------

i_fe_prefix
                call    #\i_setupmodrm
                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' INC
        if_z    jmp     #.inc
                cmp     i_temp0, #%00_001_000   wz  ' DEC
        if_z    jmp     #.dec
                ret

.inc
                call    #\i_readopb
                mov     i_data0, i_data
                mov     i_data1, #1
                add     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_add_flags8_nc

.dec
                call    #\i_readopb
                mov     i_data0, i_data
                mov     i_data1, #1
                sub     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_sub_flags8_nc

' --------------------------------------------------------------------

i_f6_prefix
                call    #\i_setupmodrm
                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' TEST
        if_nz   cmp     i_temp0, #%00_001_000   wz  ' TEST (alias)
        if_z    jmp     #.test
                cmp     i_temp0, #%00_010_000   wz  ' NOT
        if_z    jmp     #.not
                cmp     i_temp0, #%00_011_000   wz  ' NEG
        if_z    jmp     #.neg
                cmp     i_temp0, #%00_100_000   wz  ' MUL
        if_z    jmp     #.mul
                cmp     i_temp0, #%00_101_000   wz  ' IMUL
        if_z    jmp     #.imul
                cmp     i_temp0, #%00_110_000   wz  ' DIV
        if_z    jmp     #.div
                cmp     i_temp0, #%00_111_000   wz  ' IDIV
        if_z    jmp     #.idiv
                ret

.test
                call    #\i_readimmb
                mov     i_data1, i_data
                call    #\i_readopb
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags8

.not
                call    #\i_readopb
                not     i_data
                jmp     #\i_writeopb

.neg
                call    #\i_readopb
                mov     i_data1, i_data
                mov     i_data, #0
                mov     i_data0, i_data
                sub     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_sub_flags8

.mul
                call    #\i_readopb
                mov     i_data1, i_data

                getbyte i_data, i_ax, #0

                mul     i_data, i_data1         wz
                getword i_ax, i_data, #0

                bitz    i_flags, #I_ZF_BIT

                testb   i_ax, #7                wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF              wc
                bitnc   i_flags, #I_PF_BIT

                testn   i_ax, #$FF              wz
                bitnz   i_flags, #I_CF_BIT
        _ret_   bitnz   i_flags, #I_OF_BIT

.imul
                call    #\i_readopb
                mov     i_data1, i_data
                signx   i_data1, #7

                getbyte i_data, i_ax, #0
                signx   i_data, #7

                muls    i_data, i_data1         wz
                getword i_ax, i_data, #0

                bitz    i_flags, #I_ZF_BIT

                testb   i_ax, #7                wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF              wc
                bitnc   i_flags, #I_PF_BIT

                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT

                cmps    i_data, #127            wcz
        if_gt   bith    i_flags, #I_CF_BIT
        if_gt   bith    i_flags, #I_OF_BIT

                cmps    i_data, ##-128          wcz
        if_lt   bith    i_flags, #I_CF_BIT
        if_lt   bith    i_flags, #I_OF_BIT

                ret

.div
                call    #\i_readopb
                mov     i_data1, i_data         wz
        if_z    jmp     #i_divzero

                getword i_data, i_ax, #0

                qdiv    i_data, i_data1
                getqx   i_temp0
                getqy   i_temp1

                testn   i_temp0, #$FF           wz
        if_nz   jmp     #i_divzero

                setbyte i_ax, i_temp0, #0
        _ret_   setbyte i_ax, i_temp1, #1

.idiv
                call    #\i_readopb
                mov     i_data1, i_data         wz
        if_z    jmp     #i_divzero

                signx   i_data1, #7
                testb   i_data1, #31            wc
        if_c    abs     i_data1

                getword i_data, i_ax, #0
                cmp     i_data, ##$8000         wz
        if_z    jmp     #i_divzero
                signx   i_data, #15
                testb   i_data, #31             wz
        if_z    abs     i_data

                qdiv    i_data, i_data1
                getqx   i_temp0
                getqy   i_temp1
    if_c_ne_z   neg     i_temp0
    if_z        neg     i_temp1

                getbyte i_temp2, i_temp0, #0
                signx   i_temp2, #7
                cmp     i_temp0, i_temp2        wz
        if_nz   jmp     #i_divzero

                setbyte i_ax, i_temp0, #0
        _ret_   setbyte i_ax, i_temp1, #1

' --------------------------------------------------------------------

i_f7_prefix
                call    #\i_setupmodrm
                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' TEST
        if_nz   cmp     i_temp0, #%00_001_000   wz  ' TEST (alias)
        if_z    jmp     #.test
                cmp     i_temp0, #%00_010_000   wz  ' NOT
        if_z    jmp     #.not
                cmp     i_temp0, #%00_011_000   wz  ' NEG
        if_z    jmp     #.neg
                cmp     i_temp0, #%00_100_000   wz  ' MUL
        if_z    jmp     #.mul
                cmp     i_temp0, #%00_101_000   wz  ' IMUL
        if_z    jmp     #.imul
                cmp     i_temp0, #%00_110_000   wz  ' DIV
        if_z    jmp     #.div
                cmp     i_temp0, #%00_111_000   wz  ' IDIV
        if_z    jmp     #.idiv
                ret

.test
                call    #\i_readimmw
                mov     i_data1, i_data
                call    #\i_readopw
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags16

.not
                call    #\i_readopw
                not     i_data
                jmp     #\i_writeopw

.neg
                call    #\i_readopw
                mov     i_data1, i_data
                mov     i_data, #0
                mov     i_data0, i_data
                sub     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_sub_flags16

.mul
                call    #\i_readopw
                mov     i_data1, i_data

                getword i_data, i_ax, #0

                mul     i_data, i_data1         wz
                getword i_ax, i_data, #0
                getword i_dx, i_data, #1

                bitz    i_flags, #I_ZF_BIT

                testb   i_ax, #15               wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF              wc
                bitnc   i_flags, #I_PF_BIT

                cmp     i_dx, #0                wz
                bitnz   i_flags, #I_CF_BIT
        _ret_   bitnz   i_flags, #I_OF_BIT

.imul
                call    #\i_readopw
                mov     i_data1, i_data
                signx   i_data1, #15

                getword i_data, i_ax, #0
                signx   i_data, #15

                muls    i_data, i_data1         wz
                getword i_ax, i_data, #0
                getword i_dx, i_data, #1

                bitz    i_flags, #I_ZF_BIT

                testb   i_ax, #15               wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF              wc
                bitnc   i_flags, #I_PF_BIT

                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT

                cmps    i_data, ##32767         wcz
        if_gt   bith    i_flags, #I_CF_BIT
        if_gt   bith    i_flags, #I_OF_BIT

                cmps    i_data, ##-32768        wcz
        if_lt   bith    i_flags, #I_CF_BIT
        if_lt   bith    i_flags, #I_OF_BIT
                ret

.div
                call    #\i_readopw
                mov     i_data1, i_data         wz
        if_z    jmp     #i_divzero

                getword i_data, i_ax, #0
                setword i_data, i_dx, #1

                qdiv    i_data, i_data1
                getqx   i_temp0
                getqy   i_temp1

                testn   i_temp0, i_ffffh        wz
        if_nz   jmp     #i_divzero

                getword i_ax, i_temp0, #0
        _ret_   getword i_dx, i_temp1, #0

.idiv
                call    #\i_readopw
                mov     i_data1, i_data         wz
        if_z    jmp     #i_divzero

                signx   i_data1, #15
                testb   i_data1, #31            wc
        if_c    abs     i_data1

                getword i_data, i_ax, #0
                setword i_data, i_dx, #1
                cmp     i_data, ##$8000_0000    wz
        if_z    jmp     #i_divzero

                testb   i_data, #31             wz
        if_z    abs     i_data

                qdiv    i_data, i_data1
                getqx   i_temp0
                getqy   i_temp1
    if_c_ne_z   neg     i_temp0
    if_z        neg     i_temp1

                getword i_temp2, i_temp0, #0
                signx   i_temp2, #15
                cmp     i_temp0, i_temp2        wz
        if_nz   jmp     #i_divzero

                getword i_ax, i_temp0, #0
        _ret_   getword i_dx, i_temp1, #0

' --------------------------------------------------------------------

i_ff_prefix
                call    #\i_setupmodrm
                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' INC
        if_z    jmp     #.inc
                cmp     i_temp0, #%00_001_000   wz  ' DEC
        if_z    jmp     #.dec
                cmp     i_temp0, #%00_010_000   wz  ' CALL
        if_z    jmp     #.call_near
                cmp     i_temp0, #%00_011_000   wz  ' CALL FAR
        if_z    jmp     #.call_far
                cmp     i_temp0, #%00_100_000   wz  ' JMP
        if_z    jmp     #.jmp_near
                cmp     i_temp0, #%00_101_000   wz  ' JMP FAR
        if_z    jmp     #.jmp_far
                cmp     i_temp0, #%00_110_000   wz  ' PUSH
        if_z    jmp     #.push
                cmp     i_temp0, #%00_111_000   wz  ' PUSH
        if_z    jmp     #.push
                ret

.inc
                call    #\i_readopw
                mov     i_data0, i_data
                mov     i_data1, #1
                add     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_add_flags16_nc

.dec
                call    #\i_readopw
                mov     i_data0, i_data
                mov     i_data1, #1
                sub     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_sub_flags16_nc

.call_near
                getword i_data, i_ip, #0
                call    #i_push
.jmp_near
                call    #\i_readopw
        _ret_   getword i_ip, i_data, #0

.call_far
                getword i_data, i_cs, #0
                call    #i_push
                getword i_data, i_ip, #0
                call    #i_push
.jmp_far
                call    #\i_setupea
                call    #\i_readw
                getword i_data0, i_data, #0
                call    #\i_readw
                getword i_cs, i_data, #0
        _ret_   getword i_ip, i_data0, #0

.push
                call    #\i_readopw
                jmp     #i_push

' --------------------------------------------------------------------

i_ret_near
                call    #i_pop
        _ret_   getword i_ip, i_data, #0

i_ret_near_sp
                call    #\i_readimmw
                mov     i_data0, i_data
                call    #i_pop
                getword i_ip, i_data, #0
                add     i_sp, i_data0
        _ret_   getword i_sp, i_sp, #0

i_ret_far
                call    #i_pop
                getword i_ip, i_data, #0
                call    #i_pop
        _ret_   getword i_cs, i_data, #0

i_ret_far_sp
                call    #\i_readimmw
                mov     i_data0, i_data
                call    #i_pop
                getword i_ip, i_data, #0
                call    #i_pop
                getword i_cs, i_data, #0
                add     i_sp, i_data0
        _ret_   getword i_sp, i_sp, #0

' --------------------------------------------------------------------

i_push_r16
                mov     pa, i_opcode
                call    #\i_getr16
                jmp     #i_push

i_pop_r16
                call    #i_pop
                mov     pa, i_opcode
                jmp     #\i_setr16

i_push_sreg
                mov     pa, i_opcode
                call    #\i_getsreg
                jmp     #i_push

i_pop_sreg
                call    #i_pop
                mov     pa, i_opcode
                jmp     #\i_setsreg

' --------------------------------------------------------------------

i_daas
                getbyte i_data, i_ax, #0

                getword i_temp0, i_flags, #0    ' save flags
                bitl    i_temp0, #I_AF_BIT
                bitl    i_temp0, #I_CF_BIT

                getnib  i_temp1, i_ax, #0
                cmpr    i_temp1, #$9        wc
                testb   i_flags, #I_AF_BIT  orc
        if_nc   jmp     #.l1

                testb   i_opcode, #3        wz
                getbyte i_data1, i_ax, #0
                sumz    i_data1, #6
                setbyte i_data, i_data1, #0

                testb   i_flags, #I_CF_BIT  wc
                testn   i_data, #$FF        wz
   if_c_or_nz   bith    i_temp0, #I_CF_BIT

                bith    i_temp0, #I_AF_BIT

.l1
                getbyte i_data1, i_ax, #0
                cmpr    i_data1, #$99       wc
                testb   i_flags, #I_CF_BIT  orc

                testb   i_opcode, #3        wz
        if_c    sumz    i_data, #$60
                bitc    i_temp0, #I_CF_BIT

                setbyte i_ax, i_data, #0
                setword i_flags, i_temp0, #0

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT
                test    i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_aaas
                getnib  i_temp1, i_ax, #0
                cmpr    i_temp1, #$9        wc
                testb   i_flags, #I_AF_BIT  orc

                testb   i_opcode, #3        wz
                getbyte i_data, i_ax, #0
        if_c    sumz    i_data, #6
                setbyte i_ax, i_data, #0

                getbyte i_data, i_ax, #1
        if_c    sumz    i_data, #1
                setbyte i_ax, i_data, #1

                muxc    i_flags, #(1 << I_CF_BIT) | (1 << I_AF_BIT)

                setnib  i_ax, #0, #1

                test    i_ax, #$0F          wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_aam
                call    #\i_readcodeb
                getbyte i_data, i_ax, #0

                qdiv    i_data, i_tmpb
                getqx   i_temp0
                getqy   i_temp1
                setbyte i_ax, i_temp0, #1
                setbyte i_ax, i_temp1, #0

                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT
                bitl    i_flags, #I_AF_BIT

                testb   i_ax, #7            wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF          wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_aad
                call    #\i_readcodeb
                getbyte i_data, i_ax, #1
                mul     i_data, i_tmpb

                getbyte i_temp0, i_ax, #0
                add     i_data, i_temp0

                getbyte i_ax, i_data, #0

                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT
                bitl    i_flags, #I_AF_BIT

                testb   i_ax, #7            wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF          wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

' --------------------------------------------------------------------

i_call_far
                call    #\i_readimmw
                getword i_data0, i_data, #0
                call    #\i_readimmw
                getword i_data1, i_data, #0

                getword i_data, i_cs, #0
                call    #i_push
                getword i_data, i_ip, #0
                call    #i_push

                getword i_cs, i_data1, #0
        _ret_   getword i_ip, i_data0, #0

i_jmp_far
                call    #\i_readimmw
                getword i_data0, i_data, #0
                call    #\i_readimmw
                getword i_cs, i_data, #0
        _ret_   getword i_ip, i_data0, #0

i_call_near
                call    #\i_readimmw
                getword i_data0, i_data, #0

                getword i_data, i_ip, #0
                call    #i_push

        _ret_   getword i_ip, i_data0, #0

i_jmp_near
                call    #\i_readimmw
        _ret_   getword i_ip, i_data, #0


i_call_displ
                call    #\i_readimmw
                getword i_data0, i_data, #0

                getword i_data, i_ip, #0
                call    #i_push

                add     i_ip, i_data0
        _ret_   getword i_ip, i_ip, #0

i_jmp_displ
                call    #\i_readimmw
                add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jmp_displ8
                call    #\i_readimmb
                signx   i_data, #7
                add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_loop
                call    #\i_readcodeb
                signx   i_tmpb, #7
                decmod  i_cx, i_ffffh       wz
        if_nz   add     i_ip, i_tmpb
        _ret_   getword i_ip, i_ip, #0

i_loope
                call    #\i_readcodeb
                signx   i_tmpb, #7
                decmod  i_cx, i_ffffh       wz
                testb   i_flags, #I_ZF_BIT  wc
  if_nz_and_c   add     i_ip, i_tmpb
        _ret_   getword i_ip, i_ip, #0

i_loopne
                call    #\i_readcodeb
                signx   i_tmpb, #7
                decmod  i_cx, i_ffffh       wz
                testb   i_flags, #I_ZF_BIT  wc
  if_nz_and_nc  add     i_ip, i_tmpb
        _ret_   getword i_ip, i_ip, #0

i_jcxz
                call    #\i_readcodeb
                signx   i_tmpb, #7
                cmp     i_cx, #0            wz
        if_z    add     i_ip, i_tmpb
        _ret_   getword i_ip, i_ip, #0

' --------------------------------------------------------------------

i_jo
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_OF_BIT  wz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jc
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_CF_BIT  wz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jz
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_ZF_BIT  wz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_js
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_SF_BIT  wz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jp
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_PF_BIT  wz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jce
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_CF_BIT  wz
                testb   i_flags, #I_ZF_BIT  orz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jl
                call    #\i_readimmb
                signx   i_data, #7
                testb   i_flags, #I_SF_BIT  wc  ' (SF != OF)
                testb   i_flags, #I_OF_BIT  wz  ' |
                modc    _c_ne_z             wc  ' | -> (C)
                testbn  i_flags, #I_ZF_BIT  wz  ' (!ZF) -> (Z)
    if_c_and_z  add     i_ip, i_data            ' ((SF != OF) && (!ZF))
        _ret_   getword i_ip, i_ip, #0

i_jle
                call    #\i_readimmb
                signx   i_data, #7
                testb   i_flags, #I_SF_BIT  wc  ' (SF != OF)
                testb   i_flags, #I_OF_BIT  wz  ' |
                modc    _c_ne_z             wc  ' | -> (C)
                testb   i_flags, #I_ZF_BIT  wz  ' (ZF) -> (Z)
    if_c_or_z   add     i_ip, i_data            ' ((SF != OF) || (ZF))
        _ret_   getword i_ip, i_ip, #0

i_jnl
                call    #\i_readimmb
                signx   i_data, #7
                testb   i_flags, #I_SF_BIT  wc
                testb   i_flags, #I_OF_BIT  wz
    if_c_eq_z   add     i_ip, i_data            ' (SF == OF)
        _ret_   getword i_ip, i_ip, #0

i_jnle
                call    #\i_readimmb
                signx   i_data, #7
                testb   i_flags, #I_SF_BIT  wc  ' (SF == OF)
                testb   i_flags, #I_OF_BIT  wz  ' |
                modc    _c_eq_z             wc  ' | -> (C)
                testbn  i_flags, #I_ZF_BIT  wz  ' (!ZF) -> (Z)
    if_c_and_z  add     i_ip, i_data            ' ((SF == OF) && (!ZF))
        _ret_   getword i_ip, i_ip, #0

' --------------------------------------------------------------------

i_in_al_imm
                call    #\i_readcodeb
                getbyte i_ea, i_tmpb, #0
                call    #\i_readiob
        _ret_   setbyte i_ax, i_tmpb, #0

i_in_ax_imm
                call    #\i_readcodeb
                getbyte i_ea, i_tmpb, #0
                call    #\i_readiob
                setbyte i_ax, i_tmpb, #0
                add     i_ea, #1
                call    #\i_readiob
        _ret_   setbyte i_ax, i_tmpb, #1

i_in_al_dx
                getword i_ea, i_dx, #0
                call    #\i_readiob
        _ret_   setbyte i_ax, i_tmpb, #0

i_in_ax_dx
                getword i_ea, i_dx, #0
                call    #\i_readiob
                setbyte i_ax, i_tmpb, #0
                add     i_ea, #1
                call    #\i_readiob
        _ret_   setbyte i_ax, i_tmpb, #1

i_out_imm_al
                call    #\i_readcodeb
                getbyte i_ea, i_tmpb, #0
                getbyte i_tmpb, i_ax, #0
                jmp     #\i_writeiob

i_out_imm_ax
                call    #\i_readcodeb
                getbyte i_ea, i_tmpb, #0
                getbyte i_tmpb, i_ax, #0
                call    #\i_writeiob
                add     i_ea, #1
                getbyte i_tmpb, i_ax, #1
                jmp     #\i_writeiob

i_out_dx_al
                getword i_ea, i_dx, #0
                getbyte i_tmpb, i_ax, #0
                jmp     #\i_writeiob

i_out_dx_ax
                getword i_ea, i_dx, #0
                getbyte i_tmpb, i_ax, #0
                call    #\i_writeiob
                add     i_ea, #1
                getbyte i_tmpb, i_ax, #1
                jmp     #\i_writeiob

' --------------------------------------------------------------------

i_xlatb
                getbyte i_temp0, i_ax, #0
                add     i_temp0, i_bx
                getword i_temp0, i_temp0, #0
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_temp0
                call    #\i_readmemb
        _ret_   setbyte i_ax, i_tmpb, #0

i_les
                call    #\i_setupmodrm
                call    #\i_setupea
                call    #\i_readw
                call    #\i_setmodr16
                call    #\i_readw
        _ret_   mov     i_es, i_data

i_lds
                call    #\i_setupmodrm
                call    #\i_setupea
                call    #\i_readw
                call    #\i_setmodr16
                call    #\i_readw
        _ret_   mov     i_ds, i_data

i_movsb
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si
                call    #\i_readb

                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di
                call    #\i_writeb

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_si, #1
                getword i_si, i_si, #0
                sumz    i_di, #1
        _ret_   getword i_di, i_di, #0

i_movsw
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si
                call    #\i_readw

                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di
                call    #\i_writew

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_si, #2
                getword i_si, i_si, #0
                sumz    i_di, #2
        _ret_   getword i_di, i_di, #0

i_lodsb
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si

                call    #\i_readb
                setbyte i_ax, i_data, #0

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_si, #1
        _ret_   getword i_si, i_si, #0

i_lodsw
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si

                call    #\i_readw
                getword i_ax, i_data, #0

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_si, #2
        _ret_   getword i_si, i_si, #0

i_stosb
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di

                getbyte i_data, i_ax, #0
                call    #\i_writeb

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #1
        _ret_   getword i_di, i_di, #0

i_stosw
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di

                getword i_data, i_ax, #0
                call    #\i_writew

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #2
        _ret_   getword i_di, i_di, #0

i_scasb
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di

                call    #\i_readb
                mov     i_data1, i_data

                getbyte i_data, i_ax, #0
                mov     i_data0, i_data

                sub     i_data, i_data1

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #1
                getword i_di, i_di, #0

                jmp     #\i_sub_flags8

i_scasw
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di

                call    #\i_readw
                mov     i_data1, i_data

                getword i_data, i_ax, #0
                mov     i_data0, i_data

                sub     i_data, i_data1

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #2
                getword i_di, i_di, #0

                jmp     #\i_sub_flags16

i_cmpsb
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di
                call    #\i_readb
                mov     i_data1, i_data

                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si
                call    #\i_readb
                mov     i_data0, i_data

                sub     i_data, i_data1

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #1
                getword i_di, i_di, #0
                sumz    i_si, #1
                getword i_si, i_si, #0

                jmp     #\i_sub_flags8

i_cmpsw
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di
                call    #\i_readw
                mov     i_data1, i_data

                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si
                call    #\i_readw
                mov     i_data0, i_data

                sub     i_data, i_data1

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #2
                getword i_di, i_di, #0
                sumz    i_si, #2
                getword i_si, i_si, #0

                jmp     #\i_sub_flags16

' --------------------------------------------------------------------

i_divzero
                getword i_ip, i_ip_start, #0
                mov     i_temp0, #0
                jmp     #i_trap

i_into
                testb   i_flags, #I_OF_BIT  wz
        if_x1   mov     i_temp0, #4
        if_x1   jmp     #i_trap
                ret

i_int3          mov     i_temp0, #3
                jmp     #i_trap

i_int           call    #\i_readcodeb
                mov     i_temp0, i_tmpb
i_trap          getword i_data, i_flags, #0
                and     i_data, ##ALL_FLAGS
                or      i_data, i_flags_pre
                call    #i_push
                getword i_data, i_cs, #0
                call    #i_push
                getword i_data, i_ip, #0
                call    #i_push
                bitl    i_flags, #I_TF_BIT
                bitl    i_flags, #I_IF_BIT
                mov     i_ea, i_temp0
                shl     i_ea, #2
                call    #\i_readw
                getword i_ip, i_data, #0
                call    #\i_readw
        _ret_   getword i_cs, i_data, #0

i_iret
                call    #i_pop
                getword i_ip, i_data, #0
                call    #i_pop
                getword i_cs, i_data, #0
                call    #i_pop
                setword i_flags, i_data, #0
        _ret_   bith    i_flags, #I_NO_INT_BIT

' --------------------------------------------------------------------

i_d2_prefix
                getbyte i_rep_cnt, i_cx, #0
                skip    #%1
i_d0_prefix
                mov     i_rep_cnt, #1

                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data0, i_data

                cmp     i_rep_cnt, #0           wz
        if_z    ret
                and     i_rep_cnt, #$1F             ' *** 286 ***

                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' ROL
        if_z    jmp     #.rol
                cmp     i_temp0, #%00_001_000   wz  ' ROR
        if_z    jmp     #.ror
                cmp     i_temp0, #%00_010_000   wz  ' ROLC
        if_z    jmp     #.rolc
                cmp     i_temp0, #%00_011_000   wz  ' RORC
        if_z    jmp     #.rorc
                cmp     i_temp0, #%00_100_000   wz  ' SHL
        if_z    jmp     #.shl
                cmp     i_temp0, #%00_101_000   wz  ' SHR
        if_z    jmp     #.shr
                cmp     i_temp0, #%00_110_000   wz
        if_z    jmp     #\@i_hlt
                cmp     i_temp0, #%00_111_000   wz  ' SHRA
        if_z    jmp     #.shra
                ret

.rol
                testb   i_data, #7          wc

                shl     i_data, #1
                bitc    i_data, #0

                djnz    i_rep_cnt, #.rol

                bitc    i_flags, #I_CF_BIT

                testb   i_flags, #I_CF_BIT  wz
                testb   i_data, #7          xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopb

.ror
                testb   i_data, #0          wc

                shr     i_data, #1
                bitc    i_data, #7

                djnz    i_rep_cnt, #.ror

                bitc    i_flags, #I_CF_BIT

                testb   i_data, #7          wz
                testb   i_data, #6          xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopb

.rolc
                testb   i_data, #7          wc

                shl     i_data, #1
                testb   i_flags, #I_CF_BIT  wz
                bitz    i_data, #0

                bitc    i_flags, #I_CF_BIT
                djnz    i_rep_cnt, #.rolc

                testb   i_flags, #I_CF_BIT  wz
                testb   i_data, #7          xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopb

.rorc
                testb   i_data, #0          wc

                shr     i_data, #1
                testb   i_flags, #I_CF_BIT  wz
                bitz    i_data, #7

                bitc    i_flags, #I_CF_BIT
                djnz    i_rep_cnt, #.rorc

                testb   i_data, #7          wz
                testb   i_data, #6          xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopb

.shl
                testb   i_data, #7          wc
                shl     i_data, #1
                djnz    i_rep_cnt, #.shl

                bitc    i_flags, #I_CF_BIT

                testb   i_data, #8          wz
                testb   i_data, #7          xorz
                bitz    i_flags, #I_OF_BIT

                test    i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopb

.shr
                cmp     i_rep_cnt, #1       wz  ' check count=1 for overflow
.shr_loop
                testb   i_data, #0          wc
                shr     i_data, #1
                djnz    i_rep_cnt, #.shr_loop

                bitc    i_flags, #I_CF_BIT

        if_z    testb   i_data0, #7         wc  ' overflow defined only if count=1
        if_z    bitc    i_flags, #I_OF_BIT
        if_nz   bitl    i_flags, #I_OF_BIT

                test    i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopb

.shra
                testb   i_data, #0          wc
                testb   i_data, #7          wz
                shr     i_data, #1
                bitz    i_data, #7
                djnz    i_rep_cnt, #.shra

                bitc    i_flags, #I_CF_BIT

                bitl    i_flags, #I_OF_BIT

                test    i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopb

i_d3_prefix
                getbyte i_rep_cnt, i_cx, #0
                skip    #%1
i_d1_prefix
                mov     i_rep_cnt, #1

                call    #\i_setupmodrm
                call    #\i_readopw
                mov     i_data0, i_data

                cmp     i_rep_cnt, #0           wz
        if_z    ret
                and     i_rep_cnt, #$1F             ' *** 286 ***

                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' ROL
        if_z    jmp     #.rol
                cmp     i_temp0, #%00_001_000   wz  ' ROR
        if_z    jmp     #.ror
                cmp     i_temp0, #%00_010_000   wz  ' ROLC
        if_z    jmp     #.rolc
                cmp     i_temp0, #%00_011_000   wz  ' RORC
        if_z    jmp     #.rorc
                cmp     i_temp0, #%00_100_000   wz  ' SHL
        if_z    jmp     #.shl
                cmp     i_temp0, #%00_101_000   wz  ' SHR
        if_z    jmp     #.shr
                cmp     i_temp0, #%00_110_000   wz
        if_z    jmp     #\@i_hlt
                cmp     i_temp0, #%00_111_000   wz  ' SHRA
        if_z    jmp     #.shra
                ret

.rol
                testb   i_data, #15         wc

                shl     i_data, #1
                bitc    i_data, #0

                djnz    i_rep_cnt, #.rol

                bitc    i_flags, #I_CF_BIT

                testb   i_flags, #I_CF_BIT  wz
                testb   i_data, #15         xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopw

.ror
                testb   i_data, #0          wc

                shr     i_data, #1
                bitc    i_data, #15

                djnz    i_rep_cnt, #.ror

                bitc    i_flags, #I_CF_BIT

                testb   i_data, #15         wz
                testb   i_data, #14         xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopw

.rolc
                testb   i_data, #15         wc

                shl     i_data, #1
                testb   i_flags, #I_CF_BIT  wz
                bitz    i_data, #0

                bitc    i_flags, #I_CF_BIT
                djnz    i_rep_cnt, #.rolc

                testb   i_flags, #I_CF_BIT  wz
                testb   i_data, #15         xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopw

.rorc
                testb   i_data, #0          wc

                shr     i_data, #1
                testb   i_flags, #I_CF_BIT  wz
                bitz    i_data, #15

                bitc    i_flags, #I_CF_BIT
                djnz    i_rep_cnt, #.rorc

                testb   i_data, #15         wz
                testb   i_data, #14         xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopw

.shl
                testb   i_data, #15         wc
                shl     i_data, #1
                djnz    i_rep_cnt, #.shl

                bitc    i_flags, #I_CF_BIT

                testb   i_data, #16         wz
                testb   i_data, #15         xorz
                bitz    i_flags, #I_OF_BIT

                test    i_data, i_ffffh     wz
                bitz    i_flags, #I_ZF_BIT

                test    i_data, #$FF        wc
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopw

.shr
                cmp     i_rep_cnt, #1       wz  ' check count=1 for overflow
.shr_loop
                testb   i_data, #0          wc
                shr     i_data, #1
                djnz    i_rep_cnt, #.shr_loop

                bitc    i_flags, #I_CF_BIT

        if_z    testb   i_data0, #15        wc  ' overflow defined only if count=1
        if_z    bitc    i_flags, #I_OF_BIT
        if_nz   bitl    i_flags, #I_OF_BIT

                test    i_data, i_ffffh     wz
                bitz    i_flags, #I_ZF_BIT

                test    i_data, #$FF        wc
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopw

.shra
                testb   i_data, #0          wc
                testb   i_data, #15         wz
                shr     i_data, #1
                bitz    i_data, #15
                djnz    i_rep_cnt, #.shra

                bitc    i_flags, #I_CF_BIT

                bitl    i_flags, #I_OF_BIT

                test    i_data, i_ffffh     wz
                bitz    i_flags, #I_ZF_BIT

                test    i_data, #$FF        wc
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopw

' --------------------------------------------------------------------

i_lock
i_wait
                ret

i_cmc   _ret_   bitnot  i_flags, #I_CF_BIT

i_clc   _ret_   bitl    i_flags, #I_CF_BIT

i_stc   _ret_   bith    i_flags, #I_CF_BIT

i_cli   _ret_   bitl    i_flags, #I_IF_BIT

i_sti           bith    i_flags, #I_NO_INT_BIT
        _ret_   bith    i_flags, #I_IF_BIT

i_cld   _ret_   bitl    i_flags, #I_DF_BIT

i_std   _ret_   bith    i_flags, #I_DF_BIT

i_cbw
                signx   i_ax, #7
        _ret_   getword i_ax, i_ax, #0

i_cwd
                testb   i_ax, #15           wc
        _ret_   muxc    i_dx, i_ffffh

i_salc
                testb   i_flags, #I_CF_BIT  wc
        _ret_   muxc    i_ax, #$FF

i_sahf
                getbyte i_data, i_ax, #1
                and     i_data, ##ALL_FLAGS
                or      i_data, i_flags_pre
        _ret_   setbyte i_flags, i_data, #0

i_lahf
                getword i_data, i_flags, #0
                or      i_data, i_flags_pre
        _ret_   setbyte i_ax, i_data, #1

i_lea
                call    #\i_setupmodrm
                getword i_data, i_offset, #0
                jmp     #\i_setmodr16

i_xchg
                mov     pa, i_opcode
                call    #\i_getr16
                mov     i_data0, i_data
                getword i_data, i_ax, #0
                getword i_ax, i_data0, #0
                jmp     #\i_setr16

i_xchg_modrm8
                call    #\i_setupmodrm

                call    #\i_readopb
                mov     i_data1, i_data

                call    #\i_getmodr8
                mov     i_data0, i_data

                mov     i_data, i_data1
                call    #\i_setmodr8
                mov     i_data, i_data0
                jmp     #\i_writeopb

i_xchg_modrm16
                call    #\i_setupmodrm

                call    #\i_readopw
                mov     i_data1, i_data

                call    #\i_getmodr16
                mov     i_data0, i_data

                mov     i_data, i_data1
                call    #\i_setmodr16
                mov     i_data, i_data0
                jmp     #\i_writeopw

CON             ' 8086 Constants

    I_CF_BIT = 0    ' Carry
    I_PF_BIT = 2    ' Parity
    I_AF_BIT = 4    ' Aux. Carry
    I_ZF_BIT = 6    ' Zero
    I_SF_BIT = 7    ' Sign
    I_TF_BIT = 8    ' Trap
    I_IF_BIT = 9    ' Interrupt
    I_DF_BIT = 10   ' Direction
    I_OF_BIT = 11   ' Overflow

    ALL_FLAGS = (1 << I_CF_BIT) | (1 << I_PF_BIT) | (1 << I_AF_BIT) | (1 << I_ZF_BIT) | (1 << I_SF_BIT) | (1 << I_TF_BIT) | (1 << I_IF_BIT) | (1 << I_DF_BIT) | (1 << I_OF_BIT)

    I_REP_BIT    = 26
    I_REP_ZF_BIT = 27

    I_SEG_BIT    = 28
    I_HALT_BIT   = 29
    I_LOCK_BIT   = 30
    I_NO_INT_BIT = 31

    I_INT_LOCK   = 0
    I_TIMER_LOCK = 1
    I_DMA_LOCK   = 2

    I_SYS_TMR0_HL    = 0
    I_SYS_TMR0_LATCH = 3
    I_SYS_TMR1_HL    = 1
    I_SYS_TMR1_LATCH = 4
    I_SYS_TMR2_HL    = 2
    I_SYS_TMR2_LATCH = 5

    I_SYS_DMA_HL     = 6

    I_SYS_KB_RESET   = 7

DAT             ' PIT 8254
                org     $000

i8254
                getct   t_lastct1

t_loop
                addct1  t_lastct1, #(_CLKFREQ / 1_193_180) + 1
.wait           pollct1 wc
        if_nc   jmp     #.wait

.lock           locktry #I_TIMER_LOCK wc ' acquire timer lock
        if_nc   jmp     #.lock

                rdlong  t_ctrl, #@tmr0
                mov     t_temp0, t_ctrl
                and     t_temp0, t_reload_mask
                wrlong  t_temp0, #@tmr0

                lockrel #I_TIMER_LOCK    ' release lock

                getbyte t_temp0, t_ctrl, #3
                and     t_flags, #%00111000
                or      t_flags, t_temp0

t_timer0
                testb   t_flags, #TIMER0_ENABLE wz
        if_x0   jmp     #t_timer1

                bitl    t_flags, #TIMER0_RELOAD wcz
        if_x1   rdword  t_count0, #@tmr0_reload
        if_x1   wrword  t_count0, #@tmr0_cnt
        if_x1   jmp     #t_timer1

                getbyte t_temp0, t_ctrl, #0
                and     t_temp0, #%0000_111_0 wz
'        if_z    jmp     #.mode0
'                cmp     t_temp0, #%0000_001_0 wz
'        if_e    jmp     #.mode1
                cmp     t_temp0, #%0000_010_0 wz
        if_ne   cmp     t_temp0, #%0000_110_0 wz
        if_e    jmp     #.mode2
                cmp     t_temp0, #%0000_011_0 wz
        if_ne   cmp     t_temp0, #%0000_111_0 wz
        if_e    jmp     #.mode3
'                cmp     t_temp0, #%0000_100_0 wz
'        if_e    jmp     #.mode4
'                cmp     t_temp0, #%0000_101_0 wz
'        if_e    jmp     #.mode5
'                jmp     #t_timer1
.mode0
.mode4
                decmod  t_count0, t_ffffh       wcz
                wrword  t_count0, #@tmr0_cnt
        if_nz   jmp     #t_timer1
                jmp     #t_trigger_irq
.mode2
.mode3
                decmod  t_count0, t_ffffh       wcz
                wrword  t_count0, #@tmr0_cnt
        if_nz   jmp     #t_timer1
                bith    t_flags, #TIMER0_RELOAD

t_trigger_irq
.lock           locktry #I_INT_LOCK  wc ' acquire irq lock
        if_nc   jmp     #.lock

                rdbyte  htmp1, #@pic_irq
                bith    htmp1, #0
                wrbyte  htmp1, #@pic_irq

                lockrel #I_INT_LOCK ' release lock

t_timer1
                testb   t_flags, #TIMER1_ENABLE wz
        if_x0   jmp     #t_timer2

                bitl    t_flags, #TIMER1_RELOAD wcz
        if_x1   rdword  t_count1, #@tmr1_reload
        if_x1   wrword  t_count1, #@tmr1_cnt
        if_x1   jmp     #t_timer2

                getbyte t_temp0, t_ctrl, #1
                and     t_temp0, #%0000_111_0 wz
'        if_z    jmp     #.mode0
'                cmp     t_temp0, #%0000_001_0 wz
'        if_e    jmp     #.mode1
                cmp     t_temp0, #%0000_010_0 wz
        if_ne   cmp     t_temp0, #%0000_110_0 wz
        if_e    jmp     #.mode2
                cmp     t_temp0, #%0000_011_0 wz
        if_ne   cmp     t_temp0, #%0000_111_0 wz
        if_e    jmp     #.mode3
'                cmp     t_temp0, #%0000_100_0 wz
'        if_e    jmp     #.mode4
'                cmp     t_temp0, #%0000_101_0 wz
'        if_e    jmp     #.mode5
'                jmp     #t_timer1
.mode0
.mode4
                decmod  t_count1, t_ffffh       wcz
                wrword  t_count1, #@tmr1_cnt
        if_nz   jmp     #t_timer2
                jmp     #t_dma_tick
.mode2
.mode3
                decmod  t_count1, t_ffffh       wcz
                wrword  t_count1, #@tmr1_cnt
        if_nz   jmp     #t_timer2
                bith    t_flags, #TIMER1_RELOAD

t_dma_tick
.lock           locktry #I_DMA_LOCK wc  ' acquire dma lock
        if_nc   jmp     #.lock

                rdlong  t_dma_ctl, #@dma_ctl

                rdlong  t_dma_mode, #@dma_mode
                testb   t_dma_mode, #4        wz    ' auto init?
        if_x0   bitl    t_dma_ctl, #16 + 0          ' | yes, clear dma mask

                testb   t_dma_ctl, #8 + 2     wz    ' controller enable
        if_x1   jmp     #.unlock
                testb   t_dma_ctl, #16 + 0    wz    ' ch0 mask
        if_x1   jmp     #.unlock
                bitl    t_dma_ctl, #4 + 0     wcz   ' ch0 request
        if_x1   jmp     #.unlock

                rdword  t_temp0, #@dma              ' ch0 address
                incmod  t_temp0, i_ffffh
                wrword  t_temp0, #@dma
                rdword  t_temp0, #@dma + 2          ' ch0 counter
                sub     t_temp0, #1           wz
                wrword  t_temp0, #@dma + 2
        if_z    bith    t_dma_ctl, #0               ' signal ch0 end

.unlock
                wrbyte  t_dma_ctl, #@dma_ctl
                lockrel #I_DMA_LOCK     ' release lock

t_timer2
                testb   t_flags, #TIMER2_ENABLE wz
        if_x0   jmp     #t_done

                bitl    t_flags, #TIMER2_RELOAD wcz
        if_x1   rdword  t_count2, #@tmr2_reload
        if_x1   wrword  t_count2, #@tmr2_cnt
        if_x1   jmp     #t_done

                getbyte t_temp0, t_ctrl, #2
                and     t_temp0, #%0000_111_0 wz
'        if_z    jmp     #.mode0
'                cmp     t_temp0, #%0000_001_0 wz
'        if_e    jmp     #.mode1
                cmp     t_temp0, #%0000_010_0 wz
        if_ne   cmp     t_temp0, #%0000_110_0 wz
        if_e    jmp     #.mode2
                cmp     t_temp0, #%0000_011_0 wz
        if_ne   cmp     t_temp0, #%0000_111_0 wz
        if_e    jmp     #.mode3
'                cmp     t_temp0, #%0000_100_0 wz
'        if_e    jmp     #.mode4
'                cmp     t_temp0, #%0000_101_0 wz
'        if_e    jmp     #.mode5
'                jmp     #t_timer1
.mode0
.mode4
                decmod  t_count2, t_ffffh       wcz
                wrword  t_count2, #@tmr2_cnt
        if_nz   jmp     #t_done
                ' TODO ???
                jmp     #t_done
.mode2
                decmod  t_count2, t_ffffh       wcz
                wrword  t_count2, #@tmr2_cnt
        if_nz   jmp     #t_done
                bith    t_flags, #TIMER2_RELOAD
                ' TODO ???
                jmp     #t_done
.mode3
                decmod  t_count2, t_ffffh       wcz
        if_nz   decmod  t_count2, t_ffffh       wcz
                wrword  t_count2, #@tmr2_cnt
        if_nz   jmp     #t_done
                bith    t_flags, #TIMER2_RELOAD
                ' TODO ???
                jmp     #t_done

t_done
                jmp     #t_loop

t_flags         long    %00111000
t_reload_mask   long    %11000111_11111111_11111111_11111111
t_ffffh         long    $FFFF

t_lastct1       res     1

t_ctrl          res     1
t_count0        res     1
t_count1        res     1
t_count2        res     1

t_dma_ctl       res     1
t_dma_mode      res     1

t_temp0         res     1

DAT             ' PIT 8254 HUB I/O
                orgh

pit_40_wr
                debug("I/O (W): ", uhex_byte(i_ea,i_tmpb))
.lock           locktry #I_TIMER_LOCK  wc      ' acquire timer lock
        if_nc   jmp     #.lock
                rdlong  i_pit, #@tmr0

                testb   i_pit, #PIT_TMR0_MODE5 wc
                testb   i_pit, #PIT_TMR0_MODE4 wz
        if_01   call    #.ctl_01    ' write counter bits 0-7 only
        if_10   call    #.ctl_10    ' write counter bits 8-15 only
        if_11   call    #.ctl_11    ' write counter bits 0-7 first, then 8-15

                wrlong  i_pit, #@tmr0
                lockrel #I_TIMER_LOCK ' release lock

                ret     wcz
.ctl_01
                wrword  i_tmpb, #@tmr0_reload
                bith    i_pit, #PIT_TMR0_ENABLE ' enable timer
        _ret_   bith    i_pit, #PIT_TMR0_RELOAD ' signal reload counter
.ctl_10
                shl     i_tmpb, #8
                wrword  i_tmpb, #@tmr0_reload
                bith    i_pit, #PIT_TMR0_ENABLE ' enable timer
        _ret_   bith    i_pit, #PIT_TMR0_RELOAD ' signal reload counter
.ctl_11
                bitnot  i_sys_flags, #I_SYS_TMR0_HL wcz
                rdword  i_temp0, #@tmr0_reload
        if_0x   setbyte i_temp0, i_tmpb, #0
        if_1x   setbyte i_temp0, i_tmpb, #1
                wrword  i_temp0, #@tmr0_reload
        if_1x   bith    i_pit, #PIT_TMR0_ENABLE ' enable timer (if write complete)
        if_1x   bith    i_pit, #PIT_TMR0_RELOAD ' signal reload counter
                ret

pit_40_rd
                rdlong  i_pit, #@tmr0
                testb   i_pit, #PIT_TMR0_MODE5 wc
                testb   i_pit, #PIT_TMR0_MODE4 wz
        if_01   jmp     #.ctl_01    ' read counter bits 0-7 only
        if_10   jmp     #.ctl_10    ' read counter bits 8-15 only
        if_11   jmp     #.ctl_11    ' read counter bits 0-7 first, then 8-15
                ret     wcz
.ctl_01
                bitl    i_sys_flags, #I_SYS_TMR0_LATCH  wcz
        if_x0   rdword  i_temp0, #@tmr0_cnt
        if_x1   getword i_temp0, i_pit_latches, #0
                getbyte i_tmpb, i_temp0, #0
                ret     wcz
.ctl_10
                bitl    i_sys_flags, #I_SYS_TMR0_LATCH    wcz
        if_x0   rdword  i_temp0, #@tmr0_cnt
        if_x1   getword i_temp0, i_pit_latches, #0
                getbyte i_tmpb, i_temp0, #1
                ret     wcz
.ctl_11
                bitnot  i_sys_flags, #I_SYS_TMR0_HL       wcz
                testb   i_sys_flags, #I_SYS_TMR0_LATCH    wz
        if_x0   rdword  i_temp0, #@tmr0_cnt
        if_x1   getword i_temp0, i_pit_latches, #0

        if_0x   getbyte i_tmpb, i_temp0, #0
        if_1x   getbyte i_tmpb, i_temp0, #1
        if_1x   bitl    i_sys_flags, #I_SYS_TMR0_LATCH
                ret     wcz

pit_41_wr
                debug("I/O (W): ", uhex_byte(i_ea,i_tmpb))
.lock           locktry #I_TIMER_LOCK  wc      ' acquire timer lock
        if_nc   jmp     #.lock
                rdlong  i_pit, #@tmr0

                testb   i_pit, #PIT_TMR1_MODE5 wc
                testb   i_pit, #PIT_TMR1_MODE4 wz
        if_01   call    #.ctl_01    ' write counter bits 0-7 only
        if_10   call    #.ctl_10    ' write counter bits 8-15 only
        if_11   call    #.ctl_11    ' write counter bits 0-7 first, then 8-15

                wrlong  i_pit, #@tmr0
                lockrel #I_TIMER_LOCK ' release lock

                ret     wcz
.ctl_01
                wrword  i_tmpb, #@tmr1_reload
                bith    i_pit, #PIT_TMR1_ENABLE ' enable timer
        _ret_   bith    i_pit, #PIT_TMR1_RELOAD ' signal reload counter
.ctl_10
                shl     i_tmpb, #8
                wrword  i_tmpb, #@tmr1_reload
                bith    i_pit, #PIT_TMR1_ENABLE ' enable timer
        _ret_   bith    i_pit, #PIT_TMR1_RELOAD ' signal reload counter
.ctl_11
                bitnot  i_sys_flags, #I_SYS_TMR1_HL   wcz
                rdword  i_temp0, #@tmr1_reload
        if_0x   setbyte i_temp0, i_tmpb, #0
        if_1x   setbyte i_temp0, i_tmpb, #1
                wrword  i_temp0, #@tmr1_reload
        if_1x   bith    i_pit, #PIT_TMR1_ENABLE ' enable timer (if write complete)
        if_1x   bith    i_pit, #PIT_TMR1_RELOAD ' signal reload counter
                ret

pit_41_rd
                rdlong  i_pit, #@tmr0
                testb   i_pit, #PIT_TMR1_MODE5 wc
                testb   i_pit, #PIT_TMR1_MODE4 wz
        if_01   jmp     #.ctl_01    ' read counter bits 0-7 only
        if_10   jmp     #.ctl_10    ' read counter bits 8-15 only
        if_11   jmp     #.ctl_11    ' read counter bits 0-7 first, then 8-15
                ret     wcz
.ctl_01
                bitl    i_sys_flags, #I_SYS_TMR1_LATCH    wcz
        if_x0   rdword  i_temp0, #@tmr1_cnt
        if_x1   getword i_temp0, i_pit_latches, #1
                getbyte i_tmpb, i_temp0, #0
                ret     wcz
.ctl_10
                bitl    i_sys_flags, #I_SYS_TMR1_LATCH    wcz
        if_x0   rdword  i_temp0, #@tmr1_cnt
        if_x1   getword i_temp0, i_pit_latches, #1
                getbyte i_tmpb, i_temp0, #1
                ret     wcz
.ctl_11
                bitnot  i_sys_flags, #I_SYS_TMR1_HL       wcz
                testb   i_sys_flags, #I_SYS_TMR1_LATCH    wz
        if_x0   rdword  i_temp0, #@tmr1_cnt
        if_x1   getword i_temp0, i_pit_latches, #1

        if_0x   getbyte i_tmpb, i_temp0, #0
        if_1x   getbyte i_tmpb, i_temp0, #1
        if_1x   bitl    i_sys_flags, #I_SYS_TMR1_LATCH
                ret     wcz

pit_42_wr
                debug("I/O (W): ", uhex_byte(i_ea,i_tmpb))
.lock           locktry #I_TIMER_LOCK  wc      ' acquire timer lock
        if_nc   jmp     #.lock
                rdlong  i_pit, #@tmr0

                testb   i_pit, #PIT_TMR2_MODE5 wc
                testb   i_pit, #PIT_TMR2_MODE4 wz
        if_01   call    #.ctl_01    ' write counter bits 0-7 only
        if_10   call    #.ctl_10    ' write counter bits 8-15 only
        if_11   call    #.ctl_11    ' write counter bits 0-7 first, then 8-15

                wrlong  i_pit, #@tmr0
                lockrel #I_TIMER_LOCK ' release lock

                ret     wcz
.ctl_01
                wrword  i_tmpb, #@tmr2_reload
                bith    i_pit, #PIT_TMR2_ENABLE ' enable timer
        _ret_   bith    i_pit, #PIT_TMR2_RELOAD ' signal reload counter
.ctl_10
                shl     i_tmpb, #8
                wrword  i_tmpb, #@tmr2_reload
                bith    i_pit, #PIT_TMR2_ENABLE ' enable timer
        _ret_   bith    i_pit, #PIT_TMR2_RELOAD ' signal reload counter
.ctl_11
                bitnot  i_sys_flags, #I_SYS_TMR2_HL   wcz
                rdword  i_temp0, #@tmr2_reload
        if_0x   setbyte i_temp0, i_tmpb, #0
        if_1x   setbyte i_temp0, i_tmpb, #1
                wrword  i_temp0, #@tmr2_reload
        if_1x   bith    i_pit, #PIT_TMR2_ENABLE ' enable timer (if write complete)
        if_1x   bith    i_pit, #PIT_TMR2_RELOAD ' signal reload counter
                ret

pit_42_rd
                rdlong  i_pit, #@tmr0
                testb   i_pit, #PIT_TMR2_MODE5 wc
                testb   i_pit, #PIT_TMR2_MODE4 wz
        if_01   jmp     #.ctl_01    ' read counter bits 0-7 only
        if_10   jmp     #.ctl_10    ' read counter bits 8-15 only
        if_11   jmp     #.ctl_11    ' read counter bits 0-7 first, then 8-15
                ret     wcz
.ctl_01
                bitl    i_sys_flags, #I_SYS_TMR2_LATCH    wcz
        if_x0   rdword  i_temp0, #@tmr2_cnt
        if_x1   getword i_temp0, i_pit_latches+1, #0
                getbyte i_tmpb, i_temp0, #0
                ret     wcz
.ctl_10
                bitl    i_sys_flags, #I_SYS_TMR2_LATCH    wcz
        if_x0   rdword  i_temp0, #@tmr1_cnt
        if_x1   getword i_temp0, i_pit_latches+1, #0
                getbyte i_tmpb, i_temp0, #1
                ret     wcz
.ctl_11
                bitnot  i_sys_flags, #I_SYS_TMR2_HL       wcz
                testb   i_sys_flags, #I_SYS_TMR2_LATCH    wz
        if_x0   rdword  i_temp0, #@tmr1_cnt
        if_x1   getword i_temp0, i_pit_latches+1, #0

        if_0x   getbyte i_tmpb, i_temp0, #0
        if_1x   getbyte i_tmpb, i_temp0, #1
        if_1x   bitl    i_sys_flags, #I_SYS_TMR2_LATCH
                ret     wcz

pit_43_wr
                debug("I/O (W): ", uhex_byte(i_ea,i_tmpb))
                testb   i_tmpb, #5          wc
                testb   i_tmpb, #4          wz
        if_00   jmp     #.latch

.lock           locktry #I_TIMER_LOCK  wc      ' acquire timer lock
        if_nc   jmp     #.lock
                rdlong  i_pit, #@tmr0

                testb   i_tmpb, #7          wc
                testb   i_tmpb, #6          wz

        if_00   setbyte i_pit, i_tmpb, #0
        if_00   bitl    i_pit, #PIT_TMR0_ENABLE
        if_00   bitl    i_sys_flags, #I_SYS_TMR0_LATCH
        if_00   bitl    i_sys_flags, #I_SYS_TMR0_HL

        if_01   setbyte i_pit, i_tmpb, #1
        if_01   bitl    i_pit, #PIT_TMR1_ENABLE
        if_01   bitl    i_sys_flags, #I_SYS_TMR1_LATCH
        if_01   bitl    i_sys_flags, #I_SYS_TMR1_HL

        if_10   setbyte i_pit, i_tmpb, #2
        if_10   bitl    i_pit, #PIT_TMR2_ENABLE
        if_10   bitl    i_sys_flags, #I_SYS_TMR2_LATCH
        if_10   bitl    i_sys_flags, #I_SYS_TMR2_HL

                wrlong  i_pit, #@tmr0
                lockrel #I_TIMER_LOCK ' release lock
                ret     wcz
.latch
                testb   i_tmpb, #7          wc
                testb   i_tmpb, #6          wz

        if_00   rdword  i_temp0, #@tmr0_cnt
        if_00   setword i_pit_latches, i_temp0, #0
        if_00   bith    i_sys_flags, #I_SYS_TMR0_LATCH
        if_00   bitl    i_sys_flags, #I_SYS_TMR0_HL

        if_01   rdword  i_temp0, #@tmr1_cnt
        if_01   setword i_pit_latches, i_temp0, #1
        if_01   bith    i_sys_flags, #I_SYS_TMR1_LATCH
        if_01   bitl    i_sys_flags, #I_SYS_TMR1_HL

        if_10   rdword  i_temp0, #@tmr2_cnt
        if_10   setword i_pit_latches+1, i_temp0, #0
        if_10   bith    i_sys_flags, #I_SYS_TMR2_LATCH
        if_10   bitl    i_sys_flags, #I_SYS_TMR2_HL

                ret     wcz

CON ' PIT 8254 Constants

    TIMER0_ENABLE   = 0
    TIMER1_ENABLE   = 1
    TIMER2_ENABLE   = 2

    TIMER0_RELOAD   = 3
    TIMER1_RELOAD   = 4
    TIMER2_RELOAD   = 5

    PIT_TMR0_MODE5 = 5
    PIT_TMR0_MODE4 = 4
    PIT_TMR1_MODE5 = 8 + 5
    PIT_TMR1_MODE4 = 8 + 4
    PIT_TMR2_MODE5 = 16 + 5
    PIT_TMR2_MODE4 = 16 + 4

    PIT_TMR0_ENABLE = 24 + TIMER0_ENABLE
    PIT_TMR0_RELOAD = 24 + TIMER0_RELOAD
    PIT_TMR1_ENABLE = 24 + TIMER1_ENABLE
    PIT_TMR1_RELOAD = 24 + TIMER1_RELOAD
    PIT_TMR2_ENABLE = 24 + TIMER2_ENABLE
    PIT_TMR2_RELOAD = 24 + TIMER2_RELOAD

DAT             ' NEC765
                org     $000

nec765
                add     ptrb, ##@nec765_lut - @nec765
                setq2   #(@nec765_lut_end - @nec765_lut) / 4 -1
                rdlong  0, ptrb

                setse1  #%001_000000 | FDC_PIN  ' setup events from FDC arbiter pin
                waitatn                         ' wait arbiter COG ready
                pollse1                         ' clear stale the event

                call    #\sd_init
  if_c_and_nz   jmp     #n_loop

                call    #\fs_mount
                cmp     fs_type, #0         wz
        if_z    jmp     #n_loop

                mov     fs_par0, ##@fs_file0
                call    #\fs_open
                mov     fs_par0, ##@fs_file1
                call    #\fs_open

n_loop
                testb   n_dor, #DOR_ENABLE  wc
                rdbyte  n_dor, #@fdc_dor
                testb   n_dor, #DOR_ENABLE  wz
        if_01   jmp     #n_reset

                testb   n_dor, #DOR_DRIVE0_MOTOR  wz
                drvz    #A_LED
                testb   n_dor, #DOR_DRIVE1_MOTOR  wz
                drvz    #B_LED

                rdbyte  n_temp0, #@fdc_fifo_tail
                rdbyte  n_temp1, #@fdc_fifo_head
                cmp     n_temp0, n_temp1    wz
                bitnz   n_msr, #MSR_BUSY
                bitnz   n_msr, #MSR_DATAIO
                wrbyte  n_msr, #@fdc_msr
        if_nz   jmp     #n_loop

                rdbyte  n_cmd_len, #@fdc_cmd_len wz
        if_z    jmp     #n_loop

                rdbyte  n_cmd, #@fdc_cmd
                and     n_cmd, #$0F

                cmp     n_cmd, #CMD_READ_TRACK   wz
        if_e    jmp     #n_read_track
                cmp     n_cmd, #CMD_SPECIFY      wz
        if_e    jmp     #n_specify
                cmp     n_cmd, #CMD_CHECK_STAT   wz
        if_e    jmp     #n_check_stat
                cmp     n_cmd, #CMD_WRITE_SECT   wz
        if_e    jmp     #n_write_sect
                cmp     n_cmd, #CMD_READ_SECT    wz
        if_e    jmp     #n_read_sect
                cmp     n_cmd, #CMD_CALIBRATE    wz
        if_e    jmp     #n_calibrate
                cmp     n_cmd, #CMD_CHECK_INT    wz
        if_e    jmp     #n_check_int
                cmp     n_cmd, #CMD_WRITE_DEL_S  wz
        if_e    jmp     #n_write_del_s
                cmp     n_cmd, #CMD_READ_ID_S    wz
        if_e    jmp     #n_read_id_s
                cmp     n_cmd, #CMD_READ_DEL_S   wz
        if_e    jmp     #n_read_del_s
                cmp     n_cmd, #CMD_FORMAT_TRACK wz
        if_e    jmp     #n_format_track
                cmp     n_cmd, #CMD_SEEK         wz
        if_e    jmp     #n_seek

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_loop

n_reset
                wrword  #0, #@fdc_fifo_head
                wrbyte  #0, #@fdc_cmd_len

                or      n_stat, #(1<<STATUS0_INT_INVALID)|(1<<STATUS0_INT_ABNORMAL)

                jmp     #n_trigger_irq

n_read_track
                cmp     n_cmd_len, #9           wcz
        if_lt   jmp     #n_loop

                'andn    n_stat, #(1<<STATUS0_INT_INVALID)|(1<<STATUS0_INT_ABNORMAL)

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_loop

n_specify
                cmp     n_cmd_len, #3           wcz
        if_lt   jmp     #n_loop

                andn    n_stat, #(1<<STATUS0_INT_INVALID)|(1<<STATUS0_INT_ABNORMAL)

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_loop

n_check_stat
                cmp     n_cmd_len, #2       wcz
        if_lt   jmp     #n_loop

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_loop

n_write_sect
                cmp     n_cmd_len, #9       wcz
        if_lt   jmp     #n_loop

                bith    n_msr, #MSR_BUSY
                bitl    n_msr, #MSR_DATAIO
                wrbyte  n_msr, #@fdc_msr

                rdbyte  n_drv, #@fdc_cmd+1      ' drive number
                and     n_drv, #%00000011       ' |
                andn    n_stat, #%11            ' clear drive#
                or      n_stat, n_drv           ' set current drive#

                cmp     n_drv, #0           wz
        if_z    mov     fs_par0, ##@fs_file0
                cmp     n_drv, #1           wz
        if_z    mov     fs_par0, ##@fs_file1
                cmp     n_drv, #2           wz
        if_nz   cmp     n_drv, #3           wz
        if_z    jmp     #n_loop

                mov     ptra, fs_par0
                rdlong  n_temp0, ptra[12/4] wz  ' file size
        if_z    wrbyte  #$00, #@fdc_cmd_len     ' 0 means no file found
        if_z    jmp     #n_loop                 ' |

                cmp     n_temp0, ##163_840  wz  ' 160KB
        if_e    mov     n_disk_params, ##$0028_08_01
                cmp     n_temp0, ##184_320  wz  ' 180KB
        if_e    mov     n_disk_params, ##$0028_09_01
                cmp     n_temp0, ##327_680  wz  ' 320KB
        if_e    mov     n_disk_params, ##$0028_08_02
                cmp     n_temp0, ##368_640  wz  ' 360KB
        if_e    mov     n_disk_params, ##$0028_09_02

                rdbyte  n_ctrack, #@fdc_cmd+2   ' track#
                rdbyte  n_chead, #@fdc_cmd+3    ' head#
                rdbyte  n_csector, #@fdc_cmd+4  ' sector#
                sub     n_csector, #1

.l2             mov     fs_par1, n_ctrack
                getbyte n_temp0, n_disk_params, #0 ' heads
                mul     fs_par1, n_temp0
                add     fs_par1, n_chead
                getbyte n_temp0, n_disk_params, #1 ' sectors
                mul     fs_par1, n_temp0
                add     fs_par1, n_csector

                call    #\fs_setup_sector
                mov     ptrb, ##@sd_data
                mov     pb, ##512
.l1             call    #\n_dma_read
                wrbyte  pa, ptrb++
        if_nc   djnz    pb, #.l1
                call    #\fs_write_sector
        if_c    jmp     #.done
                add     n_csector, #1
                getbyte n_temp0, n_disk_params, #1 ' sectors
                cmp     n_csector, n_temp0  wcz
        if_lt   jmp     #.l2
                mov     n_csector, #0
                add     n_chead, #1
                getbyte n_temp0, n_disk_params, #0 ' heads
                cmp     n_chead, n_temp0    wcz
        if_lt   jmp     #.l2
                mov     n_chead, #0
                add     n_ctrack, #1
                jmp     #.l2

.done           altsb   n_drv, #n_track         ' update drive track#
                setbyte n_ctrack

                cmp     n_ctrack, #0        wz
                bitz    n_stat, #STATUS3_TRK0   ' set track0 flag
                add     n_csector, #1

                getbyte pa, n_stat, #0          ' st0
                call    #n_fifo_write
                getbyte pa, n_stat, #1          ' st1
                call    #n_fifo_write
                getbyte pa, n_stat, #2          ' st2
                call    #n_fifo_write
                mov     pa, n_ctrack            ' track#
                call    #n_fifo_write
                mov     pa, n_chead             ' head#
                call    #n_fifo_write
                mov     pa, n_csector           ' sector#
                call    #n_fifo_write
                rdbyte  pa, #@fdc_cmd+5
                call    #n_fifo_write

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_trigger_irq

n_read_sect
                cmp     n_cmd_len, #9       wcz
        if_lt   jmp     #n_loop

                bith    n_msr, #MSR_BUSY
                bitl    n_msr, #MSR_DATAIO
                wrbyte  n_msr, #@fdc_msr

                rdbyte  n_drv, #@fdc_cmd+1      ' drive number
                and     n_drv, #%00000011       ' |
                andn    n_stat, #%11            ' clear drive#
                or      n_stat, n_drv           ' set current drive#

                cmp     n_drv, #0           wz
        if_z    mov     fs_par0, ##@fs_file0
                cmp     n_drv, #1           wz
        if_z    mov     fs_par0, ##@fs_file1
                cmp     n_drv, #2           wz
        if_nz   cmp     n_drv, #3           wz
        if_z    jmp     #n_loop

                mov     ptra, fs_par0
                rdlong  n_temp0, ptra[12/4] wz  ' file size
        if_z    wrbyte  #$00, #@fdc_cmd_len     ' 0 means no file found
        if_z    jmp     #n_loop                 ' |

                cmp     n_temp0, ##163_840  wz  ' 160KB
        if_e    mov     n_disk_params, ##$0028_08_01
                cmp     n_temp0, ##184_320  wz  ' 180KB
        if_e    mov     n_disk_params, ##$0028_09_01
                cmp     n_temp0, ##327_680  wz  ' 320KB
        if_e    mov     n_disk_params, ##$0028_08_02
                cmp     n_temp0, ##368_640  wz  ' 360KB
        if_e    mov     n_disk_params, ##$0028_09_02

                rdbyte  n_ctrack, #@fdc_cmd+2   ' track#
                rdbyte  n_chead, #@fdc_cmd+3    ' head#
                rdbyte  n_csector, #@fdc_cmd+4  ' sector#
                sub     n_csector, #1

.l2             mov     fs_par1, n_ctrack
                getbyte n_temp0, n_disk_params, #0 ' heads
                mul     fs_par1, n_temp0
                add     fs_par1, n_chead
                getbyte n_temp0, n_disk_params, #1 ' sectors
                mul     fs_par1, n_temp0
                add     fs_par1, n_csector

                call    #\fs_setup_sector
                call    #\fs_read_sector
                mov     pb, ##512
                mov     ptrb, ##@sd_data
.l1             rdbyte  pa, ptrb++
                call    #\n_dma_write
        if_nc   djnz    pb, #.l1
        if_c    jmp     #.done
                add     n_csector, #1
                getbyte n_temp0, n_disk_params, #1 ' sectors
                cmp     n_csector, n_temp0  wcz
        if_lt   jmp     #.l2
                mov     n_csector, #0
                add     n_chead, #1
                getbyte n_temp0, n_disk_params, #0 ' heads
                cmp     n_chead, n_temp0    wcz
        if_lt   jmp     #.l2
                mov     n_chead, #0
                add     n_ctrack, #1
                jmp     #.l2

.done           altsb   n_drv, #n_track         ' update drive track#
                setbyte n_ctrack

                cmp     n_ctrack, #0        wz
                bitz    n_stat, #STATUS3_TRK0   ' set track0 flag
                add     n_csector, #1

                getbyte pa, n_stat, #0          ' st0
                call    #n_fifo_write
                getbyte pa, n_stat, #1          ' st1
                call    #n_fifo_write
                getbyte pa, n_stat, #2          ' st2
                call    #n_fifo_write
                mov     pa, n_ctrack            ' track#
                call    #n_fifo_write
                mov     pa, n_chead             ' head#
                call    #n_fifo_write
                mov     pa, n_csector           ' sector#
                call    #n_fifo_write
                rdbyte  pa, #@fdc_cmd+5
                call    #n_fifo_write

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_trigger_irq

n_calibrate
                cmp     n_cmd_len, #2       wcz
        if_lt   jmp     #n_loop

                rdbyte  n_drv, #@fdc_cmd+1      ' drive number
                and     n_drv, #%00000011       ' |
                altsb   n_drv, #n_track
                setbyte #$00

                andn    n_stat, #%11            ' clear drive#
                or      n_stat, n_drv           ' set current drive#

                bith    n_stat, #STATUS3_TRK0   ' set track0 flag

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_trigger_irq

n_check_int
                getbyte pa, n_stat, #0          ' st0
                call    #n_fifo_write           ' |

                altgb   n_drv, #n_track         ' current drive track#
                getbyte pa                      ' |
                call    #n_fifo_write           ' |

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_loop

n_write_del_s
                cmp     n_cmd_len, #9           wcz
        if_lt   jmp     #n_loop

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_loop

n_read_id_s
                cmp     n_cmd_len, #2           wcz
        if_lt   jmp     #n_loop

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_loop

n_read_del_s
                cmp     n_cmd_len, #9           wcz
        if_lt   jmp     #n_loop

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_loop

n_format_track
                cmp     n_cmd_len, #6           wcz
        if_lt   jmp     #n_loop

                wrbyte  #$00, #@fdc_cmd_len
                jmp     #n_loop

n_seek
                cmp     n_cmd_len, #3           wcz
        if_lt   jmp     #n_loop

                rdbyte  n_drv, #@fdc_cmd+1      ' drive#
                and     n_drv, #%00000011       ' |

                andn    n_stat, #%11            ' clear drive#
                or      n_stat, n_drv           ' set current drive#

                rdbyte  n_temp0, #@fdc_cmd+2    ' track#
                altsb   n_drv, #n_track
                setbyte n_temp0
                cmp     n_temp0, #0             wz
                bitz    n_stat, #STATUS3_TRK0   ' set track0 flag

                wrbyte  #$00, #@fdc_cmd_len
                'jmp     #n_loop
                ' fall-through

n_trigger_irq
                testb   n_dor, #DOR_INT_ENABLE   wz
        if_x0   jmp     #n_loop

                waitx   ##_CLKFREQ / 1000 * 2

.lock           locktry #I_INT_LOCK  wc ' acquire irq lock
        if_nc   jmp     #.lock

                rdbyte  n_temp0, #@pic_irq
                bith    n_temp0, #6
                wrbyte  n_temp0, #@pic_irq

                lockrel #I_INT_LOCK ' release lock

                jmp     #n_loop

' write pa to fifo head
n_fifo_write
                rdbyte  n_temp0, #@fdc_fifo_head
                'debug("n_fifo_write ", uhex_byte(pa),udec(n_temp0))
                add     n_temp0, #@fdc_fifo
                wrbyte  pa, n_temp0
                sub     n_temp0, #@fdc_fifo
                incmod  n_temp0, #16 - 1
        _ret_   wrbyte  n_temp0, #@fdc_fifo_head

' write pa to dma address
n_dma_write
                rdbyte  n_ea, #@dma_page+2      ' get page address
                setnib  n_ea, n_ea, #4
                rdlong  n_dma, #@dma+8          ' get dma address and count
                setword n_ea, n_dma, #0         ' set address into ea

                shl     n_ea, #8                ' shift address to bits [27:8]
                setbyte n_ea, pa, #0            ' set byte to write to bits [7:0]
                bith    n_ea, #31               ' send write request (bit31=1)
                wxpin   n_ea, #FDC_PIN          ' |
                waitse1                         ' | clear our own event (why pollseX doesn't work here ?)
                waitse1                         ' | wait write complete

                getword n_temp0, n_dma, #0      ' increment address
                incmod  n_temp0, ##$FFFF        ' |
                setword n_dma, n_temp0, #0      ' |

                getword n_temp0, n_dma, #1      ' decrement count
                sub     n_temp0, #1         wc  ' |
                setword n_dma, n_temp0, #1      ' |

        _ret_   wrlong  n_dma, #@dma+8          ' update dma, C=1 reached TC

' read pa from dma address
n_dma_read
                rdbyte  n_ea, #@dma_page+2      ' get page address
                setnib  n_ea, n_ea, #4
                rdlong  n_dma, #@dma+8          ' get dma address and count
                setword n_ea, n_dma, #0         ' set address into ea

                wxpin   n_ea, #FDC_PIN          ' send read request (bit31=0)
                waitse1                         ' | clear our own event (why pollseX doesn't work here ?)
                waitse1                         ' | wait read complete
                rdpin   pa, #FDC_PIN            ' | read byte

                getword n_temp0, n_dma, #0      ' increment address
                incmod  n_temp0, ##$FFFF        ' |
                setword n_dma, n_temp0, #0      ' |

                getword n_temp0, n_dma, #1      ' decrement count
                sub     n_temp0, #1         wc  ' |
                setword n_dma, n_temp0, #1      ' |

        _ret_   wrlong  n_dma, #@dma+8          ' update dma, C=1 reached TC

n_msr           long    (1<<MSR_DATAREG)
n_stat          long    STATUS0_INT_ABNORMAL_POLL

n_drv           long    0                       ' current drive number
n_track         long    $00_00_00_00            ' drive track position

n_ctrack        long    0
n_chead         long    0
n_csector       long    0

n_disk_params   long    $0028_09_02
                '        |||| || ++-------------- heads
                '        |||| ++----------------- sectors/track
                '        ++++-------------------- tracks (cylinders)

'-------------------------------------------------------------------------------

sd_cmd          long    0                           ' The 8b CMDxx | $40
sd_cmdpar       long    0                           ' The 32b parameters
sd_cmdcrc       long    0                           ' The 8b CRC (must be valid for CMD0 & CMD8)
sd_cmdpar2      long    0                           ' SDV1=$0, SDV2=$40000000
sd_cmdtype      long    0                           ' reply is R1=1, R3=3, R7=7, else 0
sd_reply        long    0                           ' R1 reply (moved to replyR1 when R3/R7 32b reply here)
sd_replyR1      long    0                           ' R1 reply (8b saved when R3/R7 32b reply follows)
sd_replyR2      long    0                           ' R2 reply (32 bits)
sd_dataout      long    0                           ' 8/32 bit data being shifted out
sd_bytescnt     long    0                           ' #bytes to send/recv
sd_bitscnt      long    0                           ' #bits to be shifted in/out
sd_ctr1         long    0
sd_ini_time     long    0                           ' initial time
sd_time_out     long    0                           ' length of timeout
                                                    '\ 1=SDV1, 2=SDV2(byte address), 3=SDHC/SDV2(block address)
sd_blocksh      long    0                           '/ block shift 0/9 bits

sd_blocknr      long    0                           ' sector#
sd_data_p       long    0                           ' data buffer ptr

'-------------------------------------------------------------------------------

fs_begin        long    0       ' Partition start sector
fs_sectors      long    0       ' Partition sectors

fs_type         long    0       ' Filesystem type: 1=FAT16, 2=FAT32
fs_cluster_sh   long    0       ' Cluster sectors shift
fs_fat          long    0       ' FAT table start sector
fs_root         long    0       ' Root directory start sector
fs_root_entries long    0       ' Root directory entries
fs_data         long    0       ' Data section start

fs_cwd          res     1       ' Current working directory begin cluster (0=FAT16 root)
fs_cluster      res     1       ' Current cluster
fs_cluster_sect res     1       ' Current cluster sector index

fs_find_index   res     1

fs_ptr          res     1
fs_length       res     1

fs_par0         res     1
fs_par1         res     1
fs_par2         res     1
fs_par3         res     1

fs_memptr0      res     1
fs_memptr1      res     1
fs_tmp0         res     1
fs_tmp1         res     1
fs_tmp2         res     1

'-------------------------------------------------------------------------------

n_dor           res     1
n_cmd           res     1
n_cmd_len       res     1
n_ea            res     1
n_dma           res     1
n_temp0         res     1
n_temp1         res     1

DAT             ' NEC765 LUT code
                org     $200
nec765_lut

'+-------[ Mount Partition ]---------------------------------------------------+
'+ Call Format:                                                                +
'+      call    #\fs_mount                                                     +
'+ On Return:                                                                  +
'+      fs_type = file system type ($06, $0C), 0 if error                      +
'+-----------------------------------------------------------------------------+
fs_mount
                mov     sd_blocknr, #0
                mov     sd_data_p, ##@sd_data
                call    #\sd_read

                call    #\.check_type
        if_z    mov     fs_begin, #0
        if_z    jmp     #.l1

                call    #.get_partition
        'if_nz   TODO can't find a FAT16 or FAT32 partition, raise error

                mov     sd_blocknr, fs_begin
                mov     sd_data_p, ##@sd_data
                call    #\sd_read

.l1
                rdbyte  fs_cluster_sh, ##@sd_data + $0D ' sectors per cluster
                encod   fs_cluster_sh

                rdword  fs_fat, ##@sd_data + $0E    ' reserved sectors
                add     fs_fat, fs_begin            ' + fs_begin = FAT start sector

                cmp     fs_type, #$0C           wz
        if_z    jmp     #.fat32

                rdbyte  fs_tmp0, ##@sd_data + $10   ' number of FATs
                rdword  fs_tmp1, ##@sd_data + $16   ' sectors per FAT
                mul     fs_tmp0, fs_tmp1            ' total sectors for all FATs
                mov     fs_root, fs_fat             ' begin of FAT
                add     fs_root, fs_tmp0            '  + total FAT sectors = root directory start

                rdword  fs_root_entries, ##@sd_data + 17 ' root entries

                mov     fs_data, fs_root_entries
                shr     fs_data, #4                 ' root sectors
                add     fs_data, fs_root            ' = data section start
                ret
.fat32
                rdbyte  fs_tmp0, ##@sd_data + $10   ' number of FATs
                rdlong  fs_tmp1, ##@sd_data + $24   ' sectors per FAT
                mul     fs_tmp0, fs_tmp1            ' total sectors for all FATs
                mov     fs_data, fs_fat             ' begin of FAT
                add     fs_data, fs_tmp0            ' + total fat sectors = data section start

                rdlong  fs_root, ##@sd_data + $2C   ' root directory first cluster
                sub     fs_root, #2                 '
                shl     fs_root, fs_cluster_sh      '
                add     fs_root, fs_data            ' = root directory start sector

                decod   fs_root_entries, fs_cluster_sh
                shl     fs_root_entries, #4
                ret

.check_type
                rdlong  fs_tmp0, ##@sd_data + $36
                cmp     fs_tmp0, ##$31544146    wz  ' FAT1
        if_z    rdbyte  fs_tmp0, ##@sd_data + $3A
        if_z    cmp     fs_tmp0, #$36           wz  ' 6
        if_z    mov     fs_type, #$06
        if_z    ret

                rdlong  fs_tmp0, ##@sd_data + $52
                cmp     fs_tmp0, ##$33544146    wz  ' FAT3
        if_z    rdbyte  fs_tmp0, ##@sd_data + $56
        if_z    cmp     fs_tmp0, #$32           wz  ' 2
        if_z    mov     fs_type, #$0C
                ret

.get_partition
                mov     fs_tmp1, #4
                mov     ptra, ##@sd_data + $1BE
.l2             rdbyte  fs_tmp0, ptra[4]            ' type
                cmp     fs_tmp0, #$06           wz  ' FAT16
        if_nz   cmp     fs_tmp0, #$0E           wz  ' FAT16
        if_nz   cmp     fs_tmp0, #$0C           wz  ' FAT32
        if_nz   add     ptra, #16
        if_nz   djnz    fs_tmp1, #.l2
        if_z    rdlong  fs_begin, ptra[2]           ' $1C6 + (partition << 4)
        if_z    mov     fs_type, fs_tmp0
                ret

'+-------[ Find first/next directory entry ]-----------------------------------+
'+ Call Format:                                                                +
'+      call    #\fs_find_first                                                +
'+      call    #\fs_find_next                                                 +
'+ On Return:                                                                  +
'+      ptra    = Entry                                                        +
'+      Returns "NC" if ok, "C" if error                                       +
'+-----------------------------------------------------------------------------+
fs_find_first
                mov     fs_find_index, #0
fs_find_next
                cmps    fs_find_index, fs_root_entries  wcz
        if_ae   modc    _set    wc
        if_ae   ret

                mov     fs_tmp0, fs_find_index
                shr     fs_tmp0, #4
                add     fs_tmp0, fs_root
                cmp     fs_tmp0, sd_blocknr wz
        if_nz   mov     sd_blocknr, fs_tmp0
                mov     sd_data_p, ##@sd_data
        if_nz   call    #\sd_read

                mov     ptra, fs_find_index
                and     ptra, #$0F
                shl     ptra, #5
                add     ptra, ##@sd_data

                add     fs_find_index, #1       ' pre-select next entry

                rdbyte  fs_tmp0, ptra[11]       ' attribute
                test    fs_tmp0, #AM_VOLUME|AM_DIR wz ' skip volume id and directories
        if_nz   jmp     #fs_find_next           ' |
                and     fs_tmp0, #AM_LFN_MASK   ' check if LFN entry
                cmp     fs_tmp0, #AM_LFN    wz  ' |
        if_z    jmp     #fs_find_next           ' | yes, skip

                rdbyte  fs_tmp0, ptra
                cmp     fs_tmp0, #$E5       wz
        if_z    jmp     #fs_find_next
                cmp     fs_tmp0, #$00       wz
        if_z    modc    _set    wc
        if_nz   modc    _clr    wc

                ret

'+-------[ Open file for read/write ]------------------------------------------+
'+ Call Format:                                                                +
'+      mov     fs_par0, #@file_descriptor                                     +
'+      call    #\fs_open                                                      +
'+-----------------------------------------------------------------------------+
fs_open
                mov     ptrb, fs_par0
                call    #\fs_find_first
        if_c    jmp     #.end
.next           rdlong  fs_tmp0, ptra
                rdlong  fs_tmp1, ptrb
                cmp     fs_tmp0, fs_tmp1    wz
        if_z    rdlong  fs_tmp0, ptra[1]
        if_z    rdlong  fs_tmp1, ptrb[1]
        if_z    cmp     fs_tmp0, fs_tmp1    wz
        if_z    rdlong  fs_tmp0, ptra[1]
        if_z    setbyte fs_tmp0, #0, #3
        if_z    rdlong  fs_tmp1, ptrb[1]
        if_z    setbyte fs_tmp1, #0, #3
        if_z    cmp     fs_tmp0, fs_tmp1    wz
        if_z    jmp     #.ok
                call    #\fs_find_next
        if_nc   jmp     #.next
.end
        _ret_   modz    _clr    wz
.ok
                rdlong  fs_tmp0, ptra[28/4]
                wrlong  fs_tmp0, ptrb[12/4]     ' fle size

                rdword  fs_tmp0, ptra[26/2]     ' lower cluster
                cmp     fs_type, #$0C   wz
        if_z    rdword  fs_tmp1, ptra[20/2]     ' upper cluster
        if_z    setword fs_tmp0, fs_tmp1, #1
                wrlong  fs_tmp0, ptrb[16/4]     ' first cluster

                wrlong  #0, ptrb[20/4]          ' clear pointers
                wrlong  #0, ptrb[24/4]          ' |
                wrlong  fs_tmp0, ptrb[28/4]     ' | current cluster

        _ret_   modz    _set    wz

'+-------[ Setup SD for file sector read/write ]-------------------------------+
'+ Call Format:                                                                +
'+      mov     fs_par0, #@file_descriptor                                     +
'+      mov     fs_par1, #sector                                               +
'+      call    #fs_setup_sector                                               +
'+-----------------------------------------------------------------------------+
fs_setup_sector
                mov     ptrb, fs_par0

                mov     fs_par2, fs_par1        ' get cluster index
                shr     fs_par2, fs_cluster_sh  ' |
                decod   fs_par3, fs_cluster_sh  ' cluster sector mask
                sub     fs_par3, #1             ' |
                and     fs_par3, fs_par1        ' get sector index

                rdlong  fs_tmp0, ptrb[24/4] ' current cluster index
                cmp     fs_par2, fs_tmp0    wz
        if_z    rdlong  fs_tmp0, ptrb[28/4] ' current cluster
        if_z    jmp     #.l1

                wrlong  fs_par2, ptrb[24/4] ' update cluster index

                rdlong  fs_tmp0, ptrb[16/4] ' first cluster
                cmp     fs_par2, #0     wz
        if_z    jmp     #.l1

.l2             mov     fs_tmp2, fs_tmp0
                cmp     fs_type, #$0C   wz
        if_z    shr     fs_tmp2, #7         ' FAT32 128 clusters per sector
        if_nz   shr     fs_tmp2, #8         ' FAT16 256 clusters per sector
                add     fs_tmp2, fs_fat
                cmp     sd_blocknr, fs_tmp2 wz
        if_nz   mov     sd_blocknr, fs_tmp2
        if_nz   mov     sd_data_p, ##@sd_data
        if_nz   call    #\sd_read

                cmp     fs_type, #$0C   wz
        if_z    and     fs_tmp0, #$7F       ' FAT32 128 clusters per sector
        if_z    shl     fs_tmp0, #2         ' |
        if_nz   and     fs_tmp0, #$FF       ' FAT16 256 clusters per sector
        if_nz   shl     fs_tmp0, #1         ' |
                add     fs_tmp0, ##@sd_data
        if_z    rdlong  fs_tmp0, fs_tmp0
        if_nz   rdword  fs_tmp0, fs_tmp0
                sub     fs_par2, #1     wz
        if_nz   jmp     #.l2

.l1
                wrlong  fs_tmp0, ptrb[28/4] ' update current cluster

                sub     fs_tmp0, #2
                shl     fs_tmp0, fs_cluster_sh
                add     fs_tmp0, fs_data

                add     fs_tmp0, fs_par3
        _ret_   mov     sd_blocknr, fs_tmp0

'+-------[ Read a file sector ]------------------------------------------------+
'+ Call Format:                                                                +
'+      mov     fs_par0, #@file_descriptor                                     +
'+      mov     fs_par1, #sector                                               +
'+      call    #\fs_setup_sector                                              +
'+      call    #\fs_read_sector                                               +
'+      ' read 512 bytes from #@sd_data                                        +
'+-----------------------------------------------------------------------------+
fs_read_sector
                mov     sd_data_p, ##@sd_data
                call    #\sd_read
                ret     wcz

'+-------[ Write a file sector ]-----------------------------------------------+
'+ Call Format:                                                                +
'+      mov     fs_par0, #@file_descriptor                                     +
'+      mov     fs_par1, #sector                                               +
'+      call    #\fs_setup_sector                                              +
'+      ' fill #@sd_data with 512 bytes                                        +
'+      call    #\fs_write_sector                                              +
'+-----------------------------------------------------------------------------+
fs_write_sector
                mov     sd_data_p, ##@sd_data
                call    #\sd_write
                ret     wcz

'+-------[ SD Card Initialisation ]--------------------------------------------+
'+ On Entry:                                                                   +
'+ Call Format:                                                                +
'+              CALL    #_SDcard_Init                   '                      +
'+ On Return:                                                                  +
'+      hub $20   = CSD[16] + CID[16]                   ' csd/cid data         +
'+      Returns  "Z" if ok, "NZ" if error                                      +
'+-----------------------------------------------------------------------------+

'+-----------------------------------------------------------------------------+
'+      SD/SDHC/sdxc SPI Initialisation                                        +
'+-----------------------------------------------------------------------------+
'+      Send >74 clocks with /CS=1 & DI=1 starting & ending with CLK=0         +
'+-----------------------------------------------------------------------------+
sd_init
                callpa  #SD_CS, #check_pullup       ' check for pull-up on sd_cs
        if_nc   jmp     #_fail                      '_pullup                 '

                drvh    #SD_CS                      ' cs=1 & output
                drvl    #SD_CK                      ' ck=0 & output
                drvh    #SD_DI                      ' di=1 & output

                mov     sd_ctr1, #(96 * 2)
.count          waitx   ##delay5us                  '\ 5us+5us (ie 100KHz)
                outnot  #SD_CK                      '| CLK=0-->1-->0
                djnz    sd_ctr1, #.count            '/
                waitx   ##delay5us                  '  CLK=0 (idle) & /CS=1
'+-----------------------------------------------------------------------------+
'+ Software Reset:                                                             +
'+      CMD0,  PAR=$0,        CRC=$95, REPLY=R1($01)                           +
'+-----------------------------------------------------------------------------+
.cmd0           getct   sd_ini_time                 '\ set timeout up to CMD9
                mov     sd_time_out, ##delay10ms    '/
                mov     sd_ctr1, #10                ' try a few times
.again0         mov     sd_cmd, #CMD0
                mov     sd_cmdpar, #0
                mov     sd_cmdcrc, #$95

                call    #_cmdR1                     ' /CS=0, send cmd, recv R1, /CS=1

                'debug(uhex_long(cmdout, cmdpar, cmdcrc, replyR1, replyR2))
        if_nc   mov     sd_time_out, ##delay1s      ' increase timeout to 1s
                                                    '\ $01(idle): SD/MMC, not fully validated
        if_nc   jmp     #.cmd8                      '/ $00(good): (dane card response)

                waitx   ##delay5us                  ' delay 5us
                djnz    sd_ctr1, #.again0           ' n: try again?
                jmp     #_fail                      '00                      '

' we know we now have an SD/MMC card but its not fully validated yet...
'+-----------------------------------------------------------------------------+
'+ Check Voltage:                                                              +
'+      CMD8,  PAR=$1AA,      CRC=$87, REPLY=R1($01)+R7($xx1AA) ($05=try SDV1) +
'+-----------------------------------------------------------------------------+
.cmd8           mov     sd_cmd, #CMD8
                mov     sd_cmdpar, #$1AA
                mov     sd_cmdcrc, #$87

                call    #_cmdR1R7                   ' /CS=0, send cmd, recv R1+R7, /CS=1
                'debug(uhex_long(cmdout, cmdpar, cmdcrc, replyR1, replyR2))

    if_c_or_z   jmp     #.illegal                   ' j if <> $01 (not idle)
.idle           and     sd_reply, ##$FFF            '\
                cmp     sd_reply, #$1AA     wz      '/ R7[11:0]=$1AA ?
                mov     sd_cmdpar2, ##$40000000     ' preset for SDV2
        if_ne   jmp     #_fail '98                  ' n: unknown R7
                jmp     #.cmd55                     ' y: CMD55+ACMD41($4000_0000)

.illegal        cmp     sd_replyR1, #$05    wz      ' $05(illegal cmd) ?
        if_ne   jmp     #_fail '08                  ' <>$01/$05 (not idle/illegal)
                mov     sd_cmdpar2, #0              ' try SDV1
                                                            ' CMD55+ACMD41($0) fall thru
'+-----------------------------------------------------------------------------+
'+ Prefix to ACMD41 & ACMD23:                                                  +
'+      CMD55, PAR=$0,        CRC=$xx, REPLY=R1($01)                           +
'+-----------------------------------------------------------------------------+
.cmd55          mov     sd_cmd, #CMD55              '
                mov     sd_cmdpar, #0               '

                call    #_cmdRZA41                  ' /CS=0, send cmd, recv R1, /CS=0(ena)
                'debug(uhex_long(cmdout, cmdpar, cmdcrc, replyR1, replyR2))

    if_c_or_z   jmp     #_fail '55                  ' <>$01 (not idle)
                                                            '              fall thru
'+-----------------------------------------------------------------------------+
'+ Check SDV1/SDV2:  (follows CMD55)                                           +
'+     ACMD41, PAR=$0,        CRC=$xx, REPLY=R1($00) SD-V1                     +
'+     ACMD41, PAR=$40000000, CRC=$xx, REPLY=R1($00) SD-V2                     +
'+-----------------------------------------------------------------------------+
.CommandA41     mov     sd_cmd, #ACMD41             '
                mov     sd_cmdpar, sd_cmdpar2       ' SDV1=0 / SDV2=$40000000

                call    #_cmdR1                     ' /CS=0, send cmd, recv R1, /CS=1
                'debug(uhex_long(cmdout, cmdpar, cmdcrc, replyR1, replyR2))

if_nc_and_nz    jmp     #.cmd55                     '  =$01(busy): CMD55+CMD41 again
        if_c    jmp     #_fail '41                  ' <>$00/$01: error

                cmp     sd_cmdpar2, #0      wz      ' SDV1 ?
        if_z    mov     sd_blocksh, #9              ' y: #1 SDV1(byte address)
        if_z    jmp     #.cmd16                     ' y: SDV1 does not use CMD58
                                                    ' SDV2         fall thru
'+-----------------------------------------------------------------------------+
'+ Check OCR CCS bit:                                                          +
'+      CMD58, PAR=$0,        CRC=$xx, REPLY=R1($00)+R3(b30=1)                 +
'+-----------------------------------------------------------------------------+
.cmd58          mov     sd_cmd, #CMD58              ' SDHC ?
                mov     sd_cmdpar, #0               '

                call    #_cmdR1R3                   ' /CS=0, send cmd, recv R1+R3, /CS=1
                'debug(uhex_long(cmdout, cmdpar, cmdcrc, replyR1, replyR2))

    if_c_or_nz  jmp     #_fail                      '58                      ' <>$00(good): error
                testbn  sd_reply, #30       wz      ' bit30=CCS=1? $40000000?
        if_z    mov     sd_blocksh, #9              ' n: #2 SDV2(byte address)
        if_nz   mov     sd_blocksh, #0              ' y: #3 SDHC/SDV2(block address)
''      if_nz   jmp     #.Command9x                   ' y: does not req cmd16?                        ?????????
                                                    ' SDV2(byte)   fall thru
'+-----------------------------------------------------------------------------+
'+ Force block size to 512 bytes:                                              +
'+      CMD16, PAR=$200,      CRC=$xx, REPLY=R1($00)                           +
'+-----------------------------------------------------------------------------+
.cmd16          mov     sd_cmd, #CMD16              ' force blocksize=512bytes
                mov     sd_cmdpar, ##512            ' 512 bytes

                call    #_cmdR1                     ' /CS=0, send cmd, recv R1, /CS=1
                'debug(uhex_long(cmdout, cmdpar, cmdcrc, replyR1, replyR2))

if_nc_and_nz    jmp     #.cmd16                     '  =$01(idle): again
if_c_or_nz      jmp     #_fail '16                  ' <>$00(good): error

'+-----------------------------------------------------------------------------+
'+ Read CSD register (16 bytes):                                               +
'+      CMD9,  PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
'+-----------------------------------------------------------------------------+
.cmd9           mov     sd_data_p, ##@sd_csd
                mov     sd_cmd, #CMD9               ' read CSD register
                call    #sd_read_reg                '
                'debug(uhex_byte_array(#@SD_csd, #16))

'+-----------------------------------------------------------------------------+
'+ Read CID register (16 bytes):                                               +
'+      CMD10, PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
'+-----------------------------------------------------------------------------+
.cmd10          mov     sd_data_p, ##@sd_cid
                mov     sd_cmd, #CMD10              ' read CID register
                call    #sd_read_reg                '
                'debug(uhex_byte_array(#@SD_cid, #16))

        _ret_   modz    _set                wz      ' "Z" = success


'+-----------------------------------------------------------------------------+
'+ Read Sector:                                                                +
'+-----------------------------------------------------------------------------+
sd_read
'+-----------------------------------------------------------------------------+
'+ Read Block/Sector:  (512 bytes)                                             +
'+      CMD17, PAR=blocknr,   CRC=$xx, REPLY=R1($??) +n*$FF +($FE+block+CRC16) +
'+-----------------------------------------------------------------------------+
.cmd17          mov     sd_bytescnt, ##512          ' read block (no. bytes)
                mov     sd_cmd, #CMD17              '
                mov     sd_cmdpar, sd_blocknr       '
                shl     sd_cmdpar, sd_blocksh       ' <<0 or <<9
                jmp     #sd_read_block              ' read 512 bytes
                                                    ' "Z" = success

'+-----------------------------------------------------------------------------+
'+ Write Sector:                                                               +
'+-----------------------------------------------------------------------------+
sd_write
'+-----------------------------------------------------------------------------+
'+ Write Block/Sector:  (512 bytes)                                            +
'+      CMD24, PAR=blocknr,   CRC=$xx, REPLY=R1($??) +n*$FF +($FE+block+CRC16) +
'+-----------------------------------------------------------------------------+
.cmd24          mov     sd_bytescnt, ##512          ' write block (no. bytes)
                mov     sd_cmd, #CMD24              '
                mov     sd_cmdpar, sd_blocknr       '
                shl     sd_cmdpar, sd_blocksh       ' <<0 or <<9
                jmp     #sd_write_block             ' write 512 bytes
                                                    ' "Z" = success

'+-----------------------------------------------------------------------------+
'+ Read Block/Sector:  (512 bytes)                                             +
'+      CMD9,  PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
'+      CMD10, PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
'+      CMD17, PAR=blocknr,   CRC=$xx, REPLY=R1($??) +n*$FF +($FE+block+CRC16) +
'+-----------------------------------------------------------------------------+
sd_read_reg     mov     sd_bytescnt, #16            ' CMD9,10: CSD,CID register
                mov     sd_cmdpar, #0               '        PAR=$0,      16 bytes
sd_read_block                                       ' CMD17: PAR=sector, 512 bytes
                getct   sd_ini_time                 '\ set timeout for cmd9,10,17
                mov     sd_time_out, ##delay1s      '/

                call    #_cmdRZtoken                ' /CS=0, send cmd, recv R1, /CS=0(ena)
                'debug(uhex_long(cmdout, cmdpar, cmdcrc, replyR1, replyR2))
        if_nz   jmp     #_fail '17                  ' <>$00(good): error

                call    #_getreply                  ' n*$FF+$FE
                cmp     sd_reply, #$FE         wz   ' $FE=valid Data Token
        if_nz   jmp     #_fail '97                  '

.readbyte       call    #_recvbyte                  ' read data byte
                wrbyte  sd_reply, sd_data_p         ' save byte
                add     sd_data_p, #1               ' bufaddr++
                djnz    sd_bytescnt, #.readbyte     ' byte--
                call    #_recvbyte                  ' read CRC16 1/2
                call    #_recvbyte                  ' read CRC16 2/2
' NOTE: CRC16 not checked - do we want to do this?
                outl    #SD_CK                      ' CLK=0 (idle)          already=0
                call    #_recvbyte                  ' SEND 8 CLOCKS BEFORE DISABLING CS
                outh    #SD_CS                      ' /CS=1 (disable)
        _ret_   modz    _set                wz      ' "Z" = success

'+-----------------------------------------------------------------------------+
'+ Write Block/Sector:  (512 bytes)                                            +
'+      CMD24, PAR=blocknr                                                     +
'+-----------------------------------------------------------------------------+
sd_write_block                                      ' CMD24: PAR=sector, 512 bytes
                getct   sd_ini_time                 '\ set timeout for cmd24
                mov     sd_time_out, ##delay1s      '/

                call    #_cmdRZtoken                ' /CS=0, send cmd, recv R1, /CS=0(ena)
        if_nz   jmp     #_fail '24                  ' <>$00(good): error

                mov     sd_dataout, #$FE            ' start block token
                call    #_sendbyte                  ' write data byte

.writebyte      rdbyte  sd_dataout, sd_data_p       ' load byte
                call    #_sendbyte                  ' write data byte
                add     sd_data_p, #1               ' bufaddr++
                djnz    sd_bytescnt, #.writebyte    ' byte--
' NOTE: CRC16 is ignored in SPI mode
                call    #_sendFF                    ' CRC16 byte 1/2
                call    #_sendFF                    ' CRC16 byte 2/2
                call    #_getreply                  '
                and     sd_reply, #$1F
                cmp     sd_reply, #$5          wz
        if_nz   jmp     #_fail
                waitx   ##delay20ms                 ' why is this necessary???
.waitbusy
                call    #_recvbyte                  ' get a byte
                cmp     sd_reply, #$FF         wz   ' reply=$FF=busy ?
        if_nz   jmp     #.writedone                 ' n: done
                getct   sd_replyR1                  '\ y: timeout ?
                sub     sd_replyR1, sd_ini_time     '|
                cmp     sd_replyR1, sd_time_out wc  '| c if < timeout
        if_c    jmp     #.waitbusy                  '| n: try again
                jmp     #_fail '90                  '/ y: timed out
.writedone
        _ret_   modz    _set                        ' "Z" = success

'+-----------------------------------------------------------------------------+
'+      SEND: CMDx, PARx, CRCx, GET REPLY                                      +
'+-----------------------------------------------------------------------------+
_cmdRZA41                                           ' cmd55:       r1 response
_cmdRZtoken                                         ' cmd9,10,17,24: r1+$fe response
                mov     sd_cmdtype, #1              ' returns w /CS=0(ena)
                jmp     #_cmdxx                     '
_cmdR1R3                                            ' cmd58:    r1+r3 response
_cmdR1R7                                            ' cmd8:     r1+r7 response
_cmdR1                                              ' cmd0,a41,16: r1 response
                mov     sd_cmdtype, #0              ' returns w /CS=1(disabled)
_cmdxx                                              '
                outl    #SD_CS                      ' /CS=0 (enable)

                call    #_sendFF                    ' send $FF byte first
                mov     sd_dataout, sd_cmd          ' CMD
                call    #_sendbyte                  ' send cmd byte
                mov     sd_dataout, sd_cmdpar       ' Parameter
                call    #_sendlong                  ' send 4 bytes (MSB first)
                mov     sd_dataout, sd_cmdcrc       ' CRC
                call    #_sendbyte                  ' send crc byte

                call    #_getreply                  ' recv R1/R1+R3/R1+R7/RZ..+Token

                outl    #SD_CK                      ' CLK=0 (idle)           already=0

                skip    sd_cmdtype                  '\ skips next instr if #1
                outh    #SD_CS                      '| /CS=1(disable) if reqd
                ret                                 '/ else /CS=0 cmdRZA41/cmdRZtoken

'+-----------------------------------------------------------------------------+
'+      READ REPLY: R1/R1+R3/R1+R7/R1+token                                    +
'+-----------------------------------------------------------------------------+
_getreply       call    #_recvbyte                  ' recv R1 byte
                cmp     sd_reply, #$FF      wz      ' reply=$ff=busy ?
        if_nz   jmp     #.doneR1                    ' n:

' timeout set in CMD0(for CMD0,8,55,A41,58,16) and CMD9,10,17(readblock)
                getct   sd_replyR1                  '\ timeout ?
                sub     sd_replyR1, sd_ini_time     '|
                cmp     sd_replyR1, sd_time_out wc  '| c if < timeout
        if_c    jmp     #_getreply                  '| n: try again
                jmp     #_fail '90                  '/ timeout:

.doneR1         mov     sd_replyR1, sd_reply        ' save R1/Token reply

                cmp     sd_cmd, #CMD8    wz
        if_nz   cmp     sd_cmd, #CMD58   wz
        if_nz   jmp     #.end                       ' ret if not CMD8/CMD58

                call    #_recvlong                  ' R7=CMD8=volts/R3=CMD58=OCR
.end                                                '\ returns with...
                '| nc+z  replyR1=$00(success)
                test    sd_replyR1, #1      wz      '| nc+nz replyr1=$01(idle)
        _ret_   cmpr    sd_replyR1, #$01    wc      '/  c    replyr1>$01(error)

'+-----------------------------------------------------------------------------+
'+      SD SPI Send/Recv Routines... (write/read byte/long simultaneously)     +
'+              /CS=0 & CLK=0 on both entry and exit                           +
'+-----------------------------------------------------------------------------+
_recvlong       neg     sd_dataout, #1              ' call here to Recv a Long (+send 1's)
_sendlong       mov     sd_bitscnt, #32             ' call here to Send a Long (long=32bits)
                jmp     #_sendrecv                  '
_sendFF                                             ' call here to send $ff byte
_recvbyte       neg     sd_dataout, #1              ' call here to Recv a Byte (+send 1's)
_sendbyte       rol     sd_dataout, #24             ' call here to Send a Byte (msbit first)
                mov     sd_bitscnt, #8              '                          (byte=8bits)
_sendrecv       mov     sd_reply, #0                ' clear reply
' 8+15 low/high clk cycles (8.7MHz@200MHz, 1.3MHz@30MHz)
.nextbit        rol     sd_dataout, #1      wc      ' \ prepare output bit (di=0/1)..
                outl    #SD_CK                      ' | CLK=0  (already 0 first time)
                outc    #SD_DI                      ' / write output bit: output on CLK falling edge
                waitx   #2                          ' |   setup time to be safe
                outh    #SD_CK                      ' \ CLK=1
                waitx   #3                          ' |   setup time to be safe
                testp   #SD_DO              wc      ' | read input bit:   sample on clk rising edge
                rcl     sd_reply, #1                ' / accum DO input bits
                djnz    sd_bitscnt, #.nextbit       '   8/32 bits?
        _ret_   outl    #SD_CK                      ' CLK=0 on exit

_fail           outh    #SD_CS                      ' /CS=1 (disable)
        _ret_   modcz   _set, _clr          wcz     ' c & nz = fail

'
' Check pin pull-up
'
check_pullup    drvl    pa                          'drive pin low
check_pulldn    waitx   ##300 * 1                   'wait >1us
                fltl    pa                          'float pin
                waitx   ##300 * 5                   'wait >5us
        _ret_   testp   pa                  wc      'sample pin

nec765_lut_end

CON ' SD Card Driver Constants

    delay1s = _CLKFREQ                                      ' 1s  (xtal * pll)
    delay10ms = _CLKFREQ / 100                              ' 10ms
    delay20ms = _CLKFREQ / 50                               ' 20ms
    delay1ms = _CLKFREQ / 1_000                             ' 1ms
    delay5us = _CLKFREQ / 200_000                           ' 5us

'------------------------------------------------------------------------------------------------
' SD Commands & Responses...
'------------------------------------------------------------------------------------------------
'   Command             Argument        Response/Data    Description
    CMD0   =  0 + $40 ' 0               R1       -       GO_IDLE_STATE            *Reqs valid CRC
'   CMD1   =  1 + $40 ' 0               R1       -       SEND_OP_COND
    ACMD41 = 41 + $40 ' $4000_0000      R1       -       APP_SEND_OP_COND         *Reqs CMD55 first
    CMD8   =  8 + $40 ' 0               R1+R7    -       SEND_IF_COND             *Reqs valid CRC
    CMD9   =  9 + $40 ' 0               R1       Y       SEND_CSD
    CMD10  = 10 + $40 ' 0               R1       Y       SEND_CID
'   CMD12  = 12 + $40 ' 0               R2       -       STOP_TRANSMISSION
    CMD13  = 13 + $40 ' 0               R2       -       SEND_STATUS
    CMD16  = 16 + $40 ' BlkLen[31:0]    R1       -       SET_BLOCKLEN
    CMD17  = 17 + $40 ' Addr[31:0]      R1       Y       READ_SINGLE_BLOCK
'   CMD18  = 18 + $40 ' Addr[31:0]      R1       Y       READ_MULTIPLE_BLOCK
'   CMD23  = 23 + $40 ' NoBlks[15:0]    R1       -       SET_BLOCK_COUNT
'   ACMD23 = 23 + $40 ' NoBlks[22:0]    R1       -       SET_WR_BLOCK_ERASE_COUNT *Reqs CMD55 first
    CMD24  = 24 + $40 ' Addr[31:0]      R1       Y*      WRITE_BLOCK
'   CMD25  = 25 + $40 ' Addr[31:0]      R1       Y*      WRITE_MULTIPLE_BLOCK
    CMD55  = 55 + $40 ' 0               R1       -       APP_CMD                  *Prefix for ACMD41/ACMD23
    CMD58  = 58 + $40 ' 0               R1+R3    -       READ_OCR

' R1 response:  $FF = busy/wait (0-8 bytes?)
'               b7: 0 (msb first)
'               b6: Parameter Error
'               b5: Address Error
'               b4: Erase Sequence Error
'               b3: Command CRC Error
'               b2: Illegal Command
'               b1: Erase Reset
'               b0: In Idle State
' R1b response: ???
' R3 response:  R1 + OCR(32b)
' R7 response:  R1($01) + 32b(b11..b0 = $1AA = SDC V2 2V7-3V6, else reject)
'
' DataPacket:   DataToken(1byte) + DataBlock(1-2048bytes) + CRC(2bytes)
'   DataToken:  $FE = CMD17/18/24 (read'1'block/read'n'blocks/write'1'block)
'               $FC = CMD25 (write'n'blocks)
'               $FD = CMD25 StopToken  (Single byte packet without data or CRC)
' ErrorToken:   Single Byte Reply
'               b7-b5: 000
'               b4: Card Locked
'               b3: Out of Range
'               b2: Card ECC failed
'               b1: CC Error
'               b0: Error
' DataResponse:
'               b7-b4: xxx0
'               $x5: Data Accepted
'               $xB: Data Rejected - CRC Error
'               $xD: Data Rejected - Write Error

AM_READ_ONLY = $01  ' Read only
AM_HIDDEN    = $02  ' Hidden
AM_SYSTEM    = $04  ' System
AM_VOLUME    = $08  ' Volume ID
AM_DIR       = $10  ' Directory
AM_ARCHIVE   = $20  ' Archive
AM_LFN       = AM_READ_ONLY|AM_HIDDEN|AM_SYSTEM|AM_VOLUME
AM_LFN_MASK  = AM_READ_ONLY|AM_HIDDEN|AM_SYSTEM|AM_VOLUME|AM_DIR|AM_ARCHIVE

DAT             ' NEC765 I/O HUB code
                orgh

sd_csd          byte    $00[16]
sd_cid          byte    $00[16]
sd_data         byte    $00[512]

fdc_status_rd
                rdbyte  i_tmpb, #@fdc_msr
                ret     wcz

fdc_data_rd
                mov     i_tmpb, #$00
                rdbyte  i_temp0, #@fdc_fifo_tail
                rdbyte  i_temp1, #@fdc_fifo_head
                cmp     i_temp0, i_temp1    wcz
        if_e    ret     wcz
                add     i_temp0, #@fdc_fifo
                rdbyte  i_tmpb, i_temp0
                sub     i_temp0, #@fdc_fifo
                incmod  i_temp0, #16 - 1
                wrbyte  i_temp0, #@fdc_fifo_tail
                ret     wcz

fdc_dor_wr
                wrbyte  i_tmpb, #@fdc_dor
                ret     wcz

fdc_data_wr
                rdbyte  i_temp0, #@fdc_msr
                testb   i_temp0, #MSR_BUSY      wz
        if_x1   ret     wcz
                rdbyte  i_temp0, #@fdc_cmd_len
                cmp     i_temp0, #9             wcz
        if_ae   ret     wcz
                add     i_temp0, #@fdc_cmd
                wrbyte  i_tmpb, i_temp0
                sub     i_temp0, #@fdc_cmd - 1
                wrbyte  i_temp0, #@fdc_cmd_len
                ret     wcz

CON ' NEC765 Constants

    DOR_ENABLE       = 2
    DOR_INT_ENABLE   = 3
    DOR_DRIVE0_MOTOR = 4
    DOR_DRIVE1_MOTOR = 5
    DOR_DRIVE2_MOTOR = 6
    DOR_DRIVE3_MOTOR = 7

    STATUS0_INT_NORMAL        = $00
    STATUS0_INT_ABNORMAL_POLL = $C0

    STATUS0_HD   = encod($00_00_00_04)
    STATUS0_NR   = encod($00_00_00_08)
    STATUS0_UC   = encod($00_00_00_10)
    STATUS0_SE   = encod($00_00_00_20)
    STATUS0_INT_ABNORMAL = encod($00_00_00_40)
    STATUS0_INT_INVALID  = encod($00_00_00_80)

    STATUS1_NID  = encod($00_00_01_00)
    STATUS1_NW   = encod($00_00_02_00)
    STATUS1_NDAT = encod($00_00_04_00)
    STATUS1_TO   = encod($00_00_10_00)
    STATUS1_DE   = encod($00_00_20_00)
    STATUS1_EN   = encod($00_00_80_00)

    STATUS2_NDAM = encod($00_01_00_00)
    STATUS2_BCYL = encod($00_02_00_00)
    STATUS2_SERR = encod($00_04_00_00)
    STATUS2_SEQ  = encod($00_08_00_00)
    STATUS2_WCYL = encod($00_10_00_00)
    STATUS2_CRCE = encod($00_20_00_00)
    STATUS2_DADM = encod($00_40_00_00)

    STATUS3_HDDR = encod($04_00_00_00)
    STATUS3_DSDR = encod($08_00_00_00)
    STATUS3_TRK0 = encod($10_00_00_00)
    STATUS3_RDY  = encod($20_00_00_00)
    STATUS3_WPDR = encod($40_00_00_00)
    STATUS3_ESIG = encod($80_00_00_00)

    MSR_DRIVE1_POS_MODE = 0
    MSR_DRIVE2_POS_MODE = 1
    MSR_DRIVE3_POS_MODE = 2
    MSR_DRIVE4_POS_MODE = 3
    MSR_BUSY    = 4
    MSR_NDMA    = 5
    MSR_DATAIO  = 6
    MSR_DATAREG = 7

    CMD_READ_TRACK   = $02
    CMD_SPECIFY      = $03
    CMD_CHECK_STAT   = $04
    CMD_WRITE_SECT   = $05
    CMD_READ_SECT    = $06
    CMD_CALIBRATE    = $07
    CMD_CHECK_INT    = $08
    CMD_WRITE_DEL_S  = $09
    CMD_READ_ID_S    = $0A
    CMD_READ_DEL_S   = $0C
    CMD_FORMAT_TRACK = $0D
    CMD_SEEK         = $0F

DAT             ' PPI 8255A
                orgh

ppi_60_rd
                testb   i_ppi, #PPI_PA_INPUT        wz  ' PA input ?
        if_x0   getbyte i_tmpb, i_ppi, #PPI_PA_BYTE     ' no, return the out state
        if_x1   rdbyte  i_tmpb, #@kbd_data
                ret     wcz

ppi_61_wr
                testb   i_ppi, #(PPI_PB_BYTE * 8) + 6 wc
                testb   i_tmpb, #6                  wz
        if_01   bitnz   i_sys_flags, #I_SYS_KB_RESET

                testb   i_ppi, #(PPI_PB_BYTE * 8) + 7 wc
                testb   i_tmpb, #7                  wz
                setbyte i_ppi, i_tmpb, #PPI_PB_BYTE
        if_10   jmp     #.reset

                testb   i_tmpb, #(PPI_PB_BYTE * 8) + 7 wz
        if_x1   wrbyte  #$00, #@kbd_data
                ret     wcz

.reset
                bitl    i_sys_flags, #I_SYS_KB_RESET    wcz
        if_x0   wrbyte  #$00, #@kbd_data
        if_x1   wrbyte  #$AA, #@kbd_data
        if_x1   bith    i_pic_irr, #1       ' signal irq
                ret     wcz

ppi_62_rd
                testb   i_ppi, #(PPI_PB_BYTE * 8) + 3  wz
        if_x0   mov     i_tmpb, #%00001101 ' Low switches
                '                     ||||
                '                     |||+-- Loop on POST
                '                     ||+--- 1=Co-Processor installed
                '                     ++---- Planar RAM size (00=64K, 01=128K, 10=192K, 11=256K)
        if_x1   mov     i_tmpb, #%00000110 ' High switches
                '                     ||||
                '                     ||++-- Display (10=CGA)
                '                     ++---- Num. Floppy drives (00=1, 01=2, 10=3, 11=4)
                ret     wcz

CON ' PPI 8255A constants

    PPI_PA_BYTE  = 0
    PPI_PB_BYTE  = 1
    PPI_PC_BYTE  = 2
    PPI_CTL_BYTE = 3

    PPI_PA_INPUT  = (PPI_CTL_BYTE * 8) + 4
    PPI_PCU_INPUT = (PPI_CTL_BYTE * 8) + 3
    PPI_PB_INPUT  = (PPI_CTL_BYTE * 8) + 1
    PPI_PCL_INPUT = (PPI_CTL_BYTE * 8) + 0

DAT             ' PIC 8259A
                orgh

pic_20_wr
                testb   i_tmpb, #4      wc
                testb   i_tmpb, #3      wz
        if_00   jmp     #.ocw2
        if_01   setbyte i_pic_ocw, i_tmpb, #PIC_OCW3_BYTE ' OCW3
        if_01   ret
                mov     i_pic_icw, #0     ' ICW1
                mov     i_pic_ocw, #0
                mov     i_pic_irr, #0
                setbyte i_pic_ocw, #%00001010, #PIC_OCW3_BYTE
                setnib  i_pic_irr, #7, #PIC_IR_NIB
                setbyte i_pic_icw, i_tmpb, #0
                ret     wcz

.ocw2
                testb   i_tmpb, #5      wz  ' EOI
        if_x1   getnib  i_temp0, i_pic_irr, #PIC_IR_NIB
        if_x1   add     i_temp0, #PIC_ISR_BYTE * 8
        if_x1   bitl    i_pic_irr, i_temp0
        if_x1   bitl    i_pic_irr, #PIC_IS_BIT
        if_x1   setnib  i_temp0, #7, #PIC_IR_NIB
                ret     wcz

pic_20_rd
                mov     i_tmpb, #0

                bitl    i_pic_ocw, #PIC_OCW3_POLL_BIT wcz
                testb   i_pic_ocw, #PIC_OCW3_RR_BIT   wz
        if_11   jmp     #.poll

                testb   i_pic_ocw, #PIC_OCW3_RR_BIT   wc
                testb   i_pic_ocw, #PIC_OCW3_RIS_BIT  wz
        if_10   getbyte i_tmpb, i_pic_irr, #PIC_IRR_BYTE
        if_11   getbyte i_tmpb, i_pic_irr, #PIC_ISR_BYTE
                ret     wcz

.poll
                call    #pic_intack
                getbyte i_tmpb, i_pic_irr, #PIC_POLL_BYTE
                ret     wcz

pic_21_wr
                bith    i_pic_ocw, #29    wcz
        if_0x   setbyte i_pic_icw, i_tmpb, #1 ' ICW2
        if_0x   ret     wcz

                bith    i_pic_ocw, #30    wcz
                testb   i_pic_icw, #1     wz
        if_00   setbyte i_pic_icw, i_tmpb, #2 ' ICW3
        if_01   setbyte i_pic_icw, i_tmpb, #3 ' ICW4
        if_01   bith    i_pic_ocw, #31
        if_0x   ret     wcz

                bith    i_pic_ocw, #31    wcz
        if_0x   setbyte i_pic_icw, i_tmpb, #3 ' ICW4
        if_0x   ret     wcz

                setbyte i_pic_ocw, i_tmpb, #0 ' OCW1 (IMR)
                ret     wcz

pic_21_rd
                getbyte i_tmpb, i_pic_ocw, #PIC_OCW1_BYTE ' OCW1 (IMR)
                ret     wcz

CON ' PIC 8259A Constants

    ' pic_icw
    PIC_ICW1_BYTE = 0
    PIC_ICW2_BYTE = 1
    PIC_ICW3_BYTE = 2
    PIC_ICW4_BYTE = 3

    ' pic_ocw
    PIC_OCW1_BYTE = 0
    PIC_OCW2_BYTE = 1
    PIC_OCW3_BYTE = 2

    PIC_OCW3_POLL_BIT = (PIC_OCW3_BYTE * 8) + 2
    PIC_OCW3_RR_BIT   = (PIC_OCW3_BYTE * 8) + 1
    PIC_OCW3_RIS_BIT  = (PIC_OCW3_BYTE * 8) + 0

    PIC_ICW2_BIT  = 29
    PIC_ICW3_BIT  = 30
    PIC_ICW4_BIT  = 31

    ' pic_irq
    PIC_IRR_BYTE  = 0
    PIC_ISR_BYTE  = 1
    PIC_POLL_BYTE = 3
    PIC_IS_BIT    = 31
    PIC_IR_NIB    = 6

DAT             ' DMA 8237A
                orgh

dma_addr_rd
                bitnot  i_sys_flags, #I_SYS_DMA_HL  wcz

                mov     i_temp0, i_ea
                rcl     i_temp0, #1
                add     i_temp0, #@dma
                rdbyte  i_tmpb, i_temp0

                ret     wcz

dma_wr
                cmp     i_ea, #$0C      wcz ' clear byte pointer flip-flop
        if_e    bitl    i_sys_flags, #I_SYS_DMA_HL
        if_e    ret     wcz

.lock           locktry #I_DMA_LOCK  wc      ' acquire dma lock
        if_nc   jmp     #.lock
                rdlong  i_dma_ctl, #@dma_ctl

                cmp     i_ea, #$08      wcz ' write command register
        if_e    setbyte i_dma_ctl, i_tmpb, #1
                cmp     i_ea, #$09      wcz ' write request register
        if_e    call    #\dma_request_wr
                cmp     i_ea, #$0A      wcz ' write single mask register
        if_e    call    #\dma_mask_wr
                cmp     i_ea, #$0B      wcz ' write mode register
        if_e    call    #\dma_mode_wr
                cmp     i_ea, #$0D      wcz ' master clear
        if_e    call    #\dma_clear_wr
                cmp     i_ea, #$0E      wcz ' clear mask register
        if_e    setnib  i_dma_ctl, #0, #4
                cmp     i_ea, #$0F      wcz ' write all mask register
        if_e    setnib  i_dma_ctl, i_tmpb, #4

                wrlong  i_dma_ctl, #@dma_ctl
                lockrel #I_DMA_LOCK ' release lock
                ret     wcz

dma_addr_wr
                bitnot  i_sys_flags, #I_SYS_DMA_HL  wcz

                mov     i_temp0, i_ea
                rcl     i_temp0, #1
                add     i_temp0, #@dma
                wrbyte  i_tmpb, i_temp0

                ret     wcz

dma_request_wr
                testb   i_tmpb, #1      wc
                testb   i_tmpb, #0      wz

        if_00   mov     i_temp0, #%0001_0000
        if_00   bitl    i_dma_ctl, #0

        if_01   mov     i_temp0, #%0010_0000
        if_01   bitl    i_dma_ctl, #1

        if_10   mov     i_temp0, #%0100_0000
        if_10   bitl    i_dma_ctl, #2

        if_11   mov     i_temp0, #%1000_0000
        if_11   bitl    i_dma_ctl, #3

                testb   i_tmpb, #2      wz
        _ret_   muxz    i_dma_ctl, i_temp0

dma_mask_wr
                testb   i_tmpb, #1      wc
                testb   i_tmpb, #0      wz
        if_00   mov     i_temp0, #%0001
        if_01   mov     i_temp0, #%0010
        if_10   mov     i_temp0, #%0100
        if_11   mov     i_temp0, #%1000
                shl     i_temp0, #16
                testb   i_tmpb, #2      wz
        _ret_   muxz    i_dma_ctl, i_temp0

dma_mode_wr
                testb   i_tmpb, #1      wc
                testb   i_tmpb, #0      wz
                rdlong  i_temp0, #@dma_mode
        if_00   setbyte i_temp0, i_tmpb, #0
        if_01   setbyte i_temp0, i_tmpb, #1
        if_10   setbyte i_temp0, i_tmpb, #2
        if_11   setbyte i_temp0, i_tmpb, #3
        _ret_   wrlong  i_temp0, #@dma_mode

dma_clear_wr
                bitl    i_sys_flags, #I_SYS_DMA_HL  wcz
                mov     i_dma_ctl, ##%0_00000000000_1111_00000100_00000000
                wrlong  #0, #@dma
                wrlong  #0, #@dma + 4
                wrlong  #0, #@dma + 8
                wrlong  #0, #@dma + 12
        _ret_   wrlong  #0, #@dma_page

DAT             ' ROM and RAM
                orgh

cga_charrom     file    "CGA.F08"

rom_F6000       file    "BASIC110.ROM"
{rom_FE000}     file    "XTBIOS-REV1.ROM"

fs_file0        byte    "PCDOS3_AIMG", $00
          {12}  long    0               ' file size
          {16}  long    $00000000       ' first cluster
          {20}  long    0               ' file position
          {24}  long    0               ' current cluster (index)
          {28}  long    $00000000       ' current cluster

fs_file1        byte    "PCDOS3_BIMG", $00
          {12}  long    0               ' file size
          {16}  long    $00000000       ' first cluster
          {20}  long    0               ' file position
          {24}  long    0               ' current cluster (index)
          {28}  long    $00000000       ' current cluster

                fit     $8_0000 - RAM_SIZE - CGA_VRAM

ram_00000
                ' space used as
CON

                RAM_SIZE = $4_0000  ' 256K RAM
                CGA_VRAM = $0_4000  ' 16K CGA video ram
