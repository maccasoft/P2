{
    INTEL 8086 XT Emulator
    Copyright (c) 2022 by Marco Maccaferri <macca@maccasoft.com>

    Memory Map:

        00000-3FFFF ram (256k)
        B8000-BBFFF cga (16k)
        FE000-FFFFF rom (8k)
}
CON

    _CLKFREQ = 320_000_000

    VGA_PIN = 48
    USB_BASE_PIN = 40

DAT             ' Startup
                org     $000

                asmclk

                rep     @.lockmadness,#16   ' allocate all locks, to be safe...
                locknew pb
                nop
.lockmadness

                coginit #3, ##@video_driver
                coginit #2, ##@pit_cog
                coginit #1, ##@usb_host_start
                waitx   ##_CLKFREQ * 1
                coginit #0, ##@i8086
                jmp     #$

                orgh

                ' DMA
dma             long    $0000_0000[4] ' DMA Address / Counter registers
                '        |||| ||||
                '        |||| ++++------- Address
                '        ++++------------ Count

dma_ctl         long    %0_00000000000_1111_00000100_00000000
                '        |             |||| |||||||| ||||||||
                '        |             |||| |||||||| ||||++++-- Channel 3..0 has reached TC
                '        |             |||| |||||||| ++++------ Channel 3..0 request
                '        |             |||| ++++++++----------- Command register
                '        |             ++++-------------------- Mask bits
                '        +------------------------------------- Byte flip-flop
dma_mode        long    %00000000_00000000_00000000_00000000 ' DMA mode registers

                ' CGA I/O registers
cga_io_03D4     byte    $00         ' MC6845 Address
cga_io_03D8     byte    %00000000   ' Mode Select Register (BIOS keeps current value at 40:0065)
                                    '   0: width (text modes): 0=40 clms; 1=80 clms
                                    '   1: 1=enable graphics modes; 0=text modes
                                    '   2: 1=disable color burst on composite monitor
                                    '   3: 1=enable video signal; 0=disable (all black)
                                    '   4: dot resolutn: 0=320 2-bit dots; 1=640 1-bit dots
                                    '   5: enable blink: 1=text attribute bit 7 blinks fgnd
                                    '                    0=attr bit 7 is bkgd intensity
cga_io_03D9     byte    %00000000   ' Write: Color Select Register
                                    '   0-3: color. Text modes: IRGB of border
                                    '               Graphics modes: IRGB of background
                                    '   4: intensity. Text: bkgd intensity
                                    '                 Mid-res graphics: pixel intensity
                                    '   5: blue. Select grafx palette 0 or 1 (1 adds blue)
cga_io_03DA     byte    %00000000   ' Read: Status Register
                                    '   0: retrace.  1=display in vert or horiz retrace.
                                    '   1: 1=light pen trigger is triggered; 0=armed
                                    '   2: 1=light pen switch is open; 0=closed
                                    '   3: 1=vertical sync pulse is occurring.  Display is
                                    '                 in vertical retrace--access won't cause "snow"

                ' MC6845 registers
cga_io_mc6845                   '         Unit        R/W         Name                  Size    40x25   80x25   Graphics
                byte    $00     ' R0      Char        Write       Hor. Total            8       38      71      38
                byte    $00     ' R1      Char        Write       Hor. Disp.            8       28      50      28
                byte    $00     ' R2      Char        Write       Hor. Sync Pos.        8       2D      5A      2D
                byte    $00     ' R3      Char        Write       Hor. Sync Width       4       0A      0A      0A
                byte    $00     ' R4      Char Row    Write       Vert. Total           7       1F      1F      7F
                byte    $00     ' R5      Scan Line   Write       Vert. Total Adj.      5       06      06      06
                byte    $00     ' R6      Char Row    Write       Vert. Disp.           7       19      19      64
                byte    $00     ' R7      Char Row    Write       Vert. Sync Pos.       7       1C      1C      70
                byte    $00     ' R8                  Write       Interlace Mode        2       02      02      02
                byte    $00     ' R9      Scan Line   Write       Max Scan Line Addr.   5       07      07      01
                byte    $00     ' R10     Scan Line   Write       Cursor Start          7 (5)   06      06      06
                byte    $07     ' R11     Scan Line   Write       Cursor End            5       07      07      07
                byte    $00     ' R12                 Write       Start Add. (H)        6       00      00      00
                byte    $00     ' R13                 Write       Start Add. (L)        8       00      00      00
                byte    $00     ' R14                 Read/Write  Cursor Add. (H)       6       XX      XX      XX
                byte    $00     ' R15                 Read/Write  Cursor Add. (L)       8       XX      XX      XX
                byte    $00     ' R16                 Read        Light Pen (H)         6       XX      XX      XX
                byte    $00     ' R17                 Read        Light Pen (L)         8       XX      XX      XX

                ' Keyboard
kbd_data        byte    $00

irq             byte    %00000000
                '         | || ||
                '         | || |+-- 0: Timer0
                '         | || +--- 1: Keyboard
                '         | |+----- 3: Serial Interface 2
                '         | +------ 4: Serial Interface 1
                '         +-------- 6: Floppy Disk Controller

                alignl

tmr0            word    %01000100_00110000
                '        |||  ||| ||||||||
                '        |||  ||| ++++++++------------------ 7..0: CONTROL REGISTER
                '        |||  ||+---------------------------    8: 0=L / 1=H BYTE FLAG
                '        |||  |+----------------------------    9: 1=RELOAD COUNTER
                '        |||  +-----------------------------   10: 1=NULL COUNTER
                '        ||+--------------------------------   13: 1=LATCH
                '        |+---------------------------------   14: GATE
                '        +----------------------------------   15: OUT
tmr0_cnt        word    $0000
tmr0_latch      word    $0000
tmr0_reload     word    $0000

tmr1            word    %01000100_00110000
                '        |||  ||| ||||||||
                '        |||  ||| ++++++++------------------ 7..0: CONTROL REGISTER
                '        |||  ||+---------------------------    8: 0=L / 1=H BYTE FLAG
                '        |||  |+----------------------------    9: 1=RELOAD COUNTER
                '        |||  +-----------------------------   10: 1=NULL COUNTER
                '        ||+--------------------------------   13: 1=LATCH
                '        |+---------------------------------   14: GATE
                '        +----------------------------------   15: OUT
tmr1_cnt        word    $0000
tmr1_latch      word    $0000
tmr1_reload     word    $0000

tmr2            word    %01000100_00110000
                '        |||  ||| ||||||||
                '        |||  ||| ++++++++------------------ 7..0: CONTROL REGISTER
                '        |||  ||+---------------------------    8: 0=L / 1=H BYTE FLAG
                '        |||  |+----------------------------    9: 1=RELOAD COUNTER
                '        |||  +-----------------------------   10: 1=NULL COUNTER
                '        ||+--------------------------------   13: 1=LATCH
                '        |+---------------------------------   14: GATE
                '        +----------------------------------   15: OUT
tmr2_cnt        word    $0000
tmr2_latch      word    $0000
tmr2_reload     word    $0000

DAT             ' USB Host driver
                org     $000

usb_host_start
                mov     hcog_base_addr, ptrb

                add     ptrb, ##@hlut_start - @usb_host_start
                setq2   #512-1
                rdlong  0, ptrb

                jmp     #\usb_host_init

'------------------------------------------------------------------------------
' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
' special because the receiving function must not respond with either STALL or
' NAK, and must accept the DATAx packet that follows the SETUP token. If a
' non-control endpoint receives a SETUP token, or the function receives a
' corrupt packet, it must ignore the transaction
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data struct.
' On exit:
'   retval - PID_ACK on success, otherwise error code.
'------------------------------------------------------------------------------
txn_setup
                setbyte ep_addr_pid, #PID_SETUP, #0
                mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
                bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
                mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
                mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
.setup
                call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
                cmp     retval, #PID_ACK        wz
        if_z    ret
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    ret
                mov     ptra, pa                        ' Restore SETUP's DATAx pointer
                jmp     #.setup
' */
' /* txn_in
'------------------------------------------------------------------------------
' IN/INTERRUPT transaction.
' Possible function response: STALL or NAK handshake, or DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
' On exit:
'------------------------------------------------------------------------------
txn_in
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                setbyte ep_addr_pid, #PID_IN, #0
                call    #utx_token                      ' Put IN request on the bus

                ' Fall through to urx_packet

'------------------------------------------------------------------------------
' Wait for a packet from a device/function. As host, the only two packet types
' received are handshakes and IN DATAx.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'     returned.
'------------------------------------------------------------------------------
urx_packet
                rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
                testb   urx, #SOPB              wc
        if_c    jmp     #urx_packet
                getct   hct2
                addct2  hct2, tat_wait                  ' Start the response turn-around timer
                bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
                mov     newb_flg, #0                    ' Initialize for multi-byte read
.wait_sop
                rdpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #.get_pid
                jnct2   #.wait_sop
        _ret_   mov     retval, #ERR_TAT
.get_pid
                call    #urx_next
                testb   urx, #BUS_ERRB          wc
        if_nc   jmp     #.chk_pid
        _ret_   mov     retval, #ERR_URX
.chk_pid
                cmp     retval, #PID_ACK        wz
        if_nz   cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
                testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
                cmp     retval, #PID_DATA0      wz
   if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
   if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
                cmp     retval, #PID_DATA1      wz
   if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
   if_z_and_nc  jmp     #.ack_resend
        _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
.ack_resend
                rqpin   urx, dm
                testb   urx, #EOPB              wc
        if_nc   jmp     #.ack_resend
                mov     retval, #PID_ACK
                call    #utx_handshake                  ' Send handshake PID and return to caller
        _ret_   mov     retval, #ERR_DATAX_SYNC
.chk_eop
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
                call    #urx_next                       ' Low-speed requires an additional read to get EOP status
                testb   hstatus, #EOPB          wc
        if_c    jmp     #.idle                          ' Low-speed EOP seen
                testb   urx, #BUS_ERRB          wz
        if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
        if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
                ret
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
                ret

'------------------------------------------------------------------------------
' Send a token packet with CRC5 checksum of address and endpoint. It is the
' responsibility of the caller to append the appropriate inter-packet delay,
' if one is required.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - packed with the PID, address and endpoint.
' On exit:
'------------------------------------------------------------------------------
utx_token
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #utx_token
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     htmp, ep_addr_pid               ' Preserve the PID and destination
                mov     pkt_cnt, #3
.next_byte
                getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
                shr     htmp, #8                        ' Shift to next byte to send
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   utx, dm
        _ret_   djnz    pkt_cnt, #.next_byte

'------------------------------------------------------------------------------
' SETUP/OUT/INTERRUPT transaction.
' Possible function response in order of precedence: STALL, ACK, NAK.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'     CRC(b19..23).
'   PTRA - start address of the data buff/struct that has the bytes to send.
'   pkt_data - count of DATAx payload bytes to send.
' On exit:
'------------------------------------------------------------------------------
txn_out
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                call    #utx_token                      ' Put SETUP/OUT token on the bus
                rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
                mov     pkt_cnt, pkt_data

                ' Fall through to utx_data

'------------------------------------------------------------------------------
' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
' calculated while the data byte is being shifted out. Since data stage
' success/fail is not determined until the status stage of the transaction,
' this routine is only concerned about the current DATAx packet.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - hub start address of the data to read.
'   pkt_cnt - data payload size.
' On exit:
'------------------------------------------------------------------------------
utx_data
                rqpin   urx, dm
                testb   urx, #SOPB              wc
        if_c    jmp     #utx_data
                mov     hctwait, ip_delay
                call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                bmask   crc, #15                        ' Prime the CRC16 pump
                testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
        if_nc   mov     utx, #PID_DATA0
        if_c    mov     utx, #PID_DATA1
                call    #utx_byte                       ' No CRC calc done on PID
                cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
        if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
.read_byte
                rfbyte  utx                             ' Fetch data byte
                call    #utx_byte
                rev     utx                             ' Calculate CRC while the data is shifting out
                setq    utx                             ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
                djnz    pkt_cnt, #.read_byte
.send_crc
                xor     crc, ##$ffff                    ' Final XOR, and send the calculated CRC16
                getbyte utx, crc, #0
                call    #utx_byte
                getbyte utx, crc, #1
                call    #utx_byte                       ' Last CRC byte out
                jmp     #urx_packet                     ' Handle function response/error and back to caller

'------------------------------------------------------------------------------
' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
' payload bytes are received. The routine reads bytes until EOP is detected and
' expects that the packet includes at least the CRC word.
'
' In control transfers, it's possible to recieve fewer data bytes than what
' was requested, which makes it difficult to determine where the data stops
' and the CRC word begins. So the CRC calculation is done on every byte of the
' packet, including the CRC word. The CRC value should then be equal to the
' USB-16 expected residual value of 0xB001.
'
' The routine writes the IN packet data to a static max_packet_size buffer
' so the caller can verify IN success before writing the data to its final
' destination.
'------------------------------------------------------------------------------
' On entry:
'   pkt_data - max byte count expected to be in the packet.
'   newb_flg - signals new byte ready when toggled.
' On exit:
'   pkt_cnt - actual number of bytes read.
'------------------------------------------------------------------------------
urx_data
                mov     htmp2, pb
                mov     pb, urx_buff_p
                wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
                mov     pb, htmp2
                bmask   crc, #15                        ' Prime the CRC16 pump
                mov     pkt_cnt, #0                     ' Keep track of payload bytes received
                mov     pkt_tmp, pkt_data
                add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
.wait_byte
' In-line rx for max speed
                rqpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   jmp     #.get_byte                      ' New byte!
                testb   urx, #EOPB              wc
        if_c    jmp     #.chk_crc                       ' At end-of-packet
                jmp     #.wait_byte
.get_byte
                getbyte retval, urx, #1                 ' New byte from smart pins
                wfbyte  retval                          ' Add it to the data buffer
                rev     retval                          ' Calculate CRC while next byte is shifting in
                setq    retval                          ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
.end_crc
                add     pkt_cnt, #1
                cmp     pkt_cnt, pkt_tmp        wcz
        if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
        if_a    ret
' For full-speed at 80MHz, the time it takes to do the final byte write and
' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
' to miss it, so cheat a bit and look for SOP clear here.
                rqpin   urx, dm
                testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
        if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
.chk_crc
                sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
                xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
        if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
                mov     retval, #PID_ACK
                mov     hctwait, ip_delay
                call    #poll_waitx

                ' Fall through to utx_handshake

'------------------------------------------------------------------------------
' Transmit a handshake PID. The routine assumes that the bus is IDLE and
' the appropriate IP delay has been inserted.
'------------------------------------------------------------------------------
' On entry:
'   retval - handshake PID to send.
' On exit:
'   retval unchanged.
'------------------------------------------------------------------------------
utx_handshake
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                mov     utx, retval
                call    #utx_byte                       ' Send handshake PID
.idle
                rqpin   urx, dm
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
                mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
                jmp     #poll_waitx

'------------------------------------------------------------------------------
' Wait for the USB tx buffer to empty and feed it a new byte.
'------------------------------------------------------------------------------
' On entry:
'   utx - byte to transmit.
' On exit:
'------------------------------------------------------------------------------
utx_byte
                testp   dp                      wc
        if_nc   jmp     #utx_byte
                akpin   dp
                waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
        _ret_   wypin   utx, dm

'------------------------------------------------------------------------------
' Fetch the next data byte of a packet. Always check receiver status for EOP.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'   retval - the byte read.
'   urx - the receiver status. The caller must check the hstatus reg EOP flag
'     on return. If EOP is set, the byte in reg retval remains as the last byte
'     received.
'------------------------------------------------------------------------------
urx_next
                rdpin   urx, dm
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
        if_nz   ret                                     ' New byte is priority, so return now
                testb   urx, #SOPB              wc
                testb   urx, #BUS_ERRB          wz
   if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
        if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
                ret

'------------------------------------------------------------------------------
' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
' the data used for the USB-5 CRC lookups. The token packet is three bytes in
' length, and the PID is not included in the CRC calculation:
'  CRC5  FRAME_NUMBER SOF (full-speed)
'  CRC5  ENDP ADDRESS PID
' %00000_1111_1111111_xxxxxxxx
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - stuffed with the function endpoint, address and
'     SETUP/IN/OUT/SOF PID according to the USB standard.
' On exit:
'   ep_addr_pid - CRC value appended to the packet.
'------------------------------------------------------------------------------
calc_crc5
                and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
                mov     htmp, ep_addr_pid
                shr     htmp, #8                        ' PID not included in CRC calc
                mov     crc, #$1f                       ' Initial CRC5 value
                rev     htmp                            ' Input data reflected
                setq    htmp                            ' CRCNIB setup for data bits 0..7
                crcnib  crc, #USB5_POLY
                crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
                shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
                crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                xor     crc, #$1f                       ' Final XOR value
                shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
        _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home

'------------------------------------------------------------------------------
' Full-speed/low-speed frame timing interrupt service routine.
'------------------------------------------------------------------------------
isr1_fsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                mov     utx, #PID_SOF
                wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
                call    #utx_byte                       ' Send token PID byte
                mov     icrc, #$1f                      ' Prime the CRC5 pump
                mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
                rev     sof_pkt                         ' Input data reflected
                setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
                crcnib  icrc, #USB5_POLY
                crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
                getbyte utx, frame, #0                  ' Send the low byte of the frame number
                call    #utx_byte
                shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
                rep     #2, #3                          ' Three data bits left to process
                shl     sof_pkt, #1             wc
                crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
                xor     icrc, #$1f                      ' Final XOR value
                getbyte utx, frame, #1                  ' Send remaining frame number bits
                shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
                or      utx, icrc
                call    #utx_byte                       ' Last start-of-frame byte is on the wire
                mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
                jmp     #isr1_wait
isr1_lsframe
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
.wait
                testp   dp                      wc
        if_nc   jmp     #.wait
                akpin   dp
                wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
                mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
isr1_wait
                rqpin   utx, dm
                testb   utx, #SOPB                 wc
        if_c    jmp     #isr1_wait
                add     frame, #1                       ' Next frame# and check for wrap around
                and     frame, ##$7ff
                waitx   isrtmp1                         ' Make sure bus is idle
                reti1

'------------------------------------------------------------------------------
' Wait for a window within the 1ms frame boundary that will ensure that a
' transaction will complete before the next frame is triggered.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
wait_txn_ok
                getct   htmp2
                sub     htmp2, iframe_ct_base
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    cmp     htmp2, _txn_ok_ls_      wcz
        if_nc   cmp     htmp2, _txn_ok_fs_      wcz
        if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
                ret

'------------------------------------------------------------------------------
' A device connection was detected, or a bus reset was requested by the USB
' client. Set the appropriate smart pin FS/LS speed mode to match the device
' and perform a reset sequence prior to device enumeration.
'------------------------------------------------------------------------------
dev_reset
                rqpin   urx, dm
                testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
        if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
        if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
reset
                setint1 #0                              ' Don't want frame interrupt while in reset
                wypin   #OUT_SE0, dm                    ' Assert bus reset
                waitx   _reset_hold_                    ' Spec is >= 10ms
                wypin   #OUT_IDLE, dm
                mov     frame, #0                       ' Reset the frame timespan count
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
                add     htmp, #36
                setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
.framewait
                cmp     frame, htmp             wcz
        if_b    jmp     #.framewait
                ret

'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - source address.
'   PB - destination address.
'   hr0 - length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
hmemcpy
                rdbyte  htmp, ptra++
                wrbyte  htmp, pb
                add     pb, #1
        _ret_   djnz    hr0, #hmemcpy

'------------------------------------------------------------------------------
' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
' loop until the errant device is disconnected.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
host_error
                mov     usb_err_code, retval            ' Save the error code for the client interface
                'wxpin   #USB_ERROR, usb_event_pin       ' Signal the client an error has occurred
                mov     hrep, #5
.spin
                cmp     cmd_data, #CMD_RESET    wz
        if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
'        if_z    drvl    host_error_led
        if_z    jmp     #host_reset                     ' See if it works...
'                drvnot  host_error_led
                mov     hctwait, _100ms_                ' Blink the error LED
                call    #poll_waitx
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #.spin
                djnz    hrep, #.spin
'        if_c    drvl    host_error_led                  ' Clear the error LED
        if_c    ret                             wc      ' Handle disconnect?
                mov     hrep, #5
                jmp     #.spin

'------------------------------------------------------------------------------
' Post interrupt IN transactions at configured intervals.
'------------------------------------------------------------------------------
poll_kbd
                getct   hct3
                addct3  hct3, _8ms_                     ' Set the timer for next poll interval
                jmp     #\hget_kbd_in_report

' USB commands and error codes
cmd_data        long    0
usb_err_code    long    ERR_NONE

' Parameters block assigned at cog startup
dm              long    USB_BASE_PIN + 2    ' Client defines the basepin for four consecutive USB port pins
dp              long    USB_BASE_PIN + 3
usb_event_pin   long    USB_BASE_PIN        ' Host event reporting uses a long repository smart pin
'host_active_led long    57                  ' Client defines the LED pin# for host bus activity
'host_error_led  long    56                  ' Client defines the LED pin# to light on error
kb_cur_report_p long    @kb_cur_report
kb_pre_report_p long    @kb_pre_report
urx_buff_p      long    @urx_buff
dev_desc_buff_p long    @dev_desc_buff
con_desc_buff_p long    @con_desc_buff
cache_start_p   long    @usb_cache_start
cache_end_p     long    @usb_cache_end

hdev_init_start
kb_intf_num     long    0
kb_interval     long    0
kb_in_max_pkt   long    0
kb_next_datax   long    0
kb_max_index    long    0
kb_led_states   long    0
hdev_init_end

hidr_start
hidr_id         long    0
hidr_axis       long    0[3]
hidr_buttons    long    0
hidr_hats       long    0
hidr_flags      long    0
hidr_state      long    0
hidr_size       long    0
hidr_count      long    0
hidr_offset     long    0
hidr_usage      long    0
hidr_usage_idx  long    0
hidr_lminmax    long    0
hidr_pminmax    long    0
hidr_end

' Initialized at cog startup:
save_sysclk     long    0         ' Save the current sysclock as the client may change it
hcog_base_addr  long    0         ' This object's start address in hub, read from PTRB at cog creation
iframe_ct_new   long    0
iframe_ct_base  long    0
p2rev_val       long    P2RevB
utx_tweak       long    0         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
' This register block is reset to zero when a USB device connects
hreg_init_start
hstatus         long    0         ' Host status flags
hctwait         long    0         ' Poll-based wait clocks
ip_delay        long    0         ' Inter-packet delay in bit periods for connected device speed
tat_wait        long    0         ' Maximum bus turn-around time in bit periods for connected device speed
nak_retry       long    0         ' NAK retry count, unlimited retries if zero
xfer_retry      long    0         ' Control transfer retry count
retry           long    0         ' Transaction retry count
utx             long    0         ' Byte to transmit on USB
urx             long    0         ' LSByte receiver status flags, MSByte received data
newb_flg        long    0         ' Receive "new byte" bit toggle detector
poll_target     long    0         ' Address of a subroutine that polls an interrupt IN endpoint
max_pkt_size    long    0         ' Maximum payload bytes allowed, likely to change on device connect.
total_data      long    0         ' Total bytes to tx/rx in a transfer data stage
stage_data      long    0         ' Count of bytes sent/received so far during a data stage.
pkt_data        long    0         ' Payload size of an OUT packet or bytes received on IN
frame           long    0         ' USB 1ms frame counter value
sof_pkt         long    0         ' ISR frame# packet and CRC5
icrc            long    0         ' Only used by the 1ms frame output ISR routine
pkt_cnt         long    0         ' Count of DATAx packet payload bytes
crc             long    0         ' Used for CRC16 calculation
ep_addr_pid     long    0         ' Endpoint and device addresses for connected device
retval          long    0         ' Global success/fail return parameter
context_retval  long    0         ' Operation contextual return parameter
' Device stuff
hdev_id         long    0
hdev_bcd        long    0
hdev_ready      long    0         ' Configured device indicator
' Keyboard/mouse stuff
hctrl_ep_addr   long    0
hctrl_max_pkt   long    0
hconfig_base    long    0
hcon_tot_len    long    0         ' Size of the complete config descriptor chain
hdev_intf_idx   long    0         ' Used during verbose descriptor terminal output
hdev_class      long    0
hdev_subclass   long    0
hdev_protocol   long    0
hsearch_key     long    0         ' Descriptor type to search for in the config chain
hnext_desc      long    0         ' Offset from the config descriptor start address to the next descriptor in the chain
hkbd_ep_addr    long    0         ' Keyboard interface endpoint address
hkbd_poll_cnt   long    0         ' Poll interval counter used for key auto-repeat
hkbd_repeat     long    0         ' Key auto-repeat delay threshold
hkbd_scancode   long    0         ' Key scancode
hkbd_ledstates  long    0         ' Off/on state of keyboard LEDs
hreg_init_end
' Variables dependent on the system freqency
_var_64_lower_  res     1
_var_64_upper_  res     1
_12Mbps_        res     1
_1_5Mbps_       res     1
_1ns16fp_       res     1         ' 1ns as 32,16 fixed point
_1us_           res     1         ' 1us
_10us_          res     1         ' 10us
_33us_          res     1         ' 33us
_txn_err_       res     1         ' 250us
_500us_         res     1         ' 500us
_txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
_txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
_ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
_ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
_tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
_tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
_1ms_           res     1         ' 1ms
_2ms_           res     1         ' 2ms
_suspend_wait_  res     1         ' 3ms
_4ms_           res     1         ' 4ms
_xfer_wait_     res     1         ' 5ms
_8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
_reset_hold_    res     1         ' 15ms
_resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
_21ms_          res     1         ' 21ms
_100ms_         res     1         ' 100ms
_500ms_         res     1         ' 500ms
_pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
_frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'------------------------------------------------------------------------------
_usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
_usb_d_ls_nco_  res     1
_usb_h_fs_nco_  res     1
_usb_d_fs_nco_  res     1
'------------------------------------------------------------------------------
' Scratch registers
htmp            res     1         ' Scratch registers whose context remains within the same code block
htmp1           res     1
htmp2           res     1
htmp3           res     1
hrep            res     1         ' Repeat count
hsave0          res     1         ' Subroutine parameter saves
hsave1          res     1
hsave2          res     1
isrtmp1         res     1
pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
hr0             res     1         ' Multi-purpose registers
hr1             res     1
hr2             res     1
hr3             res     1
hpar1           res     1         ' Routine entry/exit parameters
hpar2           res     1
hpar3           res     1
hct2            res     1         ' Function response bus turn-around timer
hct3            res     1         ' Keyboard/mouse poll timer
mod_cnt         res     1         ' Used in idle loops

                fit     $1F0

DAT             ' USB Host LUT execution
                org     $200
hlut_start

'------------------------------------------------------------------------------
' Full-speed is the host's native speed, so all that is needed is to set the FS
' settings to startup defaults.
'------------------------------------------------------------------------------
' On entry:
' On exit: Save/restore caller C flag state if C is changed in this routine!
'------------------------------------------------------------------------------
set_speed_full
                mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
                mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
        _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
'                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' When a low-speed device connects, the D-/D+ signaling is inverted. If there
' is a downstream hub connected (not yet implemented), the baud generator
' remains set at the full-speed rate, but signaling is switched to low-speed,
' which reverses the D-/D+ polarity. The polarity can be changed without
' putting the smart pins into reset.
'------------------------------------------------------------------------------
' On entry:
' On exit: CZ flags restored to caller states
'------------------------------------------------------------------------------
set_speed_low
                test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
        if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
                testb   p2rev_val, #0           wc      ' P2 Revision is either %0001 (A) or %0010 (B+)
        if_c    dirl    dm                              ' P2RevA needs to be completely reconfigured
        if_c    dirl    dp
        if_c    wrpin   ##USB_V1HMODE_LS, dm            ' Low-speed signaling is always used
        if_c    wrpin   ##USB_V1HMODE_LS, dp
        if_c    wxpin   _1_5Mbps_, dm                   ' Set 1.5Mbs baud if no downstream hub
        if_c    dirh    dm
        if_c    dirh    dp
        if_nc   wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
                mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
                mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
                mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
                bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
                ret                             wcz     ' Restore caller flags on exit

'------------------------------------------------------------------------------
' Perform configuration stuff required when a device intitially connects.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
on_connect
                mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
                call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
.retry
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
        if_nc   mov     hpar1, #USB_SPEED_FULL
                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$40, ptra[wLength]             ' Request IN data stage max of 64 bytes will test actual < requested logic
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.get_dev_desc
                mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
                call    #poll_waitx
                sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
        if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
                call    #reset                          ' Try another reset to see if the device responds
                jmp     #.retry
.get_dev_desc
                mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
                call    #reset
                loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
                add     ptra, hcog_base_addr
                wrword  #1, ptra[wValue]                ' Only support one device port at this time
                call    #control_write                  ' Execute SetAddress()
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctwait, _8ms_
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, #1 << 8            ' Device ep/addr now #1 and endpoint zero
                call    #calc_crc5
                loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
                add     ptra, hcog_base_addr
                mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
                mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
                rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
                mov     hctwait, _500us_
                call    #poll_waitx
                loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
                add     ptra, hcog_base_addr
                wrword  #$ff, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_nz   ret
                mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
                mov     hconfig_base, ptra              ' Will need this for configuration
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    mov     retval, #ERR_CONFIG_FAIL
        if_b    jmp     #host_error
                loc     pa, #@hparse_con_desc - @usb_host_start
                add     pa, hcog_base_addr
                jmp     pa

'------------------------------------------------------------------------------
' Perform a control read transaction (Section 8.5.3, Figure 8-37).
' Status reporting is always in the function-to-host direction.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - start address of the SETUP data in hub.
'   PB - start address of the buffer/struct to be written to during the IN data
'     stage.
'   ep_addr_pid - device address, endpoint and CRC5.
' On exit:
'   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'     contains the count of data stage bytes actually received, which must
'     always be <= the count requested.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_read
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb                       ' Save dest buffer pointer
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                mov     nak_retry, ##IN_NAK_RETRIES
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
.nak_retry
                mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
.in_retry
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' Commit on ACK
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak_retry                     ' Function not ready to send data
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.in_retry                      ' Bus error retry
                ret                                     ' The transfer has failed
.commit
                cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
        if_z    jmp     #.pre_status                    ' and also end-of-data
                mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
                add     stage_data, pkt_cnt             ' Update bytes received on commit
                cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
        if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
                cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
        if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
        if_a    mov     retval, #ERR_PACKET
        if_a    mov     context_retval, retval          ' In this case overall and context are the same
        if_a    ret                                     ' Caller must handle ERR_PACKET
                bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
                jmp     #.data                          ' Start next IN transaction
.pre_status
                mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
                setbyte ep_addr_pid, #PID_OUT, #0
                mov     pkt_data, #0
                bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
                mov     nak_retry, ##OUT_NAK_RETRIES
.out_retry
                call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
                cmp     retval, #PID_ACK        wz
        if_z    ret                                     ' All is good when ACK
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
                ret                                     ' Caller must handle transfer retirement
' I've encountered transfer STALL, even though the data looks correct, and
' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
' ControlRead() transfer gets things unstuck most of the time...
.xfer_retry
                mov     hctwait, _xfer_wait_
                call    #poll_waitx
                call    #wait_txn_ok
                mov     ep_addr_pid, hpar1
                mov     ptra, hpar2
                mov     pb, hpar3
                djnz    xfer_retry, #.xfer_start
                mov     context_retval, retval          ' Preserve the USB error code
        _ret_   mov     retval, #ERR_XFER_RETRY

'------------------------------------------------------------------------------
' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
' reporting is always in the function-to-host direction. It is assumed that
' the SETUP data struct is filled with the required values.
'------------------------------------------------------------------------------
' On entry:
'   PTRA - points to the start of the struct for the SETUP data.
'   PB - the start address of the struct/buffer to be read for the OUT data
'     stage.
'   ep_addr_pid - the proper CRC'd address and endpoint to use.
' On exit:
'   retval - used to convey the success/failure of each stage.
'   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'     more specific USB operation error code.
'------------------------------------------------------------------------------
control_write
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
.out_retry
                mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
                call    #txn_out
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit                        ' Function got the data
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
        if_nz   jmp     #.out_retry
                ret                                     ' Caller must handle transfer retirement
.commit
                mov     pb, ptra                        ' Save the current buffer/struct location
                add     stage_data, pkt_data
                cmp     stage_data, total_data  wz
        if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
        if_nz   jmp     #.data                          ' More data to send
pre_status_in
                bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.status_retry
                mov     pkt_data, #0
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
        if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
        if_z    ret                                     ' Control Write finished
                cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
        if_z    ret
                call    #retry_wait                     ' NAK or bus error, so delay a bit
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.status_retry
                ret                                     ' Caller must handle transfer retirement

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - The function address and endpoint for the IN request.
'   hpar2 - Address of the IN data buffer
'   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
' On exit:
'   retval - the result of the operation.
'   hpar3 - the count of IN data bytes actually received.
'------------------------------------------------------------------------------
do_int_in
                getword htmp, hpar3, #0
                cmp     htmp, #PID_DATA0        wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
                mov     retry, #TXN_RETRIES
.retry
                getword pkt_data, hpar3, #1             ' IN max packet length
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK if data received
        if_z    jmp     #.commit
                cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
        if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
        if_z    jmp     #.post_ret                      ' The caller must handle either
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    jmp     #.post_ret
                jmp     #.retry
.commit
                cmp     pkt_cnt, #0             wz
        if_z    jmp     #.post_ret                      ' Skip copy if it's an empty packet
                mov     ptra, urx_buff_p                ' Copy the rx buffer
                mov     pb, hpar2                       ' to the destination buffer
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
.post_ret
                mov     hpar3, pkt_cnt                  ' IN bytes actually received
                ret

'------------------------------------------------------------------------------
' The one millisecond frame timer is implemented as an interrupt service
' routine. Since this timing is critical, care must be taken to avoid any
' instructions that can delay the interrupt branch, which will likely upset
' the timer. WAITX is among those instructions, so any time you're inside
' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'------------------------------------------------------------------------------
' On entry:
'   hctwait - wait interval in sysclocks.
' On exit:
'------------------------------------------------------------------------------
poll_waitx
                getct   hct2
                addct2  hct2, hctwait
.wait
                jnct2   #.wait
                ret

'------------------------------------------------------------------------------
' Transaction retry handling for NAK/STALL or bus error.
'------------------------------------------------------------------------------
' On entry:
'   retval - transaction response PID or error code.
' On exit:
'------------------------------------------------------------------------------
retry_wait
                cmp     retval, #PID_STALL      wz
        if_z    ret                                     ' STALL is special case
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak
                mov     hctwait, _txn_err_              ' Transaction error wait...
                call    #poll_waitx
.dec
                sub     retry, #1               wz
        if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
                ret                                     ' Retry result to caller
.nak
                mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
                call    #poll_waitx
                cmp     nak_retry, #NAK_NOLIMIT wz
        if_z    ret                                     ' Indefinite NAK retries
                sub     nak_retry, #1           wz
        if_z    mov     retval, #ERR_NAK
                ret

host_reset
                setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
                mov     htmp, ##_CLKFREQ                ' Get current sysclock setting
' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
                cmp     htmp, ##168_000_000     wcz
        if_be   mov     utx_tweak, #0
        if_a    mov     utx_tweak, #3   '#20
' Check to see if the system clock has been changed.
                cmp     htmp, save_sysclk       wz
        if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
        if_nz   add     pb, hcog_base_addr
        if_nz   call    pb                              ' Recalculate sysclk dependent timing values
                dirl    dm                              ' Put smart pins into reset
                dirl    dp
                cmp     p2rev_val, #P2RevB      wz
        if_z    jmp     #.not_reva
                wrpin   ##USB_V1HMODE_FS, dm            ' The host is also the root hub, so full-speed is its native speed
                wrpin   ##USB_V1HMODE_FS, dp
                wxpin   _12Mbps_, dm                    ' Default to Full-Speed
                jmp     #.enable
.not_reva
                wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
                wrpin   ##USB_V2_DRVOUT, dp
                wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
.enable
                dirh    dm                              ' Crank them smart pins up
                dirh    dp
                waitx   _1us_
                wypin   #OUT_IDLE, dm
                waitx   _21ms_                          ' Hold to let the idle state get settled
                mov     pa, #hreg_init_start            ' Reset all host common registers to startup values
.regloop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hreg_init_end      wz
        if_nz   jmp     #.regloop
discon_entry
                mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one

                ' Fall through to disconnected loop

'-----------------------------------------------------------------------------------------------------------------
' Device connect handling (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
' device to connect (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
disconnected
                mov     hr1, ##_CLKFREQ                 ' Check to see if the system frequency has changed
                cmp     hr1, save_sysclk        wz
        if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
                shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
                waitx   hr1                             ' it down to smaller wait chunks
                incmod  mod_cnt, #8             wc
'        if_c    drvnot  host_active_led
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
        if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
        if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
.se1_test
                mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
                call    #poll_waitx
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
        if_ne   jmp     #discon_entry                   ' Back to connect detection loop
.se1            'SE1 is a fatal error condition
                mov     hctwait, _100ms_
                call    #poll_waitx
                mov     retval, #ERR_SE1
                call    #host_error                     ' Seeing SE1 for any length of time is not good...
.connect_test                                           ' Test lines until stable J/K state seen
                waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
                rqpin   urx, dm
                and     urx, #J_IDLEF | K_RESUMEF wcz
        if_z    jmp     #discon_entry                   ' D+ and D- low
        if_e    jmp     #.se1_test                      ' D+ and D- high
connected
                bith    hstatus, #CONNECTEDB            ' Device plugged in
                call    #on_connect                     ' Initial device configuration
                cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
        if_nz   jmp     #discon_entry
set_poll_target
                mov     poll_target, #0                 ' If unknown device, no interrupt targets
                cmp     hkbd_ep_addr, #0        wz
        if_nz   mov     poll_target, #poll_kbd
.set_pulse
                getct   _pulse_time_
                add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
' of 1ms and make a correction, if necessary.
'                mov     htmp, _1ms_
'                subs    htmp, iframe_delta
'                adds    _frame1ms_clks_, htmp
'                debug(udec(_frame1ms_clks_))

                ' Fall through to idle/processing loop

hidle
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_c    jmp     #.se0_test
                cmp     poll_target, #0         wz
        if_z    jmp     #.nopoll
                pollct3                         wc
        if_c    call    poll_target                     ' Call the current poll/wait subroutine
.nopoll
                cmp     cmd_data, #CMD_SUSPEND  wz
        if_z    jmp     #hsuspend
                cmp     cmd_data, #CMD_RESET    wz
        if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
        if_z    jmp     #host_reset                     ' See if it works...
                getct   hr0
                cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
'        if_ae   drvnot  host_active_led
        if_ae   getct   _pulse_time_
        if_ae   add     _pulse_time_, _500ms_
                jmp     #hidle
' Check for extended SE0 state on the bus
.se0_test
                mov     hctwait, _1ms_
                call    #poll_waitx                     ' Wait a bit and test for SE0 again
                rqpin   urx, dm
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #hidle                          ' Bus still IDLE
                call    #wait_txn_ok
                wypin   ##OUT_IDLE, dm                  ' Float USB
                'wxpin   #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
                jmp     #host_reset                     ' Device disconnected

hsuspend
                call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
                setint1 #0                              ' Stopping the 1ms frame packets signals suspend
                waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
                wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
                mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
                mov     mod_cnt, #0

                ' Fall through to resume wait loop

hwait_resume
                mov     hr1, ##_CLKFREQ                 ' Use the CLKFREQ value, as the sysclock may change
                shr     hr1, #2
                waitx   hr1                             ' Pulse the activity LED every two seconds but break
                incmod  mod_cnt, #8             wc      ' it down to smaller wait chunks
'        if_c    drvnot  host_active_led
                cmp     cmd_data, #CMD_RESUME   wz
        if_nz   jmp     #hwait_resume
                mov     htmp, ##_CLKFREQ                ' Check to see if the system frequency has changed
                cmp     htmp, save_sysclk       wz
        if_z    jmp     #.resume
                loc     pb, #@hinit_usb_timings - @usb_host_start
                add     pb, hcog_base_addr
                call    pb                              ' Recalculate sysclk dependent timing values
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
        if_c    wxpin   _usb_h_ls_nco_, dm
.resume
                wypin   #OUT_K, dm
                waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
                wypin   #OUT_SE0, dm
                mov     htmp, _ip_delay_ls_
                shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
                waitx   htmp
                wypin   #OUT_J, dm
                shr     htmp, #1
                waitx   htmp
                wypin   #OUT_IDLE, dm
                getct   iframe_ct_base
                mov     iframe_ct_new, iframe_ct_base
                addct1  iframe_ct_new, _frame1ms_clks_
                setint1 #1                              ' Enable the 1ms frame ISR
                mov     hctwait, _4ms_
                call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
                mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
                jmp     #set_poll_target                ' This addr configs a USB poll transaction and falls thru to hidle

hlut_end
                fit     $400

DAT             ' USB Host HUB execution
                orgh
'------------------------------------------------------------------------------
' Routines called from cog space.
'------------------------------------------------------------------------------
' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'------------------------------------------------------------------------------

'------------------------------------------------------------------------------
' USB host cog initialization.
'------------------------------------------------------------------------------
usb_host_init
'                drvl    host_error_led                  ' Ensure fatal error LED is inactive
'                mov     p2rev_val, ptrb                 ' Running on P2RevA or P2RevB+ silicon?
'                setq    #1
'                rdlong  $1e0, ptrb++
'                subr    p2rev_val, ptrb
'                shr     p2rev_val, #2           wz      ' RevA if shift result is zero
'        if_z    mov     p2rev_val, #P2RevA              ' 1 == RevA, 2 == RevB+
'                loc     ptrb, #p2rev_char               ' Make a revision "A" or "B" char accessible to Spin2
'                mov     htmp, p2rev_val
'                add     htmp, #"@"
'                wrbyte  htmp, ptrb
                dirl    usb_event_pin                   ' Configure the USB event mailbox smart pin
                wrpin   ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
                dirh    usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
' Configure and enable the Serial Host USB port.
                mov     htmp, usb_event_pin             ' I/O + 1 pin is the Serial Host USB Protection enable/disable
                add     htmp, #1                        ' Protection enable is a one-time operation
                drvh    htmp                            ' Enable the port
                jmp     #host_reset                     ' Initialize host and enter main processing loop

'------------------------------------------------------------------------------
' Timing calculations happen before any interrupt(s) are enabled.
'------------------------------------------------------------------------------
' On entry:
'   htmp - current CLKFREQ value.
'------------------------------------------------------------------------------
hinit_usb_timings
'                getct   htmp2
                mov     save_sysclk, htmp
                qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
                getqx   _12Mbps_
                shr     _12Mbps_, #16           wc
                addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
                mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
                shl     _usb_h_fs_nco_, #14
                add     _usb_h_fs_nco_, _12Mbps_
                mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
                shl     _usb_d_fs_nco_, #14
                add     _usb_d_fs_nco_, _12Mbps_
                mov     _1_5Mbps_, _12Mbps_
                shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
                mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
                shl     _usb_h_ls_nco_, #14
                add     _usb_h_ls_nco_, _1_5Mbps_
                mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
                qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1b
                getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1m
                getqx   _1us_                           ' 1us as 32,9 fixed point
                mov     hsave0, _1us_                   ' Save it to compute other us values
                shr     _1us_, #9               wc
                addx    _1us_, #0                       ' Round to final value
                qmul    hsave0, #10                     ' Calc 10us
                getqx   _10us_
                shr     _10us_, #9              wc
                addx    _10us_, #0                      ' 10us
                qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
                getqx   _33us_
                shr     _33us_, #9              wc
                addx    _33us_, #0                      ' 33us
                qmul    hsave0, #250                    ' Calc 250us
                getqx   _txn_err_
                shr     _txn_err_, #9           wc
                addx    _txn_err_, #0                   ' 250us
                qmul    hsave0, #500                    ' Calc 500us
                getqx   _500us_
                shr     _500us_, #9             wc
                addx    _500us_, #0                     ' 500us
                qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
                getqx   _txn_ok_ls_
                shr     _txn_ok_ls_, #9         wc
                addx    _txn_ok_ls_, #0                 ' 666us
                qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
                getqx   _txn_ok_fs_
                shr     _txn_ok_fs_, #9         wc
                addx    _txn_ok_fs_, #0                 ' 850us
                mov     _ip_delay_ls_, _1ns16fp_
                mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_ls_, #16      wc
                addx    _ip_delay_ls_, #0
                mov     _tat_wait_ls_, _1ns16fp_
                mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
                shr     _tat_wait_ls_, #16      wc
                addx    _tat_wait_ls_, #0
                mov     _ip_delay_fs_, _1ns16fp_
                mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
                shr     _ip_delay_fs_, #16      wc
                addx    _ip_delay_fs_, #0
                mov     _tat_wait_fs_, _1ns16fp_
                mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
                shr     _tat_wait_fs_, #16      wc
                addx    _tat_wait_fs_, #0
                qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
                getqx   _var_64_lower_
                getqy   _var_64_upper_
                setq    _var_64_lower_
                qfrac   _var_64_upper_, ##_1thou
                getqx   _1ms_                           ' 1ms as 32,9 fixed point
                shr     _1ms_, #9               wc
                addx    _1ms_, #0                       ' 1ms
                mov     _frame1ms_clks_, ##-14
                adds    _frame1ms_clks_, _1ms_
                mov     _2ms_, _1ms_
                shl     _2ms_, #1                       ' 2ms
                mov     _suspend_wait_, _1ms_
                add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
                mov     _4ms_, _1ms_
                shl     _4ms_, #2                       ' 4ms
                mov     _xfer_wait_, _4ms_
                add     _xfer_wait_, _1ms_              ' 5ms
                mov     _reset_hold_, _xfer_wait_       ' 5ms
                mov     _resume_hold_, _reset_hold_
                shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
                mov     _100ms_, _resume_hold_          ' 20ms
                shl     _100ms_, #1                     ' 40ms
                mov     _8ms_, _1ms_
                shl     _8ms_, #3                       ' 8ms
                shl     _reset_hold_, #1                ' 10ms
                add     _100ms_, _reset_hold_           ' 50ms
                add     _reset_hold_, _xfer_wait_       ' 15ms
                mov     _21ms_, _xfer_wait_             ' 5ms
                shl     _21ms_, #2                      ' 20ms
                add     _21ms_, _1ms_                   ' 21ms
                mov     _500ms_, _100ms_                ' 50ms
                shl     _100ms_, #1                     ' 100ms
                shl     _500ms_, #3                     ' 400ms
        _ret_   add     _500ms_, _100ms_                ' 500ms
'        _ret_   mov     _1sec_, save_sysclk
'        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'                ret
{
                getct   htmp
                sub     htmp, htmp2
        debug("USB timing calc sysclocks: ", udec( htmp))
                ret
}

'------------------------------------------------------------------------------
' Parse a configuration descriptor chain to see if the device is a recognized
' one. If it is, start the task progression that will configure the device for
' use.
'------------------------------------------------------------------------------
' On entry:
'   hconfig_base - start address of the cached config descriptor chain.
' On exit:
'------------------------------------------------------------------------------
hparse_con_desc
                call    #init_kbdm_data                 ' Reset device data area to start-up values

                mov     ptrb, dev_desc_buff_p
                rdword  htmp, ptrb[4]       ' idVendor
                rdword  hdev_id, ptrb[5]    ' idProduct
                setword hdev_id, htmp, #1
                rdword  hdev_bcd, ptrb[6]   ' bcdDevice
                debug(uhex_long(hdev_id), uhex_word(hdev_bcd))

                mov     pa, #CON_wTotalLen
                add     pa, hconfig_base
                rdword  hcon_tot_len, pa                ' Keep config chain size handy
                'debug(uhex_byte_array(hconfig_base, hcon_tot_len))
' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
' that defines a keyboard and/or mouse.
                rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
.next_intf
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #hset_config
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.intf
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                jmp     #.next_intf
.intf
                mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
                mov     hpar3, #0
                rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
                rdbyte  hdev_class, ptrb[INTF_bIntfClass]
                rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
                rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
                debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))

.endp
                rdbyte  htmp, ptrb
                add     hnext_desc, htmp                ' Get offset of next desc to check
                cmp     hnext_desc, hcon_tot_len wcz
        if_ae   jmp     #.get_device
                mov     ptrb, hconfig_base
                add     ptrb, hnext_desc
                rdbyte  htmp, ptrb[DESC_bDescType]
                cmp     htmp, #TYPE_INTERFACE   wz
        if_z    jmp     #.get_device
                cmp     htmp, #TYPE_ENDPOINT    wz
        if_z    jmp     #.get_ep
                jmp     #.endp
.get_ep
                rdbyte  hr1, ptrb[ENDP_bAddress]
                testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
                shl     hr1, #8 + 7
                mov     htmp, hctrl_ep_addr
                and     htmp, ##ADDR_MASK
                or      htmp, hr1                       ' endpoint address
                cmp     hpar2, #0               wz
  if_z_and_c    jmp     #.in_ep
                cmp     hpar3, #0               wz
 if_z_and_nc    jmp     #.out_ep
                jmp     #.endp
.in_ep
                mov     hpar2, htmp                     ' IN endpoint
                rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr2, hr0, #3
                jmp     #.endp
.out_ep
                mov     hpar3, htmp                     ' OUT endpoint
                rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
                'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
                setbyte hr3, hr0, #3
                jmp     #.endp

.get_device
                cmp     hdev_class, #CLASS_HID              wz
        if_nz   jmp     #.next_intf                     ' No HID class, ignore
                cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
        if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
.keyboard
                cmp     hdev_protocol, #INTF_PROTO_KBD      wz
        if_nz   jmp     #.next_intf                     ' No Keyboard
                cmp     hkbd_ep_addr, #0    wz
        if_nz   jmp     #.next_intf
                getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
                getbyte kb_interval, hr2, #3
                mov     hkbd_ep_addr, hpar2             ' IN endpoint address
                getbyte kb_in_max_pkt, hr2, #0
                'debug(udec(kb_intf_num))
                debug(uhex_long(hkbd_ep_addr),udec(kb_in_max_pkt,kb_interval))
                jmp     #.next_intf

'------------------------------------------------------------------------------
' If a newly-connected device is recognized, do whatever is needed to configure
' it according to its function, or functions. In the case of this boot protocol
' keyboard/mouse class driver:
' - SetConfiguration(config_num)
' - SetProtocol(boot)
' - SetIdle(indefinite)
' - Enter the device interrupt IN polling task stage.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hset_config
'                mov     hkbd_ep_addr, #0                ' DEBUG
'                mov     hmouse_ep_addr, #0              ' DEBUG
                mov     htmp2, #DEV_UNKNOWN
                cmp     hkbd_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No boot keyboard or mouse interface
.set_config
                loc     ptra, #set_config
                mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
                add     pa, hconfig_base
                rdbyte  hpar1, pa
                wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
                mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
                mov     pb, #0                          ' SetConfiguration() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   ret
.kbd_config
                cmp     hkbd_ep_addr, #0        wz
        if_z    jmp     #.notify_client                 ' No keyboard
                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_protocol
                wrword  #BOOT_PROTOCOL, ptra[wValue]
                wrword  htmp, ptra[wIndex]
                mov     pb, #0                          ' SetProtocol() has no data stage
                call    #control_write
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
                getbyte hpar2, kb_intf_num, #0
                call    #hset_idle
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     hctwait, _2ms_
                call    #poll_waitx
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   mov     hkbd_ep_addr, #0
        if_nz   jmp     #.notify_client
                mov     ep_addr_pid, hkbd_ep_addr
                call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
                mov     hkbd_ep_addr, ep_addr_pid
                mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
                mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
                mov     hkbd_repeat, #KBD_REPEAT_DELAY
                mov     htmp2, #KB_READY                ' Keyboard interface configured
.notify_client
        _ret_   mov     hdev_ready, htmp2               ' Save device ready
        '_ret_   wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured

'------------------------------------------------------------------------------
' Initialize the keyboard/mouse data area to start-up values.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
init_kbdm_data
                mov     hkbd_ep_addr, #0

                mov     ptra, cache_start_p         ' Clear cached data buffers
                mov     pa, cache_end_p
.loop
                wrbyte  #0, ptra++
                cmp     ptra, pa                wcz
        if_b    jmp     #.loop

                mov     pa, #hdev_init_start        ' Clear device data registers
.regloop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hdev_init_end      wz
        if_nz   jmp     #.regloop
        _ret_   mov     kb_next_datax, #PID_DATA0   ' Reset interrupt IN datax sequence PIDs

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
' function.
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'   hpar2 - index number of the target interface.
' On exit:
'------------------------------------------------------------------------------
hset_idle
                mov     hctwait, _2ms_
                call    #poll_waitx
                loc     ptra, #set_idle
                wrword  hpar1, ptra[wValue]
                wrword  hpar2, ptra[wIndex]
                jmp     #control_write

'------------------------------------------------------------------------------
' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'------------------------------------------------------------------------------
' On entry:
'   ep_addr_pid - device address and enpoint for the request.
' On exit:
'   retval - transaction result.
'------------------------------------------------------------------------------
hset_kbdled_report
                getbyte htmp, kb_intf_num, #0
                loc     ptra, #set_report
                wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
                wrword  htmp, ptra[wIndex]
                wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
                mov     pb, urx_buff_p
                wrbyte  kb_led_states, pb
                jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller

'------------------------------------------------------------------------------
' Execute an IN interrupt transaction to poll for keyboard activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
hget_kbd_in_report
                mov     ep_addr_pid, hkbd_ep_addr
                mov     hpar2, kb_cur_report_p
                setword hpar3, kb_next_datax, #0
                setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
                call    #do_int_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.data
                cmp     retval, #PID_NAK        wz
        if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
' The NAK count is used to determine when key auto-repeat kicks in.
                add     hkbd_poll_cnt, #1
                cmp     hkbd_poll_cnt, hkbd_repeat wcz
        if_b    ret                                     ' No auto-repeat action
'                cmp     hkbd_poll_cnt, #KBD_REPEAT_DELAY wz
'        if_z    drvnot  host_active_led                 ' Show keypress activity on the feedback LED
                mov     hpar1, hkbd_scancode    wz      ' Peek at the last key-down scancode
        if_z    mov     hkbd_repeat, #KBD_REPEAT_DELAY  ' Key repeat delay reset on KEY_NO_KEY
        if_z    mov     hkbd_poll_cnt, #0
        if_z    ret
                add     hkbd_repeat, #KBD_REPEAT_RATE   ' Set the next repeat interval
                modc    _clr                    wc      ' Signal key pressed
                rdbyte  hpar2, kb_cur_report_p
                jmp     #\hkbd_key                      ' Repeat the key being held down and return to caller
.data
'                drvnot  host_active_led                 ' Show keypress activity on the feedback LED
                cmp     hpar3, #0               wz
        if_z    ret                                     ' Ignore an empty DATAx packet
                mov     hpar1, kb_next_datax
                cmp     hpar1, #PID_DATA0       wz
        if_z    mov     hpar1, #PID_DATA1               ' Txn success, so toggle DATAx
        if_nz   mov     hpar1, #PID_DATA0
                mov     kb_next_datax, hpar1
                mov     kb_max_index, hpar3             ' Save actual bytes read
                call    #hkbd_compare
.led_check
                mov     htmp, kb_led_states
                cmp     hkbd_ledstates, htmp    wz
        if_z    ret                                     ' No toggle key indicator changes, so we're done
                mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
                mov     ep_addr_pid, hctrl_ep_addr
                call    #hset_kbdled_report
                cmp     retval, #PID_ACK        wz
        if_nz   jmp     #host_error                     ' FIXME: on !ACK try to recover instead of fatal error
                ret

'------------------------------------------------------------------------------
' Compare current and previous keyboard data buffers for keypress changes.
'------------------------------------------------------------------------------
hkbd_compare
                mov     ptra, kb_cur_report_p
                mov     ptrb, kb_pre_report_p
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
                cmp     htmp1, htmp2    wz
                rdlong  htmp1, ptra++
                rdlong  htmp2, ptrb++
        if_z    cmp     htmp1, htmp2    wz
        if_z    ret

                mov     hkbd_repeat, #KBD_REPEAT_DELAY  ' Report was different than last,
                mov     hkbd_poll_cnt, #0               ' so reset auto-repeat

                mov     hpar1, #0
                rdbyte  hpar2, kb_cur_report_p
                rdbyte  hpar3, kb_pre_report_p
                cmp     hpar2, hpar3    wz
        if_nz   call    #hkbd_shift

.release        modc    _set    wc
                mov     ptra, kb_pre_report_p
                add     ptra, #2
                mov     pa, #6
.rl1            rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.rl3
                mov     ptrb, kb_cur_report_p
                add     ptrb, #2
                mov     pb, #6
.rl2            rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.rl3
                djnz    pb, #.rl2
                mov     hkbd_scancode, #0
                call    #\hkbd_key
.rl3            djnz    pa, #.rl1

                mov     hpar3, #0
                bith    hpar3, #31

.press          modc    _clr    wc
                mov     ptra, kb_cur_report_p
                add     ptra, #2
                mov     pa, #6
.pl1            rdbyte  hpar1, ptra++   wz
        if_z    jmp     #.pl3
                mov     ptrb, kb_pre_report_p
                add     ptrb, #2
                mov     pb, #6
.pl2            rdbyte  htmp, ptrb++
                cmp     hpar1, htmp     wz
        if_z    jmp     #.pl3
                djnz    pb, #.pl2
                mov     hkbd_scancode, hpar1
                call    #\hkbd_key
.pl3            djnz    pa, #.pl1

.copy           mov     ptra, kb_cur_report_p
                mov     ptrb, kb_pre_report_p
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++
                rdlong  htmp, ptra++
                wrlong  htmp, ptrb++

                ret

'------------------------------------------------------------------------------
' Translate keyboard scancode
'------------------------------------------------------------------------------
' On entry:
'   hpar1 - usb scancode
'   hpar2 - key modifiers state
'       c - pressed (0) or released (1) flag
'------------------------------------------------------------------------------
hkbd_key
                mov     htmp, hpar1
                add     htmp, ##@kbd_table
                rdbyte  htmp, htmp      wz
        if_nz   jmp     #\hkbd_out_char
                ret

hkbd_shift
                testb   hpar3, #LEFT_SHIFTB     wc
                testb   hpar2, #LEFT_SHIFTB     wz
    if_c_or_z   mov     htmp, #$2A
    if_c_or_z   jmp     #\hkbd_out_char

                testb   hpar3, #RIGHT_SHIFTB    wc
                testb   hpar2, #RIGHT_SHIFTB    wz
    if_c_or_z   mov     htmp, #$36
    if_c_or_z   jmp     #\hkbd_out_char

                testb   hpar3, #LEFT_CTRLB      wc
                testb   hpar2, #LEFT_CTRLB      wz
    if_c_or_z   mov     htmp, #$1D
    if_c_or_z   jmp     #\hkbd_out_char

                testb   hpar3, #RIGHT_CTRLB     wc
                testb   hpar2, #RIGHT_CTRLB     wz
    if_c_or_z   mov     htmp, #$1D
    if_c_or_z   jmp     #\hkbd_out_char

                testb   hpar3, #LEFT_ALTB       wc
                testb   hpar2, #LEFT_ALTB       wz
    if_c_or_z   mov     htmp, #$38
    if_c_or_z   jmp     #\hkbd_out_char

                testb   hpar3, #RIGHT_ALTB      wc
                testb   hpar2, #RIGHT_ALTB      wz
    if_c_or_z   mov     htmp, #$38
    if_c_or_z   jmp     #\hkbd_out_char

                ret

hkbd_out_char
                'debug(uhex_byte(hpar1),ubin_byte(hpar2),uhex_byte(htmp))
                bitc    htmp, #7
                wrbyte  htmp, #@kbd_data

.wl1            locktry #0              wc
        if_nc   jmp     #.wl1

                rdbyte  htmp1, #@irq
                bith    htmp1, #1
                wrbyte  htmp1, #@irq

        _ret_   lockrel #0

kbd_table ' Index is the key scan code
          {$00} byte    $00, $00, $00, $00                      ' $03
          {$04} byte    $1E, $30, $2E, $20                      ' $07: a b c d
          {$08} byte    $12, $21, $22, $23, $17, $24, $25, $26  ' $0f: e f g h i j k l
          {$10} byte    $32, $31, $18, $19, $10, $13, $1F, $14  ' $17: m n o p q r s t
          {$18} byte    $16, $2F, $11, $2D, $15, $2C, $02, $03  ' $1f: u v w x y z 1 2
          {$20} byte    $04, $05, $06, $07, $08, $09, $0A, $0B  ' $27: 3 4 5 6 7 8 9 0
          {$28} byte    $1C, $01, $0E, $0F, $39, $0C, $0D, $1A  ' $2f: Enter Esc BkSpc Tab Spc - = [
          {$30} byte    $1B, $00, $2B, $27, $28, $29, $33, $34  ' $37: ] \ # ; ' ` , .
          {$38} byte    $35, $3A, $3B, $3C, $3D, $3E, $3F, $40  ' $3f: / CapsLock F1 F2 F3 F4 F5 F6
          {$40} byte    $41, $42, $43, $44, $00, $00, $37, $46  ' $47: F7 F8 F9 F10 F11 F12 PrtSc, ScrLk
          {$48} byte    $00, $52, $47, $49, $53, $4F, $51, $4D  ' $4f: Pause, Ins, Home PgUp BkSpc_Del End PgDn Right
          {$50} byte    $4B, $50, $4C, $45, $35, $00, $4A, $4E  ' $57: Left Down Up KpdNumLck Kp/ Kp* Kp- Kp+
          {$58} byte    $1C, $00, $00, $00, $00, $4C, $00, $00  ' $5f: KpEnter Kp1_End Kp2_Down Kp3_PgDn Kp4_Left Kp5 Kp6_Right Kp7_Home
          {$60} byte    $00, $00, $00, $00, $56, $00            ' $65: Kp8_Up Kp9_PgUp Kp0_Ins Kp._Del Kp\_| App

'------------------------------------------------------------------------------
' Partially populated SETUP packets
'------------------------------------------------------------------------------
get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_DEVICE << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_GET_DESC
                word    TYPE_CONFIG << 8
                word    0       ' Zero or Language ID (Section 9.6.7)
                word    0       ' Number of bytes to transfer if there is a data stage
set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_CONFIG
                word    0       ' Configuration value
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_CONFIG has no data stage
set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                byte    REQ_SET_ADDR
                word    0       ' Zero
                word    0       ' Zero
                word    0       ' Zero, as REQ_SET_ADDR has no data stage
'------------------------------------------------------------------------------
' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
' wValue field dictates which protocol should be used.
'
' When initialized, all devices default to report protocol. However the host
' should not make any assumptions about the device state and should set the
' desired protocol whenever initializing a device.
'------------------------------------------------------------------------------
set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_PROTO
                word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
                                                ' (HID 1.11 Section 7.2.6).
                word    0               ' Interface index number.
                word    0               ' Zero, as HID_SET_PROTO has no data stage.
'------------------------------------------------------------------------------
set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_IDLE
                word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
                                        ' reporting until a change is detected in the report data

                                        ' (HID 1.11 Section 7.2.4).
                word    0       ' Interface index number.
                word    0       ' Zero, as HID_SET_IDLE has no data stage.
set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                byte    HID_SET_REPORT
                word    0       ' Byte1 = report type, byte0 = ReportID.
                                        ' (HID 1.11 Section 7.2.2).
                word    0       ' Interface index number.
                word    0       ' Size of the report, in bytes.

'------------------------------------------------------------------------------
' The USB data cache area gets zero-filled at every device disconnect
'------------------------------------------------------------------------------
usb_cache_start

' Keyboard report buffers
kb_cur_report   byte    0[KBD_IN_RPT_LEN]
kb_pre_report   byte    0[KBD_IN_RPT_LEN]

usb_cache_end

urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain

CON ' USB Host Shared constants
'------------------------------------------------------------------------------
' Smart pin configuration for "long repository" mode with output enabled,
' regardless of DIR. This allows one pin to provide a long event code via IN
' and also to control the USB port activity LED on/off state vio OUT.
    SP_REPO1_MODE = %01_00001_0 | 1 << 16    ' %TT_MMMMM_0, P[12:10] != %101
'------------------------------------------------------------------------------
' A simple event/cmd system using a smart pin configured in "long repository"
' mode. The USB_EVENT_REPO pin defined above is used to allow the USB cog to
' signal the client that a particular event has occurred. The client must poll
' this smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main"
' loop and process the event IDs you're interested in.
'------------------------------------------------------------------------------
    #0, NO_EVENT, USB_ERROR, DEV_UNKNOWN, KB_READY, M_READY, KBM_READY, GP_READY
    XINPUT_READY, PS3_READY, DEV_DISCONNECT, DBG_DATA, K_DATA, M_DATA, GP_DATA
    CMD_SUSPEND, CMD_RESUME, CMD_RESET
'------------------------------------------------------------------------------
' The CMD_* tokens are asynchronous USB commands available to the user, through
' the Spin2 usbCommand method of this object. This method will post the cmd
' token to the host and when the cmd is complete the host will post the CMD_*
' token to byte[0] of the event long. Byte[1] is typically set to one of the
' below protocol error codes, with bytes[2..3] available for additional cmd data.
'------------------------------------------------------------------------------
' Protocol error codes:
    #0, ERR_NONE, ERR_CMD, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY
    ERR_XFER_RETRY, ERR_NAK, ERR_DATAX_SYNC, ERR_CONFIG_FAIL, ERR_TIMEOUT
'------------------------------------------------------------------------------
' Keyboard LED output report toggle key bit postions:
    #0, LED_NUMLKB, LED_CAPSLKB, LED_SCRLKB, LED_COMPOSEB
    LED_KANAB, LED_CONST0B, LED_CONST1B, LED_CONST2B
' Keyboard LED output report toggle key bitflags:
    LED_NUMLKF   = decod(LED_NUMLKB)
    LED_CAPSLKF  = decod(LED_CAPSLKB)
    LED_SCRLKF   = decod(LED_SCRLKB)
    LED_COMPOSEF = decod(LED_COMPOSEB)
    LED_KANAF    = decod(LED_KANAB)
    LED_CONST0F  = decod(LED_CONST0B)
    LED_CONST1F  = decod(LED_CONST1B)
    LED_CONST2F  = decod(LED_CONST2B)
' Keyboard modifier key bit positions:
    #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
    RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
' Keyboard modifier bitflags
    LEFT_CTRLF   = decod(LEFT_CTRLB)
    LEFT_SHIFTF  = decod(LEFT_SHIFTB)
    LEFT_ALTF    = decod(LEFT_ALTB)
    LEFT_GUIF    = decod(LEFT_GUIB)
    RIGHT_CTRLF  = decod(RIGHT_CTRLB)
    RIGHT_SHIFTF = decod(RIGHT_SHIFTB)
    RIGHT_ALTF   = decod(RIGHT_ALTB)
    RIGHT_GUIF   = decod(RIGHT_GUIB)
' Consolidated left/right modkeys. Add the modifier keys you want to trap
' together, then add the key scan code e.g. CTRL+ALT+"X" would be: $600 + KEY_X_x.
' The key() Spin2 method does this and the rawKey() method returns the key data
' as packed by the USB keyboard driver.
'   SHIFT = $100
'   CTRL  = $200
'   ALT   = $400
'   APP   = $800
' L|R key modifier flag combinations:
    KEYS_APP   = LEFT_GUIF + RIGHT_GUIF
    KEYS_ALT   = LEFT_ALTF + RIGHT_ALTF
    KEYS_CTRL  = LEFT_CTRLF + RIGHT_CTRLF
    KEYS_SHIFT = LEFT_SHIFTF + RIGHT_SHIFTF

CON ' USB Host constants
'------------------------------------------------------------------------------
    _1thou         = 1_000
    _1m            = 1_000_000
    _1b            = 1_000_000_000
    _12m           = 12_000_000
    LSBTns         = 672.0                  ' Low-Speed bit period, in nanoseconds
    FSBTns         = 83.54                  ' Full-Speed bit period, in nanoseconds
    LSBTns4        = round(LSBTns * 4.0)    ' Low-Speed inter-packet delay, in nanoseconds
    LSBTns22       = round(LSBTns * 22.0)   ' Low-Speed turnaround wait time, in nanoseconds
    FSBTns4        = round(FSBTns * 4.0)    ' Full-Speed inter-packet delay, in nanoseconds
    FSBTns28       = round(FSBTns * 28.0)   ' Full-Speed turnaround wait time, in nanoseconds
' NCO baud calculations for low-speed/full-speed:
'        _1_5Mbps  = round(1_500_000.0 / _FCLKFREQ * 65536.0)  ' = NCO 492 @200MHz, 614 @160
'        _12Mbps   = round(12_000_000.0 / _FCLKFREQ * 65536.0) ' = NCO 3932 @200MHz, 4915 @160
' To configure RevA silicon LS/FS NCO baud: (WXPIN _1_5Mbps, D-) or (WXPIN _12Mbps, D-)
' To configure RevA LS/FS host/device: WRPIN appropriate LS/FS mode to D- (lower) and D+ (upper) pins:
    USB_V1HMODE_LS = %1_11000_0 + 1 << 16   ' Host mode
    USB_V1DMODE_LS = %1_11010_0 + 1 << 16   ' Device mode
    USB_V1HMODE_FS = %1_11001_0 + 1 << 16
    USB_V1DMODE_FS = %1_11011_0 + 1 << 16
' On RevB+ the USB smart pin mode is set to the D- and D+ pins via (WRPIN USBMode, pin#):
    USB_V2_DRVOUT  = %1_11011_0 + 1 << 16
    USB_V2_SNIFF   = %0_11011_0 + 1 << 16   ' Disable output to create a USB "sniffer"
' To configure NCO baud, host/device for LS/FS, set the appropriate mode to the D- pin# (WXPIN NCOMode, D-)
'   USB_H_LS_NCO   = %10 << 14 + _1_5Mbps   ' Host mode at NCO baud
'   USB_D_LS_NCO   = %00 << 14 + _1_5Mbps   ' Device mode at NCO baud
'   USB_H_FS_NCO   = %11 << 14 + _12Mbps
'   USB_D_FS_NCO   = %01 << 14 + _12Mbps
'------------------------------------------------------------------------------
' Time delays and intervals
' Useful USB constants and wait intervals:
    XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
    TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
    NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
    IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
    OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
' Standard Device request maximum timeout periods (reference):
{
    TO_STANDARD  = _1ms * 5000              ' Non-specific maximum timout period
    TO_DATA      = _1ms * 500               ' Standard Device requests with a data stage
    TO_NODATA    = _1ms * 50                ' Standard Device requests without a data stage
    TO_SETADDR   = _1ms * 50                ' Device SetAddress() command processing maximum
    TO_CHGADDR   = _1ms * 2                 ' Device SetAddress() period allowed to change its address before next request sent
}
'------------------------------------------------------------------------------
' Token packet format.
'------------------------------------------------------------------------------
'                   CRC5  ENDP ADDRESS PID
    CRC_MASK     = %11111_0000_0000000_00000000
    EP_MASK      = %00000_1111_0000000_00000000
    ADDR_MASK    = %00000_0000_1111111_00000000
    EP_ADDR_MASK = %00000_1111_1111111_11111111
    EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
'------------------------------------------------------------------------------
' Packet Identifier Bytes (PID). Notice that the first two LSBits are
' identical for each group.
'------------------------------------------------------------------------------
' Token:
    PID_OUT   = %1110_0001                  ' $e1
    PID_IN    = %0110_1001                  ' $69
    PID_SOF   = %1010_0101                  ' $a5
    PID_SETUP = %0010_1101                  ' $2d
' Data:
    PID_DATA0 = %1100_0011                  ' $c3
    PID_DATA1 = %0100_1011                  ' $4b
    PID_DATA2 = %1000_0111                  ' $87
    PID_MDATA = %0000_1111                  ' $0f
' Handshake:
    PID_ACK   = %1101_0010                  ' $d2
    PID_NAK   = %0101_1010                  ' $5a
    PID_STALL = %0001_1110                  ' $1e
    PID_NYET  = %1001_0110                  ' $96
' Special:
    PID_PRE   = %0011_1100                  ' $3c
    PID_ERR   = %0011_1100                  ' $3c
    PID_SPLIT = %0111_1000                  ' $78
    PID_PING  = %1011_0100                  ' $b4
    PID_RESVD = %1111_0000                  ' $f0
' Tx, rx and host related constants
' USB transmitter WYPIN D line state options:
    OUT_IDLE = 0
    OUT_SE0  = 1
    OUT_K    = 2
    OUT_J    = 3
    OUT_EOP  = 4
    OUT_SOP  = $80
' USB receiver RDPIN status bit positions:
    #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
' USB receiver RDPIN status bitflags:
    J_IDLEF    = decod(J_IDLEB)
    K_RESUMEF  = decod(K_RESUMEB)
    SE0_RESETF = decod(SE0_RESETB)
    SE1_BADF   = decod(SE1_BADB)
    SOPF       = decod(SOPB)
    EOPF       = decod(EOPB)
    BUS_ERRF   = decod(BUS_ERRB)
    BYTE_TGLF  = decod(BYTE_TGLB)
' USB CRC constants:
    USB5_POLY      = %0_0101 rev (5 - 1)    ' USB5 polynomial is reflected when calculating CRC
    USB5_RESIDUAL  = %0_1100 rev (5 - 1)    ' Expected CRC5 residual value when checking received data
    USB16_POLY     = $8005 rev (16 - 1)     ' USB16 polynomial is reflected when calculating CRC
    USB16_RESIDUAL = $800d rev (16 - 1)     ' Expected CRC16 residual value when checking received data
' Host->class driver USB connect speed:
    #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
    #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB[4], DWNSTRM_HUBB, SUSPENDB
' Host status bitflags. Unless otherwise noted, bit states are active high:
    IDLEF        = decod(IDLEB)             ' Set when USB in idle state
    CONNECTEDF   = decod(CONNECTEDB)        ' USB device connected
    LOW_SPEEDF   = decod(LOW_SPEEDB)        ' Low-speed device connected, clear if full-speed
    DATAx_TGLF   = decod(DATAx_TGLB)        ' Cleared if sending DATA0 packet, set if sending DATA1 packet
'   EOPF         = decod(EOPB)              ' Same bit position as the USB rx RDPIN status constants defined above
'   BUS_ERRF     = decod(BUS_ERRB)          ' Same bit position as the USB rx RDPIN status constants defined above
'   BYTE_TGLF    = decod(BYTE_TGLB)         ' Same bit position as the USB rx RDPIN status constants defined above
    DWNSTRM_HUBF = decod(DWNSTRM_HUBB)      ' NYI: downstream hub(s) connected
    SUSPENDF     = decod(SUSPENDB)          ' NYI: command the host to signal a global suspend
'------------------------------------------------------------------------------
' Keyboard and mouse constants:
'------------------------------------------------------------------------------
' Keyboard interrupt endpoint poll interval and auto-repeat timing. Since the
' interrupt IN transactions are executed on a timed basis, use that to
' calculate auto-repeat initial delay and repeat rate.
'------------------------------------------------------------------------------
'    KBD_POLL_INTERVAL = _1ms * 8            ' Interrupt IN txn timespan
    KBD_REPEAT_DELAY  = 62                  ' 62 * 8ms = 496ms initial delay
    KBD_REPEAT_RATE   = 10                  ' 10 * 8ms = 80ms repeat rate
'------------------------------------------------------------------------------
' P2 silicon revision detection:
'------------------------------------------------------------------------------
    #1, P2RevA, P2RevB
'------------------------------------------------------------------------------

CON ' USB Descriptor Definitions
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
'------------------------------------------------------------------------------
' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
' Use TYPE_STANDARD for all USB Standard Device Request codes.
'------------------------------------------------------------------------------
' D7 Data direction  | D6:5 Type    | D4:0 Recipient
'------------------------------------------------------------------------------
' 0 - Host-to-device | 0 = Standard | 0 = Device
' 1 - Device-to-host | 1 = Class    | 1 = Interface
'                    | 2 = Vendor   | 2 = Endpoint
'                    | 3 = Reserved | 3 = Other
'                    |              | 4 -31 = Reserved
'------------------------------------------------------------------------------
    DIR_HOST_TO_DEV = 0 << 7
    DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
    TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
    TYPE_CLASS      = %01 << 5
    TYPE_VENDOR     = %10 << 5
    TYPE_RESERVED   = %11 << 5
    RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
    RECIP_INTERFACE = %0_0001
    RECIP_ENDPOINT  = %0_0010
    RECIP_OTHER     = %0_0011
'    RECIP 4 - 31 = Reserved
'------------------------------------------------------------------------------
' Standard Device Request codes (Section 9.4, Table 9-4):
'------------------------------------------------------------------------------
    #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
    REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
    REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
'------------------------------------------------------------------------------
' Standard descriptor types (Section 9.4, Table 9-5):
'------------------------------------------------------------------------------
    #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
    TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
'------------------------------------------------------------------------------
' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
'------------------------------------------------------------------------------
    #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
    CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
    CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
    CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
    CLASS_DIAGNOSTIC_DEV  = $dc
    CLASS_WIRELESS_CTRL   = $e0
    CLASS_MISCELLANEOUS   = $ef
    CLASS_APP_SPECIFIC    = $fe
    CLASS_VENDOR_SPECIFIC = $ff
'------------------------------------------------------------------------------
' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
'------------------------------------------------------------------------------
    #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
    HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
' HID Descriptor types:
    #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
'------------------------------------------------------------------------------
' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
'------------------------------------------------------------------------------
    #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
'------------------------------------------------------------------------------
' HID Interface SubClasses:
'------------------------------------------------------------------------------
    #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
'------------------------------------------------------------------------------
' HID Protocol codes:
'------------------------------------------------------------------------------
    #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
    #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
'------------------------------------------------------------------------------
' Other HID buffer lengths:
'------------------------------------------------------------------------------
    MAX_HID_REPTS   = 4             ' We have this many HID report buffers
    REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
    REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
    LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
    USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
'------------------------------------------------------------------------------
' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
'------------------------------------------------------------------------------
    LANG_ENG_US  = $0409            ' English (United States)
    LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
'------------------------------------------------------------------------------
' SETUP structure member offsets.
' NOTE: These offsets are defined in terms of the structure member's data type,
'       to take advantage of PTRA/B scaled indexing, e.g.:
'         RDBYTE D,   PTRA[bRequest]
'         WRWORD D/#, PTRA[wLength]
'------------------------------------------------------------------------------
    bmRequestType = 0
    bRequest      = 1
    wValue        = 1
    wIndex        = 2
    wLength       = 3
' SETUP bmRequestType combinations:
{
    HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
    DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
    HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
    HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
}
'------------------------------------------------------------------------------
' Standard USB descriptor structure sizes in bytes. The values defined are the
' minimum size of the descriptor:
'------------------------------------------------------------------------------
    SETUP_TXN_LEN = 8
    DEV_DESC_LEN  = 18
    CON_DESC_LEN  = 9
    INTF_DESC_LEN = 9
    ENDP_DESC_LEN = 7
    STR0_DESC_LEN = 4
    USTR_DESC_LEN = 4
'------------------------------------------------------------------------------
' Other USB-related buffer sizes:
'------------------------------------------------------------------------------
    URX_BUFF_LEN = 128      ' USB receiver scratch buffer
    CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
'------------------------------------------------------------------------------
' CON_bmAttrs member bit positions:
'------------------------------------------------------------------------------
    ATTR_RESVB     = 7      ' Reserved (should always be one)
    ATTR_SELF_PWRB = 6      ' Device Self-Powered
    ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
'    bmAttributes bits 4..0 reserved and reset to zero
'------------------------------------------------------------------------------
' Standard USB descriptor struct member offset and member size, in bytes. Note
' that the DESC_bLength and DESC_bDescType members are defined in all of the
' descriptors (including HID) at the offsets shown.
'------------------+
' !!! IMPORTANT !!!|
'------------------+
' All standard descriptor member offsets are defined in bytes, so if you want
' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
'       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
' If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
' must be very careful...
'------------------------------------------------------------------------------
'       Member          Offset  Size    Value           Description
'------------------------------------------------------------------------------
    DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
    DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
' Device Descriptor (Section 9.6.1, Table 9-8):
    DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
    DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
    DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
    DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
    DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
    DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
    DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
    DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
    DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
    DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
    DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
    DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
  ' Configuration Descriptor (Section 9.6.3, Table 9-10):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
    CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
    CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
    CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
    CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
    CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
    CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
' Interface Descriptor (Section 9.6.5, Table 9-12):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
    INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
    INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
    INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
    INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
    INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
                            '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
                            '                       reserved for assignment by the USB-IF.
    INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
                            '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
                            '                       vendor-specific protocol for this interface.
    INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
' Endpoint Descriptor (Section 9.6.6, Table 9-13):
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
    ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
    ENDP_bmAttrs     = 3    ' 1     Bitmap
    ENDP_wMaxPktSize = 4    ' 2     Number
    ENDP_bInterval   = 6    ' 1     Number
' String Descriptor Zero (Section 9.6.7, Table 9-15):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
' Unicode String Descriptor (Section 9.6.7, Table 9-16):
'    DESC_bLength     = 0    ' 1     N + 2
'    DESC_bDescType   = 1    ' 1     Constant
    USTR_wString     = 2    ' N     wString[(N - 2) / 2]
'------------------------------------------------------------------------------
' HID Descriptor (Section 6.2.1)
'------------------------------------------------------------------------------
'    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'    DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
    HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
    HID_bCountryCode = 4    ' 1     Number          Hardware target country
    HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
    HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
    HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).

' HID Report Items from HID 1.11 Section 6.2.2
    HID_USAGE_PAGE      = $04
    HID_USAGE           = $08
    HID_COLLECTION      = $A0
    HID_END_COLLECTION  = $C0
    HID_REPORT_COUNT    = $94
    HID_REPORT_SIZE     = $74
    HID_USAGE_MIN       = $18
    HID_USAGE_MAX       = $28
    HID_LOGICAL_MIN     = $14
    HID_LOGICAL_MAX     = $24
    HID_PHYSICAL_MIN    = $34
    HID_PHYSICAL_MAX    = $44
    HID_INPUT           = $80
    HID_REPORT_ID       = $84
    HID_OUTPUT          = $90

' HID Report Usage Pages from HID Usage Tables 1.12 Section 3, Table 1
    HID_USAGE_PAGE_GENERIC_DESKTOP = $01
    HID_USAGE_PAGE_KEY_CODES       = $07
    HID_USAGE_PAGE_LEDS            = $08
    HID_USAGE_PAGE_BUTTONS         = $09

' HID Report Usages from HID Usage Tables 1.12 Section 4, Table 6
    HID_USAGE_POINTER   = $01
    HID_USAGE_MOUSE     = $02
    HID_USAGE_JOYSTICK  = $04
    HID_USAGE_GAMEPAD   = $05
    HID_USAGE_KEYBOARD  = $06
    HID_USAGE_X         = $30
    HID_USAGE_Y         = $31
    HID_USAGE_Z         = $32
    HID_USAGE_RX        = $33
    HID_USAGE_RY        = $34
    HID_USAGE_RZ        = $35
    HID_USAGE_SLIDER    = $36
    HID_USAGE_WHEEL     = $38
    HID_USAGE_HATSWITCH = $39

' HID Report Collection Types from HID 1.12 6.2.2.6
    HID_COLLECTION_PHYSICAL    = 0
    HID_COLLECTION_APPLICATION = 1

' HID Input/Output/Feature Item Data (attributes) from HID 1.11 6.2.2.5
    HID_ITEM_CONSTANT = $1
    HID_ITEM_VARIABLE = $2
    HID_ITEM_RELATIVE = $4

' Keyboard report data buffer lengths (boot protocol):
    KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
    KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size
' Gamepad report and descriptor data buffer lengths:
    HID_IN_RPT_LEN   = 256
    HID_DESCR_LEN    = 256

' Gamepad axes flag bits
    HID_AXIS_X   = 16+0
    HID_AXIS_Y   = 16+1
    HID_AXIS_Z   = 16+2
    HID_AXIS_RX  = 16+3
    HID_AXIS_RY  = 16+4
    HID_AXIS_RZ  = 16+5

DAT             ' CGA
                org     $000

video_driver
                setcmod #%01_0_000_1            ' enable colorspace conversion
                '                  ^------------- horizontal polarity (1=negative, 0=positive)
                setcy   ##CGA_INTENSITY << 24   ' r      set colorspace for rgb
                setci   ##CGA_INTENSITY << 16   ' g
                setcq   ##CGA_INTENSITY << 08   ' b
                setxfrq cga_xf                  ' set transfer frequency

                cogid   pa                      ' insert cogid into dac modes
                setnib  cga_dacmode_s, pa, #2
                setnib  cga_dacmode_c, pa, #2

                wrpin   cga_dacmode_s, cga_pin_base ' enable 123-ohm 3.3V dac mode in pin +0

                xor     cga_pin_base, #2 << 6 | 1   ' enable 75-ohm 2.0V dac mode in pins +1..3
                wrpin   cga_dacmode_c, cga_pin_base

                xor     cga_pin_base, #3 << 6 ^ (2 << 6 | 1) ' make pins +0..3 outputs
                drvl    cga_pin_base

                xor     cga_pin_base, #4 | (3 << 6) ' leave av_base pointing to pin +4 (vertical sync)
                drvl    cga_pin_base                ' vertical polarity (drvh=negative, drvl=positive)

.frame_loop
                rdbyte  cga_03D8, #@cga_io_03D8 ' Mode Select Register
                rdbyte  cga_03D9, #@cga_io_03D9 ' Color Select Register

                testb   cga_03D8, #CGA_MODE_ENABLE  wz
        if_x0   setword cga_flags, #cga_blank, #0
        if_x0   jmp     #.end_config

                testb   cga_03D8, #CGA_MODE_GRAPH   wz
        if_x0   jmp     #.text_mode

                getnib  cga_lut0, cga_03D9, #0
                altd    cga_lut0, #cga_palette
                wrlut   0-0, #0 ' Background

                testb   cga_03D8, #CGA_MODE_640     wz
        if_x1   jmp     #.graphics_640x200

                testb   cga_03D9, #CGA_COLOR_BLUE   wz
        if_x0   mov     cga_lut1, cga_palette + %0010 ' Green
        if_x0   mov     cga_lut2, cga_palette + %0100 ' Red
        if_x0   mov     cga_lut3, cga_palette + %0110 ' Brown
        if_x1   mov     cga_lut1, cga_palette + %0011 ' Light Cyan
        if_x1   mov     cga_lut2, cga_palette + %0101 ' Light Magenta
        if_x1   mov     cga_lut3, cga_palette + %0111 ' High Intensity White
                testb   cga_03D8, #CGA_MODE_CBURST  wz
        if_x1   mov     cga_lut1, cga_palette + %0011 ' Light Cyan
        if_x1   mov     cga_lut2, cga_palette + %0100 ' Light Red
        if_x1   mov     cga_lut3, cga_palette + %0111 ' High Intensity White

                testb   cga_03D9, #CGA_COLOR_HIGH   wz
        if_x1   add     cga_lut1, #%1000
        if_x1   add     cga_lut2, #%1000
        if_x1   add     cga_lut3, #%1000
                wrlut   cga_lut1, #1
                wrlut   cga_lut2, #2
                wrlut   cga_lut3, #3

                setword cga_flags, #cga_graphics_320x200, #0

                jmp     #.end_config

.graphics_640x200
                testb   cga_03D9, #CGA_COLOR_HIGH   wz
        if_x0   wrlut   cga_palette + %0111, #1 ' White
        if_x1   wrlut   cga_palette + %1111, #1 ' White

                setword cga_flags, #cga_graphics_640x200, #0

                jmp     #.end_config

.text_mode
                rdbyte  cga_mc6845_10, #@cga_io_mc6845 + 10 ' cursor start scanline
                rdbyte  cga_mc6845_11, #@cga_io_mc6845 + 11 ' cursor end scanline

                testb   cga_03D8, #CGA_MODE_80COL   wz
        if_x0   setword cga_flags, #cga_text_40x25, #0
        if_x1   setword cga_flags, #cga_text_80x25, #0

.end_config
                incmod  cga_bcnt, #32       wc
        if_c    bitnot  cga_flags, #CGA_BLINK1_ON

                testb   cga_mc6845_10, #5   wz
        if_x0   incmod  cga_ccnt, #16 - 1   wc
        if_x1   incmod  cga_ccnt, #32 - 1   wc
        if_c    bitnot  cga_flags, #CGA_BLINK2_ON

                testb   cga_mc6845_10, #6   wc
        if_01   bitl    cga_flags, #CGA_BLINK2_ON
        if_10   bitl    cga_flags, #CGA_BLINK2_ON

                and     cga_mc6845_10, #%000_11111
                and     cga_mc6845_11, #%000_11111

                rdword  cga_ramptr, #@cga_io_mc6845 + 12 ' start of displayed page
                movbyts cga_ramptr, #%%3301
                and     cga_ramptr, ##%00_111111_11111111
                add     cga_ramptr, cga_ram_p

                rdword  cga_cpos, #@cga_io_mc6845 + 14  ' cursor offset address in vid mem
                movbyts cga_cpos, #%%3301
                and     cga_cpos, ##%00_111111_11111111

                mov     cga_cptr, #0
                mov     cga_lcnt, #200

.line_loop
                bith    cga_flags, #CGA_CURSOR_SCANLINE
                cmp     cga_lofs, cga_mc6845_10 wcz
        if_b    bitl    cga_flags, #CGA_CURSOR_SCANLINE
                cmp     cga_lofs, cga_mc6845_11 wcz
        if_a    bitl    cga_flags, #CGA_CURSOR_SCANLINE

                call    cga_flags
                djnz    cga_lcnt, #.line_loop

                bith    cga_03DA, #3
                wrbyte  cga_03DA, #@cga_io_03DA
                callpa  #12, #.blank                ' front porch

                drvnot  cga_pin_base                ' vertical sync on
                callpa  #2, #.blank
                drvnot  cga_pin_base                ' vertical sync off

                callpa  #35, #.blank                ' back porch
                bitl    cga_03DA, #3
                wrbyte  cga_03DA, #@cga_io_03DA

                jmp     #.frame_loop

.blank
                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_db, #0                  ' do visible part of scan line
        _ret_   djnz    pa, #.blank                 ' loop if more blanks needed

' Blank Screen

cga_blank
                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_db, #0                  ' do visible part of scan line

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
        _ret_   xcont   cga_db, #0                  ' do visible part of scan line

' Text 80x25

cga_text_80x25
                call    #cga_emit_line80
                sub     cga_cptr, #80
                call    #cga_emit_line80
                sub     cga_cptr, #80

                add     cga_chr_p, #1

                incmod  cga_lofs, #8 - 1   wc
        if_c    add     cga_cptr, #80
        if_c    add     cga_ramptr, #80 * 2
        if_c    sub     cga_chr_p, #8

                ret

cga_emit_line80
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #80 / 4
.loop
                mov     cga_lut0, #%0000_00000
                mov     cga_lut1, #%0000_00001
                setnib  cga_dv8, #%0000, #4

                rep     @.reploop, #4

                rfword  cga_chattr

                getbyte cga_tmp0, cga_chattr, #0
                shl     cga_tmp0, #3
                add     cga_tmp0, cga_chr_p
                rdbyte  cga_bmp, cga_tmp0
                rev     cga_bmp
                shr     cga_bmp, #24

                bitl    cga_chattr, #15             wcz
                testb   cga_flags, #CGA_BLINK1_ON   andc
        if_c    mov     cga_bmp, #0

                cmp     cga_cptr, cga_cpos              wz
                testb   cga_flags, #CGA_BLINK2_ON       andz
                testb   cga_flags, #CGA_CURSOR_SCANLINE andz
        if_z    or      cga_bmp, #%11111111

                getnib  cga_tmp0, cga_chattr, #3    ' background
                altd    cga_tmp0, #cga_palette      '
                wrlut   0 - 0, cga_lut0             '
                getnib  cga_tmp0, cga_chattr, #2    ' foreground
                altd    cga_tmp0, #cga_palette      '
                wrlut   0 - 0, cga_lut1    '
                xcont   cga_dv8, cga_bmp

                add     cga_cptr, #1
                add     cga_lut0, #%0001_00000
                add     cga_lut1, #%0001_00000
                add     cga_dv8, ##$1_0000
.reploop
        _ret_   djnz    pa, #.loop

' Text 40x25

cga_text_40x25
                call    #cga_emit_line40
                sub     cga_cptr, #40
                call    #cga_emit_line40
                sub     cga_cptr, #40

                add     cga_chr_p, #1

                incmod  cga_lofs, #8 - 1    wc
        if_c    add     cga_cptr, #40
        if_c    add     cga_ramptr, #40 * 2
        if_c    sub     cga_chr_p, #8

                ret

cga_emit_line40
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #40 / 4
.loop
                mov     cga_lut0, #%0000_00000
                mov     cga_lut1, #%0000_00001
                setnib  cga_dv16, #%0000, #4

                rep     @.reploop, #4

                rfword  cga_chattr

                getbyte cga_tmp0, cga_chattr, #0
                shl     cga_tmp0, #3
                add     cga_tmp0, cga_chr_p
                rdbyte  cga_bmp, cga_tmp0
                rev     cga_bmp
                shr     cga_bmp, #24

                bitl    cga_chattr, #15             wcz
                testb   cga_flags, #CGA_BLINK1_ON   andc
        if_c    mov     cga_bmp, #0

                cmp     cga_cptr, cga_cpos              wz
                testb   cga_flags, #CGA_BLINK2_ON       andz
                testb   cga_flags, #CGA_CURSOR_SCANLINE andz
        if_z    or      cga_bmp, #%11111111

                setword cga_bmp, cga_bmp, #1
                mergew  cga_bmp

                getnib  cga_tmp0, cga_chattr, #3    ' background
                altd    cga_tmp0, #cga_palette      '
                wrlut   0-0, cga_lut0               '
                getnib  cga_tmp0, cga_chattr, #2    ' foreground
                altd    cga_tmp0, #cga_palette      '
                wrlut   0-0, cga_lut1               '
                xcont   cga_dv16, cga_bmp

                add     cga_cptr, #1
                add     cga_lut0, #%0001_00000
                add     cga_lut1, #%0001_00000
                add     cga_dv16, ##$1_0000
.reploop
        _ret_   djnz    pa, #.loop

' Graphics 320x200x2bpp

cga_graphics_320x200
                mov     pb, #2
.loop2
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #320 / 4
.loop1
                rfbyte  cga_tmp0
                testb   cga_tmp0, #7  wc
                testb   cga_tmp0, #6  wz
                muxc    cga_bmp, cga_muxc00
                muxz    cga_bmp, cga_muxz00

                testb   cga_tmp0, #5  wc
                testb   cga_tmp0, #4  wz
                muxc    cga_bmp, cga_muxc11
                muxz    cga_bmp, cga_muxz11

                testb   cga_tmp0, #3  wc
                testb   cga_tmp0, #2  wz
                muxc    cga_bmp, cga_muxc22
                muxz    cga_bmp, cga_muxz22

                testb   cga_tmp0, #1  wc
                testb   cga_tmp0, #0  wz
                muxc    cga_bmp, cga_muxc33
                muxz    cga_bmp, cga_muxz33

                xcont   cga_dv8b, cga_bmp
                djnz    pa, #.loop1

                djnz    pb, #.loop2

        _ret_   add     cga_ramptr, #320 / 4

cga_muxc00      long    %0000__0000__0000__1010
cga_muxz00      long    %0000__0000__0000__0101
cga_muxc11      long    %0000__0000__1010__0000
cga_muxz11      long    %0000__0000__0101__0000
cga_muxc22      long    %0000__1010__0000__0000
cga_muxz22      long    %0000__0101__0000__0000
cga_muxc33      long    %1010__0000__0000__0000
cga_muxz33      long    %0101__0000__0000__0000

' Graphics 640x200x1bpp

cga_graphics_640x200
                mov     pb, #2
.loop2
                rdfast  #0, cga_ramptr

                bith    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA
                xcont   cga_bs, #0                  ' do before-sync part of scan line
                xcont   cga_ds, #1                  ' do sync part of scan line
                xcont   cga_as, #0                  ' do before-visible part of scan line
                bitl    cga_03DA, #0
                wrbyte  cga_03DA, #@cga_io_03DA

                mov     pa, #640 / 8
.loop1
                rfbyte  cga_bmp
                rev     cga_bmp
                shr     cga_bmp, #24
                xcont   cga_dv8, cga_bmp
                djnz    pa, #.loop1

                djnz    pb, #.loop2

        _ret_   add     cga_ramptr, #640 / 8

cga_reg_p       long    0
cga_ram_p       long    @ram_00000 + RAM_SIZE
cga_chr_p       long    @cga_charrom

cga_03D8        long    0
cga_03D9        long    0
cga_03DA        long    0

cga_mc6845_10   long    0
cga_mc6845_11   long    0

cga_palette
                                    ' h rgb
                long    $000000_00  ' 0 000     0
                long    $0000AA_00  ' 0 001     1
                long    $00AA00_00  ' 0 010     2
                long    $00AAAA_00  ' 0 011     3
                long    $AA0000_00  ' 0 100     4
                long    $AA00AA_00  ' 0 101     5
                long    $AA5500_00  ' 0 110     6
                long    $AAAAAA_00  ' 0 111     7
                long    $555555_00  ' 1 000     8
                long    $5555FF_00  ' 1 001     9
                long    $55FF55_00  ' 1 010     A
                long    $55FFFF_00  ' 1 011     B
                long    $FF5555_00  ' 1 100     C
                long    $FF55FF_00  ' 1 101     D
                long    $FFFF55_00  ' 1 110     E
                long    $FFFFFF_00  ' 1 111     F

cga_pin_base    long    VGA_PIN & $38                    ' base pin
cga_dacmode_s   long    P_DAC_124R_3V + P_CHANNEL        ' hsync is 123-ohm, 3.3V
cga_dacmode_c   long    P_DAC_75R_2V + P_CHANNEL         ' R/G/B are 75-ohm, 2.0V

cga_xf          long    (CGA_FPIX frac _CLKFREQ) >> 1           ' streamer frequency setting
cga_bs          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  16 ' streamer command: before-sync
cga_ds          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  96 ' streamer command: during-sync
cga_as          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 +  48 ' streamer command: after sync
cga_db          long    X_IMM_1X32_4DAC8 | X_DACS_3_2_1_0 + 640 ' streamer command: during-blank

cga_dv8         long    X_IMM_32X1_LUT | X_DACS_3_2_1_0 | %0000 << 16 + 8 ' streamer command: during visible
cga_dv8b        long    X_IMM_16X2_LUT | X_DACS_3_2_1_0 | %0000 << 16 + 8 ' streamer command: during visible
cga_dv16        long    X_IMM_32X1_LUT | X_DACS_3_2_1_0 | %0000 << 16 + 16 ' streamer command: during visible

cga_cpos        long    0               ' cursor position (from MC6845)
cga_flags       long    cga_blank       ' 31..20 flags
                                        '  19..0 line handler routine

cga_cptr        long    0
cga_ramptr      long    0

cga_chattr      long    0
cga_bmp         long    0
cga_lut0        long    0
cga_lut1        long    0
cga_lut2        long    0
cga_lut3        long    0

cga_bcnt        long    0
cga_ccnt        long    0
cga_lcnt        long    0
cga_lofs        long    0

cga_tmp0        res     1

CON ' CGA constants

    CGA_FPIX = 25_175_000
    CGA_INTENSITY = 80      '0..128

    CGA_BLINK1_ON = 31
    CGA_BLINK2_ON = 30
    CGA_CURSOR_SCANLINE = 29

    CGA_MODE_80COL  = 0
    CGA_MODE_GRAPH  = 1
    CGA_MODE_CBURST = 2
    CGA_MODE_ENABLE = 3
    CGA_MODE_640    = 4
    CGA_MODE_BLINK  = 5

    CGA_COLOR_BG    = %00_001111
    CGA_COLOR_HIGH  = 4
    CGA_COLOR_BLUE  = 5

DAT             ' 8086
                org     $000

i8086
                add     ptrb, ##@i8086_lut - @i8086
                setq2   #(@i8086_lut_end - @i8086_lut) / 4 -1
                rdlong  0, ptrb

                call    #\@@system_init

                mov     i_optable, ##@@i8086_optable
                getct   i_lastwait

.nextop
                getct   i_total
                sub     i_total, i_lastwait

                'add     i_total, i_cycles
                bitl    i_flags, #I_SEG_BIT

                call    #\@@i_run_interrupts

                bitl    i_flags, #I_NO_INT_BIT  wcz
                testb   i_flags, #I_TF_BIT      wz
        if_01   mov     i_temp0, #1
        if_01   call    #\@@i_trap

                getct   i_lastwait
                mov     i_cycles, #0
                getword i_ip_start, i_ip, #0

.loop
                call    #\i_readcodeb
                mov     i_opcode, i_tmpb

                cmp     i_opcode, #$26      wz
        if_ne   cmp     i_opcode, #$2E      wz
        if_ne   cmp     i_opcode, #$36      wz
        if_ne   cmp     i_opcode, #$3E      wz
        if_e    jmp     #.seg

                cmp     i_opcode, #$F2      wz
        if_ne   cmp     i_opcode, #$F3      wz
        if_e    jmp     #.rep

                shl     i_tmpb, #2
                add     i_tmpb, i_optable
                rdlong  i_opimpl, i_tmpb

                bitl    i_flags, #I_REP_BIT wcz
        if_11   call    #.rep_valid
        if_11   jmp     #.repeat

                push    #.nextop
                jmp     i_opimpl

.seg
                cmp     i_opcode, #$26      wz
        if_e    mov     i_override, i_es
                cmp     i_opcode, #$2E      wz
        if_e    mov     i_override, i_cs
                cmp     i_opcode, #$36      wz
        if_e    mov     i_override, i_ss
                cmp     i_opcode, #$3E      wz
        if_e    mov     i_override, i_ds
                bith    i_flags, #I_SEG_BIT
                add     i_cycles, #2
                jmp     #.loop

.rep
                bith    i_flags, #I_REP_BIT

                testb   i_opcode, #0        wz
                bitz    i_flags, #I_REP_ZF_BIT

                add     i_cycles, #2
                jmp     #.loop

.rep_valid
                cmp     i_opcode, #$A4        wz
        if_ne   cmp     i_opcode, #$A5        wz
        if_ne   cmp     i_opcode, #$AA        wz
        if_ne   cmp     i_opcode, #$AB        wz
        if_ne   cmp     i_opcode, #$AC        wz
        if_ne   cmp     i_opcode, #$AD        wz
        if_ne   cmp     i_opcode, #$A6        wz
        if_ne   cmp     i_opcode, #$A7        wz
        if_ne   cmp     i_opcode, #$AE        wz
        if_ne   cmp     i_opcode, #$AF        wz
                ret

.repeat
                cmp     i_cx, #0            wz
        if_z    jmp     #.nextop

                call    i_opimpl
                sub     i_cx, #1

                cmp     i_opcode, #$A4      wz
        if_ne   cmp     i_opcode, #$A5      wz
        if_ne   cmp     i_opcode, #$AA      wz
        if_ne   cmp     i_opcode, #$AB      wz
        if_ne   cmp     i_opcode, #$AC      wz
        if_ne   cmp     i_opcode, #$AD      wz
        if_e    jmp     #.repeat

                testb   i_flags, #I_REP_ZF_BIT  wc
                testb   i_flags, #I_ZF_BIT      wz
    if_c_eq_z   jmp     #.repeat

                jmp     #.nextop

i_esc_op
                ' fall-through
i_readcodeb
                getword i_ea, i_cs, #0
                shl     i_ea, #4
                add     i_ea, i_ip
                incmod  i_ip, i_ffffh
                jmp     #\i_readmemb

i_readimmb
                call    #\i_readcodeb
        _ret_   getbyte i_data, i_tmpb, #0

i_readimmw
                call    #\i_readcodeb
                getbyte i_data, i_tmpb, #0
                call    #\i_readcodeb
        _ret_   setbyte i_data, i_tmpb, #1

' +-----+---------------+------------------+-------------------+---------+---------+
' | mod |      00       |       01         |        10         |   11    |         |
' +-----+---------------+------------------+-------------------+---------+---------+
' | r/m |               |                  |                   |         |   reg   |
' +-----+---------------+------------------+-------------------+---------+----+----+
' | 000 | [DS:BX+SI]    | [DS:BX+SI+disp8] | [DS:BX+SI+disp16] | [DS:AX] | AL | AX |
' | 001 | [DS:BX+DI]    | [DS:BX+DI+disp8] | [DS:BX+DI+disp16] | [DS:CX] | CL | CX |
' | 010 | [SS:BP+SI]    | [SS:BP+SI+disp8] | [SS:BP+SI+disp16] | [DS:DX] | DL | DX |
' | 011 | [SS:BP+DI]    | [SS:BP+DI+disp8] | [SS:BP+DI+disp16] | [DS:BX] | BL | BX |
' | 100 | [DS:SI]       | [DS:SI+disp8]    | [DS:SI+disp16]    | [DS:SP] | AH | SP |
' | 101 | [DS:DI]       | [DS:DI+disp8]    | [DS:DI+disp16]    | [DS:BP] | CH | BP |
' | 110 | [DS:disp16]   | [SS:BP+disp8]    | [SS:BP+disp16]    | [DS:SI] | DH | SI |
' | 111 | [DS:BX]       | [DS:BX+disp8]    | [DS:BX+disp16]    | [DS:DI] | BH | DI |
' +-----+---------------+------------------+-------------------+---------+----+----+

'   setup i_ea based on i_modrm bits

i_setupmodrm
                call    #\i_readcodeb
                mov     i_modrm, i_tmpb
i_setupmodrm2
                getword i_segment, i_ds, #0
                mov     i_offset, #0
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
                mov     i_modrm0, i_modrm
                and     i_modrm0, #%00_000_111
        if_00   call    #\_mod00
        if_01   call    #\_mod01
        if_10   call    #\_mod10
        if_11   call    #\_mod11
        _ret_   getword i_offset, i_offset, #0

i_setupea
                add     i_cycles, #2
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_segment, #0
                shl     i_ea, #4
        _ret_   add     i_ea, i_offset

_mod00
                altgw   i_modrm0, #i_modrm_00
                getword i_modrm0
                jmp     i_modrm0
_mod01
                add     i_cycles, #4
                call    #\i_readcodeb
                signx   i_tmpb, #7
                add     i_offset, i_tmpb
                jmp     #_modxx
_mod10
                add     i_cycles, #4
                call    #\i_readcodeb
                getbyte i_temp0, i_tmpb, #0
                call    #\i_readcodeb
                setbyte i_temp0, i_tmpb, #1
                add     i_offset, i_temp0
_modxx
                altgw   i_modrm0, #i_modrm_xx
                getword i_modrm0
                jmp     i_modrm0
_mod11
                jmprel  i_modrm0
        _ret_   getword i_offset, i_ax, #0
        _ret_   getword i_offset, i_cx, #0
        _ret_   getword i_offset, i_dx, #0
        _ret_   getword i_offset, i_bx, #0
        _ret_   getword i_offset, i_sp, #0
        _ret_   getword i_offset, i_bp, #0
        _ret_   getword i_offset, i_si, #0
        _ret_   getword i_offset, i_di, #0

i_modrm_00      word    i_modrm_00_xxx_000, i_modrm_00_xxx_001, i_modrm_00_xxx_010, i_modrm_00_xxx_011
                word    i_modrm_00_xxx_100, i_modrm_00_xxx_101, i_modrm_00_xxx_110, i_modrm_00_xxx_111

i_modrm_xx      word    i_modrm_00_xxx_000, i_modrm_00_xxx_001, i_modrm_00_xxx_010, i_modrm_00_xxx_011
                word    i_modrm_00_xxx_100, i_modrm_00_xxx_101, i_modrm_xx_xxx_110, i_modrm_00_xxx_111

i_modrm_00_xxx_000
                add     i_cycles, #7
                add     i_offset, i_bx
        _ret_   add     i_offset, i_si
i_modrm_00_xxx_001
                add     i_cycles, #8
                add     i_offset, i_bx
        _ret_   add     i_offset, i_di
i_modrm_00_xxx_010
                add     i_cycles, #8
                getword i_segment, i_ss, #0
                add     i_offset, i_bp
        _ret_   add     i_offset, i_si
i_modrm_00_xxx_011
                add     i_cycles, #7
                getword i_segment, i_ss, #0
                add     i_offset, i_bp
        _ret_   add     i_offset, i_di
i_modrm_00_xxx_100
                add     i_cycles, #5
        _ret_   add     i_offset, i_si
i_modrm_00_xxx_101
                add     i_cycles, #5
        _ret_   add     i_offset, i_di
i_modrm_00_xxx_110
                add     i_cycles, #6 + 4
                call    #\i_readcodeb
                getbyte i_temp0, i_tmpb, #0
                call    #\i_readcodeb
                setbyte i_temp0, i_tmpb, #1
        _ret_   add     i_offset, i_temp0
i_modrm_00_xxx_111
                add     i_cycles, #5
        _ret_   add     i_offset, i_bx

i_modrm_xx_xxx_110
                add     i_cycles, #5
                getword i_segment, i_ss, #0
        _ret_   add     i_offset, i_bp

' get 8-bit register based on i_modrm bits 5..3

i_getmodr8
                mov     pa, i_modrm
                shr     pa, #3
i_getr8
                and     pa, #7
                jmprel  pa
        _ret_   getbyte i_data, i_ax, #0
        _ret_   getbyte i_data, i_cx, #0
        _ret_   getbyte i_data, i_dx, #0
        _ret_   getbyte i_data, i_bx, #0
        _ret_   getbyte i_data, i_ax, #1
        _ret_   getbyte i_data, i_cx, #1
        _ret_   getbyte i_data, i_dx, #1
        _ret_   getbyte i_data, i_bx, #1

' get 16-bit register based on i_modrm bits 5..3

i_getmodr16
                mov     pa, i_modrm
                shr     pa, #3
i_getr16
                and     pa, #7
                jmprel  pa
        _ret_   getword i_data, i_ax, #0
        _ret_   getword i_data, i_cx, #0
        _ret_   getword i_data, i_dx, #0
        _ret_   getword i_data, i_bx, #0
        _ret_   getword i_data, i_sp, #0
        _ret_   getword i_data, i_bp, #0
        _ret_   getword i_data, i_si, #0
        _ret_   getword i_data, i_di, #0


' set 8-bit register based on i_modrm bits 5..3

i_setmodr8
                mov     pa, i_modrm
                shr     pa, #3
i_setr8
                and     pa, #7
                jmprel  pa
        _ret_   setbyte i_ax, i_data, #0
        _ret_   setbyte i_cx, i_data, #0
        _ret_   setbyte i_dx, i_data, #0
        _ret_   setbyte i_bx, i_data, #0
        _ret_   setbyte i_ax, i_data, #1
        _ret_   setbyte i_cx, i_data, #1
        _ret_   setbyte i_dx, i_data, #1
        _ret_   setbyte i_bx, i_data, #1

' set 16-bit register based on i_modrm bits 5..3

i_setmodr16
                mov     pa, i_modrm
                shr     pa, #3
i_setr16
                and     pa, #7
                jmprel  pa
        _ret_   getword i_ax, i_data, #0
        _ret_   getword i_cx, i_data, #0
        _ret_   getword i_dx, i_data, #0
        _ret_   getword i_bx, i_data, #0
        _ret_   getword i_sp, i_data, #0
        _ret_   getword i_bp, i_data, #0
        _ret_   getword i_si, i_data, #0
        _ret_   getword i_di, i_data, #0

' get segment register based on i_modrm bits 5..3

i_getmodsreg
                mov     pa, i_modrm
i_getsreg
                shr     pa, #3
                and     pa, #3
                jmprel  pa
        _ret_   getword i_data, i_es, #0
        _ret_   getword i_data, i_cs, #0
        _ret_   getword i_data, i_ss, #0
        _ret_   getword i_data, i_ds, #0

' set segment register based on i_modrm bits 5..3

i_setmodsreg
                mov     pa, i_modrm
i_setsreg
                shr     pa, #3
                and     pa, #3
                jmprel  pa
        _ret_   getword i_es, i_data, #0
        _ret_   getword i_cs, i_data, #0
        _ret_   getword i_ss, i_data, #0
        _ret_   getword i_ds, i_data, #0

' --------------------------------------------------------------------

i_readopb
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_getr8
                call    #\i_setupea
                jmp     #\i_readb

i_writeopb
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_setr8
                call    #\i_setupea
                jmp     #\i_writeb

' --------------------------------------------------------------------

i_readopw
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_getr16
                call    #\i_setupea
                jmp     #\i_readw

i_writeopw
                testb   i_modrm, #7         wc
                testb   i_modrm, #6         wz
        if_11   mov     pa, i_modrm
        if_11   jmp     #\i_setr16
                call    #\i_setupea
                jmp     #\i_writew

' --------------------------------------------------------------------

i_readb
                add     i_cycles, #4
                call    #\i_readmemb
        _ret_   getbyte i_data, i_tmpb, #0

i_writeb
                add     i_cycles, #4
                getbyte i_tmpb, i_data, #0
                jmp     #\i_writememb

i_readw
                add     i_cycles, #4
                testb   i_ea, #0            wc
        if_c    add     i_cycles, #4
                call    #\i_readmemb
                getbyte i_data, i_tmpb, #0
                add     i_ea, #1
                call    #\i_readmemb
                setbyte i_data, i_tmpb, #1
        _ret_   add     i_ea, #1

i_writew
                add     i_cycles, #4
                testb   i_ea, #0            wc
        if_c    add     i_cycles, #4
                getbyte i_tmpb, i_data, #0
                call    #\i_writememb
                add     i_ea, #1
                getbyte i_tmpb, i_data, #1
                jmp     #\i_writememb

' --------------------------------------------------------------------

i_add_flags16
                testb   i_data0, #15        wc      ' (resultDst ^ resultSrc)
                testb   i_data1, #15        xorc    ' |
                testb   i_data1, #15        wz      ' (resultSrc ^ resultArith)
                testb   i_data, #15         xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                testb   i_data0, #15        xorz    ' (resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith)))
                bitz    i_flags, #I_CF_BIT
i_add_flags16_nc
                testb   i_data0, #15        wc      ' (resultDst ^ resultArith)
                testb   i_data, #15         xorc    ' |
                testb   i_data1, #15        wz      ' (resultSrc ^ resultArith)
                testb   i_data, #15         xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                bitz    i_flags, #I_OF_BIT

                testb   i_data0, #4         wz
                testb   i_data1, #4         xorz
                testb   i_data, #4          xorz
                bitz    i_flags, #I_AF_BIT

                test    i_data, #$FF        wcz
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, i_ffffh     wcz
        _ret_   bitz    i_flags, #I_ZF_BIT

i_sub_flags16
                testb   i_data, #15         wc      ' (resultDst ^ resultSrc)
                testb   i_data1, #15        xorc    ' |
                testb   i_data1, #15        wz      ' (resultSrc ^ resultArith)
                testb   i_data0, #15        xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                testb   i_data, #15         xorz    ' (resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith)))
                bitz    i_flags, #I_CF_BIT
i_sub_flags16_nc
                testb   i_data, #15         wc      ' (resultDst ^ resultArith)
                testb   i_data0, #15        xorc    ' |
                testb   i_data1, #15        wz      ' (resultSrc ^ resultArith)
                testb   i_data0, #15        xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                bitz    i_flags, #I_OF_BIT

                testb   i_data0, #4         wz
                testb   i_data1, #4         xorz
                testb   i_data, #4          xorz
                bitz    i_flags, #I_AF_BIT

                test    i_data, #$FF        wcz
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, i_ffffh     wcz
        _ret_   bitz    i_flags, #I_ZF_BIT

i_add_flags8
                testb   i_data0, #7         wc      ' (resultDst ^ resultSrc)
                testb   i_data1, #7         xorc    ' |
                testb   i_data1, #7         wz      ' (resultSrc ^ resultArith)
                testb   i_data, #7          xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                testb   i_data0, #7         xorz    ' (resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith)))
                bitz    i_flags, #I_CF_BIT
i_add_flags8_nc
                testb   i_data0, #7         wc      ' (resultDst ^ resultArith)
                testb   i_data, #7          xorc    ' |
                testb   i_data1, #7         wz      ' (resultSrc ^ resultArith)
                testb   i_data, #7          xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                bitz    i_flags, #I_OF_BIT

                testb   i_data0, #4         wz
                testb   i_data1, #4         xorz
                testb   i_data, #4          xorz
                bitz    i_flags, #I_AF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_sub_flags8
                testb   i_data, #7          wc      ' (resultDst ^ resultSrc)
                testb   i_data1, #7         xorc    ' |
                testb   i_data1, #7         wz      ' (resultSrc ^ resultArith)
                testb   i_data0, #7         xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                testb   i_data, #7          xorz    ' (resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith)))
                bitz    i_flags, #I_CF_BIT
i_sub_flags8_nc
                testb   i_data, #7          wc      ' (resultDst ^ resultArith)
                testb   i_data0, #7         xorc    ' |
                testb   i_data1, #7         wz      ' (resultSrc ^ resultArith)
                testb   i_data0, #7         xorz    ' |
                modz    _c_and_z            wz      ' ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))
                bitz    i_flags, #I_OF_BIT

                testb   i_data0, #4         wz
                testb   i_data1, #4         xorz
                testb   i_data, #4          xorz
                bitz    i_flags, #I_AF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_logic_flags8
                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_logic_flags16
                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT

                test    i_data, #$FF        wcz
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT
                and     i_data, i_ffffh     wcz
        _ret_   bitz    i_flags, #I_ZF_BIT

' --------------------------------------------------------------------

i_ax            long    $0000
i_bx            long    $0000
i_cx            long    $0000
i_dx            long    $0000

i_sp            long    $0000
i_bp            long    $0000
i_si            long    $0000
i_di            long    $0000

i_cs            long    $F000
i_ds            long    $0000
i_es            long    $0000
i_ss            long    $0000

i_flags         long    $0000
i_flags_pre     long    $F002
i_ip            long    $FFF0

i_cycles        long    0
i_total         long    0

i_3fffh         long    $3FFF
i_ffffh         long    $FFFF
i_eamask        long    $FFFFF
i_optable       long    @i8086_optable

i_rambase       long    @ram_00000
i_cgabase       long    @ram_00000 + RAM_SIZE

ppi             long    %00000000_00000000_00000000_00000000
                '        |||||||| |||||||| |||||||| ||||||||
                '        |||||||| |||||||| |||||||| ++++++++-- I=KB. Scancode / O=Diagnostic
                '        |||||||| |||||||| |||||||+----------- Timer 2 Gate Speaker
                '        |||||||| |||||||| ||||||+------------ Speaker Data
                '        |||||||| |||||||| |||||+------------- Spare
                '        |||||||| |||||||| ||||+-------------- Read High / Low switched
                '        |||||||| |||||||| |||+--------------- 0=Enable RAM parity check
                '        |||||||| |||||||| ||+---------------- 0=Enable I/O channel check
                '        |||||||| |||||||| |+----------------- 0=Hold keyboard clock low
                '        |||||||| |||||||| +------------------ 0=Enable keyboard, 1=Clear keyboard
                '        |||||||| ||||++++-------------------- Switches
                '        |||||||| |||+------------------------ Spare
                '        |||||||| ||+------------------------- Timer channel 2 out
                '        |||||||| |+-------------------------- 1=I/O channel check
                '        |||||||| +--------------------------- 1=Ram parity check
                '        ++++++++----------------------------- CONTROL

pic_icw         long    %00000000_00000000_00000000_00000000
                '        |||||||| |||||||| |||||||| ||||||||
                '        |||||||| |||||||| |||||||| ++++++++-- ICW1
                '        |||||||| |||||||| ++++++++----------- ICW2
                '        |||||||| ++++++++-------------------- ICW3
                '        ++++++++----------------------------- ICW4

pic_ocw         long    %00000000_00000000_00000000_00000000
                '        |||      |||||||| |||||||| ||||||||
                '        |||      |||||||| |||||||| ++++++++--   7..0: OCW1 (IMR)
                '        |||      |||||||| ++++++++-----------  15..8: OCW2
                '        |||      ++++++++-------------------- 23..16: OCW3
                '        ||+---------------------------------      29: ICW2 received
                '        |+-----------------------------------     30: ICW3 received
                '        +------------------------------------     31: ICW4 received

pic_irq         long    %00000000_00000000_00000000_00000000
                '        |    |||          |||||||| ||||||||
                '        |    |||          |||||||| ++++++++--   7..0: IRR
                '        |    |||          ++++++++-----------  15..8: ISR
                '        |    +++----------------------------- 26..24:  # served
                '        +------------------------------------     31: IS

i_opcode        res     1
i_modrm         res     1
i_modrm0        res     1

i_override      res     1
i_segment       res     1
i_offset        res     1
i_ea            res     1

i_tmpb          res     1
i_data          res     1
i_data0         res     1
i_data1         res     1

i_temp0         res     1
i_temp1         res     1
i_temp2         res     1
i_opimpl        res     1
i_rep_cnt       res     1
i_ip_start      res     1
i_lastwait      res     1

DAT             ' 8086 LUT
                org     $200
i8086_lut

i_readmemb
                ' i_ea   = address
                ' i_tmpb = data
                and     i_ea, i_eamask
                mov     i_tmpb, #$FF
                mov     pa, i_ea
                shr     pa, #12             ' get 4k-bank number
                                            ' 00000
                cmp     pa, #$40        wcz ' 3FFFF ram (256k)
        if_b    jmp     #.ram
                cmp     pa, #$B8        wcz ' B8000
        if_b    ret     wcz                 ' |
                cmp     pa, #$BC        wcz ' BBFFF video ram (16k)
        if_b    jmp     #.cga
                cmp     pa, #$FE        wcz ' FE000
        if_ae   jmp     #.rom               ' FFFFF rom (8k)
                ret     wcz
.ram
                mov     pa, i_ea
                add     pa, i_rambase
                rdbyte  i_tmpb, pa
                ret     wcz
.cga
                mov     pb, i_ea
                and     pb, i_3fffh
                add     pb, i_cgabase
                rdbyte  i_tmpb, pb
                ret     wcz
.rom
                mov     pa, i_ea
                sub     pa, ##$FE000
                add     pa, ##@rom_FE000
                rdbyte  i_tmpb, pa
                ret     wcz

i_writememb
                ' i_ea   = address
                ' i_tmpb = data
                and     i_ea, i_eamask
                mov     pa, i_ea
                shr     pa, #12             ' get 4k-bank number
                                            ' 00000
                cmp     pa, #$40        wcz ' 3FFFF ram (256k)
        if_b    jmp     #.ram
                cmp     pa, #$B8        wcz ' B8000
        if_b    ret     wcz                 ' |
                cmp     pa, #$BC        wcz ' BBFFF video ram (16k)
        if_b    jmp     #.cga
                ret     wcz
.ram
                mov     pa, i_ea
                add     pa, i_rambase
                wrbyte  i_tmpb, pa
                ret     wcz
.cga
                mov     pb, i_ea
                and     pb, i_3fffh
                add     pb, i_cgabase
                wrbyte  i_tmpb, pb
                ret     wcz

i_readiob
                ' i_ea   = address
                ' i_tmpb = data
                mov     i_tmpb, #$FF

.wl1            locktry #0              wc
        if_nc   jmp     #.wl1
                push    ##@@.ret

                cmp     i_ea, #$0F      wcz
        if_be   jmp     #dma_rd

                cmp     i_ea, #$20      wcz
        if_e    jmp     #\pic_20_rd
                cmp     i_ea, #$21      wcz
        if_e    jmp     #\pic_21_rd

                cmp     i_ea, #$40      wcz
        if_e    jmp     #\pit_40_rd
                cmp     i_ea, #$41      wcz
        if_e    jmp     #\pit_41_rd

                cmp     i_ea, #$60      wcz
        if_e    jmp     #\ppi_60_rd
                cmp     i_ea, #$61      wcz
        if_e    getbyte i_tmpb, ppi, #PPI_PB_BYTE
                cmp     i_ea, #$62      wcz
        if_e    jmp     #ppi_62_rd
                cmp     i_ea, #$63      wcz
        if_e    getbyte i_tmpb, ppi, #PPI_CTL_BYTE

                cmp     i_ea, ##$03DA   wcz
        if_e    rdbyte  i_tmpb, #@cga_io_03DA

                ret     wcz

.ret
        _ret_   lockrel #0

i_writeiob
                ' i_ea   = address
                ' i_tmpb = data

.wl1            locktry #0              wc
        if_nc   jmp     #.wl1
                push    ##@@.ret

                cmp     i_ea, #$0F      wcz
        if_be   jmp     #dma_wr

                cmp     i_ea, #$20      wcz
        if_e    jmp     #\pic_20_wr
                cmp     i_ea, #$21      wcz
        if_e    jmp     #\pic_21_wr

                cmp     i_ea, #$40      wcz
        if_e    jmp     #\pit_40_wr
                cmp     i_ea, #$41      wcz
        if_e    jmp     #\pit_41_wr
                cmp     i_ea, #$43      wcz
        if_e    jmp     #\pit_43_wr

                cmp     i_ea, #$60      wcz
        if_e    setbyte ppi, i_tmpb, #PPI_PA_BYTE
                cmp     i_ea, #$61      wcz
        if_e    jmp     #ppi_61_wr
                cmp     i_ea, #$62      wcz
        if_e    setbyte ppi, i_tmpb, #PPI_PC_BYTE
                cmp     i_ea, #$63      wcz
        if_e    setbyte ppi, i_tmpb, #PPI_CTL_BYTE

                cmp     i_ea, ##$03D4   wcz
        if_e    wrbyte  i_tmpb, #@cga_io_03D4
                cmp     i_ea, ##$03D5   wcz
        if_e    jmp     #\cga_03D5_wr
                cmp     i_ea, ##$03D8   wcz
        if_e    wrbyte  i_tmpb, #@cga_io_03D8
                cmp     i_ea, ##$03D9   wcz
        if_e    wrbyte  i_tmpb, #@cga_io_03D9
                cmp     i_ea, ##$03DA   wcz
        if_e    wrbyte  i_tmpb, #@cga_io_03DA

                ret     wcz

.ret
        _ret_   lockrel #0

i8086_lut_end

DAT             ' 8086 HUB
                orgh

i8086_optable
                long    @@i_math_modrm_r8       ' 00 rm                 add [rm], r8
                long    @@i_math_modrm_r16      ' 01 rm                 add [rm], r16
                long    @@i_math_r8_modrm       ' 02 rm                 add r16, [rm]
                long    @@i_math_r16_modrm      ' 03 rm                 add r8, [rm]
                long    @@i_math_al_imm8        ' 04 nn                 add al, nn
                long    @@i_math_ax_imm16       ' 05 ll hh              add ax, hhll
                long    @@i_push_sreg           ' 06                    push es
                long    @@i_pop_sreg            ' 07                    pop es
                long    @@i_math_modrm_r8       ' 08 rm                 or  [rm], r8
                long    @@i_math_modrm_r16      ' 09 rm                 or  [rm], r16
                long    @@i_math_r8_modrm       ' 0A rm                 or  r16, [rm]
                long    @@i_math_r16_modrm      ' 0B rm                 or  r8, [rm]
                long    @@i_math_al_imm8        ' 0C nn                 or  al, nn
                long    @@i_math_ax_imm16       ' 0D ll hh              or  ax, hhll
                long    @@i_push_sreg           ' 0E                    push cs
                long    @@i_pop_sreg            ' 0F                    pop cs

                long    @@i_math_modrm_r8       ' 10 rm                 adc [rm], r8
                long    @@i_math_modrm_r16      ' 11 rm                 adc [rm], r16
                long    @@i_math_r8_modrm       ' 12 rm                 adc r16, [rm]
                long    @@i_math_r16_modrm      ' 13 rm                 adc r8, [rm]
                long    @@i_math_al_imm8        ' 14 nn                 adc al, nn
                long    @@i_math_ax_imm16       ' 15 ll hh              adc ax, hhll
                long    @@i_push_sreg           ' 16                    push ss
                long    @@i_pop_sreg            ' 17                    pop ss
                long    @@i_math_modrm_r8       ' 18 rm                 sbb [rm], r8
                long    @@i_math_modrm_r16      ' 19 rm                 sbb [rm], r16
                long    @@i_math_r8_modrm       ' 1A rm                 sbb r16, [rm]
                long    @@i_math_r16_modrm      ' 1B rm                 sbb r8, [rm]
                long    @@i_math_al_imm8        ' 1C nn                 sbb al, nn
                long    @@i_math_ax_imm16       ' 1D ll hh              sbb ax, hhll
                long    @@i_push_sreg           ' 1E                    push ds
                long    @@i_pop_sreg            ' 1F                    pop ds

                long    @@i_math_modrm_r8       ' 20 rm                 and [rm], r8
                long    @@i_math_modrm_r16      ' 21 rm                 and [rm], r16
                long    @@i_math_r8_modrm       ' 22 rm                 and r16, [rm]
                long    @@i_math_r16_modrm      ' 23 rm                 and r8, [rm]
                long    @@i_math_al_imm8        ' 24 nn                 and al, nn
                long    @@i_math_ax_imm16       ' 25 ll hh              and ax, hhll
                long    @@i_hlt                 ' 26                    es:
                long    @@i_daas                ' 27                    daa
                long    @@i_math_modrm_r8       ' 28 rm                 sub [rm], r8
                long    @@i_math_modrm_r16      ' 29 rm                 sub [rm], r16
                long    @@i_math_r8_modrm       ' 2A rm                 sub r16, [rm]
                long    @@i_math_r16_modrm      ' 2B rm                 sub r8, [rm]
                long    @@i_math_al_imm8        ' 2C nn                 sub al, nn
                long    @@i_math_ax_imm16       ' 2D ll hh              sub ax, hhll
                long    @@i_hlt                 ' 2E                    cs:
                long    @@i_daas                ' 2F                    das

                long    @@i_math_modrm_r8       ' 30 rm                 xor [rm], r8
                long    @@i_math_modrm_r16      ' 31 rm                 xor [rm], r16
                long    @@i_math_r8_modrm       ' 32 rm                 xor r16, [rm]
                long    @@i_math_r16_modrm      ' 33 rm                 xor r8, [rm]
                long    @@i_math_al_imm8        ' 34 nn                 xor al, nn
                long    @@i_math_ax_imm16       ' 35 ll hh              xor ax, hhll
                long    @@i_hlt                 ' 26                    ss:
                long    @@i_aaas                ' 37                    aaa
                long    @@i_math_modrm_r8       ' 38 rm                 cmp [rm], r8
                long    @@i_math_modrm_r16      ' 39 rm                 cmp [rm], r16
                long    @@i_math_r8_modrm       ' 3A rm                 cmp r16, [rm]
                long    @@i_math_r16_modrm      ' 3B rm                 cmp r8, [rm]
                long    @@i_math_al_imm8        ' 3C nn                 cmp al, nn
                long    @@i_math_ax_imm16       ' 3D ll hh              cmp ax, hhll
                long    @@i_hlt                 ' 3E                    ds:
                long    @@i_aaas                ' 3F                    aas

                long    @@i_inc16               ' 40                    inc ax
                long    @@i_inc16               ' 41                    inc cx
                long    @@i_inc16               ' 42                    inc dx
                long    @@i_inc16               ' 43                    inc bx
                long    @@i_inc16               ' 44                    inc sp
                long    @@i_inc16               ' 45                    inc bp
                long    @@i_inc16               ' 46                    inc si
                long    @@i_inc16               ' 47                    inc di
                long    @@i_dec16               ' 48                    dec ax
                long    @@i_dec16               ' 49                    dec cx
                long    @@i_dec16               ' 4A                    dec dx
                long    @@i_dec16               ' 4B                    dec bx
                long    @@i_dec16               ' 4C                    dec sp
                long    @@i_dec16               ' 4D                    dec bp
                long    @@i_dec16               ' 4E                    dec si
                long    @@i_dec16               ' 4F                    dec di

                long    @@i_push_r16            ' 50                    push ax
                long    @@i_push_r16            ' 51                    push cx
                long    @@i_push_r16            ' 52                    push dx
                long    @@i_push_r16            ' 53                    push bx
                long    @@i_push_r16            ' 54                    push sp
                long    @@i_push_r16            ' 55                    push bp
                long    @@i_push_r16            ' 56                    push si
                long    @@i_push_r16            ' 57                    push di
                long    @@i_pop_r16             ' 58                    pop ax
                long    @@i_pop_r16             ' 59                    pop cx
                long    @@i_pop_r16             ' 5A                    pop dx
                long    @@i_pop_r16             ' 5B                    pop bx
                long    @@i_pop_r16             ' 5C                    pop sp
                long    @@i_pop_r16             ' 5D                    pop bp
                long    @@i_pop_r16             ' 5E                    pop si
                long    @@i_pop_r16             ' 5F                    pop di

                long    @@i_jo                  ' 60 dd                 jo dd   60 - 6F are aliases to 70 - 7F
                long    @@i_jo                  ' 61 dd                 jno dd
                long    @@i_jc                  ' 62 dd                 jc dd
                long    @@i_jc                  ' 63 dd                 jnc dd
                long    @@i_jz                  ' 64 dd                 jz dd
                long    @@i_jz                  ' 65 dd                 jnz dd
                long    @@i_jce                 ' 66 dd                 jce dd
                long    @@i_jce                 ' 67 dd                 jnce dd
                long    @@i_js                  ' 68 dd                 js dd
                long    @@i_js                  ' 69 dd                 jns dd
                long    @@i_jp                  ' 6A dd                 jp dd
                long    @@i_jp                  ' 6B dd                 jnp dd
                long    @@i_jl                  ' 6C dd                 jl dd
                long    @@i_jnl                 ' 6D dd                 jnl dd
                long    @@i_jle                 ' 6E dd                 jle dd
                long    @@i_jnle                ' 6F dd                 jnle dd

                long    @@i_jo                  ' 70 dd                 jo dd   60 - 6F are aliases to 70 - 7F
                long    @@i_jo                  ' 71 dd                 jno dd
                long    @@i_jc                  ' 72 dd                 jc dd
                long    @@i_jc                  ' 73 dd                 jnc dd
                long    @@i_jz                  ' 74 dd                 jz dd
                long    @@i_jz                  ' 75 dd                 jnz dd
                long    @@i_jce                 ' 76 dd                 jce dd
                long    @@i_jce                 ' 77 dd                 jnce dd
                long    @@i_js                  ' 78 dd                 js dd
                long    @@i_js                  ' 79 dd                 jns dd
                long    @@i_jp                  ' 7A dd                 jp dd
                long    @@i_jp                  ' 7B dd                 jnp dd
                long    @@i_jl                  ' 7C dd                 jl dd
                long    @@i_jnl                 ' 7D dd                 jnl dd
                long    @@i_jle                 ' 7E dd                 jle dd
                long    @@i_jnle                ' 7F dd                 jnle dd

                long    @@i_math_imm8           ' 80 rm nn              add/or/adc/sbb/and/sub/xor/cmp [rm8], nn
                long    @@i_math_imm16          ' 81 rm ll hh           add/or/adc/sbb/and/sub/xor/cmp [rm16], hhll
                long    @@i_math_imm8s          ' 82 rm sn              add/or/adc/sbb/and/sub/xor/cmp [rm8], sn
                long    @@i_math_imm16s         ' 83 rm sn              add/or/adc/sbb/and/sub/xor/cmp [rm16], sn
                long    @@i_test_r8_modrm       ' 84 rm                 test r8, [mm]
                long    @@i_test_r16_modrm      ' 85 rm                 test r16, [mm]
                long    @@i_xchg_modrm8         ' 86 rm                 xchg r8, [mm]
                long    @@i_xchg_modrm16        ' 87 rm                 xchg r16, [mm]
                long    @@i_mov_modrm_r8        ' 88 rm                 mov [rm], r8
                long    @@i_mov_modrm_r16       ' 89 rm                 mov [rm], r16
                long    @@i_mov_r8_modrm        ' 8A rm                 mov r8, [rm]
                long    @@i_mov_r16_modrm       ' 8B rm                 mov r16, [rm]
                long    @@i_mov_modrm_sreg      ' 8C rm                 mov [rm], sreg
                long    @@i_lea                 ' 8D oo                 lea r16, oo
                long    @@i_mov_sreg_modrm      ' 8E rm                 mov sregs, [rm]
                long    @@i_pop_modrm           ' 8F mm                 pop [rm]

                long    @@i_xchg                ' 90                    xchg ax, cx
                long    @@i_xchg                ' 91                    xchg ax, cx
                long    @@i_xchg                ' 92                    xchg ax, dx
                long    @@i_xchg                ' 93                    xchg ax, bx
                long    @@i_xchg                ' 94                    xchg ax, sp
                long    @@i_xchg                ' 95                    xchg ax, bp
                long    @@i_xchg                ' 96                    xchg ax, si
                long    @@i_xchg                ' 97                    xchg ax, di
                long    @@i_cbw                 ' 98                    cbw
                long    @@i_cwd                 ' 99                    cwd
                long    @@i_call_far            ' 9A ol oh sl sh        call shsl:ohol
                long    @@i_wait                ' 9B                    wait
                long    @@i_pushf               ' 9C                    pushf
                long    @@i_popf                ' 9C                    popf
                long    @@i_sahf                ' 9E                    sahf
                long    @@i_lahf                ' 9F                    lahf

                long    @@i_mov_al_offs         ' A0 ol oh              mov al, [DS:ohol]
                long    @@i_mov_ax_offs         ' A1 ol oh              mov ax, [DS:ohol]
                long    @@i_mov_offs_al         ' A2 ol oh              mov [DS:ohol], al
                long    @@i_mov_offs_ax         ' A3 ol oh              mov [DS:ohol], ax
                long    @@i_movsb               ' A4                    movsb
                long    @@i_movsw               ' A5                    movsw
                long    @@i_cmpsb               ' A6                    cmpsb
                long    @@i_cmpsw               ' A7                    cmpsw
                long    @@i_test_al_imm         ' A8 nn                 test al, nn
                long    @@i_test_ax_imm         ' A9 ll hh              test ax, hhll
                long    @@i_stosb               ' AA                    stosb
                long    @@i_stosw               ' AB                    stosw
                long    @@i_lodsb               ' AC                    lodsb
                long    @@i_lodsw               ' AD                    lodsw
                long    @@i_scasb               ' AE                    scasb
                long    @@i_scasw               ' AF                    scasw

                long    @@i_mov_immb            ' B0 nn                 mov al, nn
                long    @@i_mov_immb            ' B1 nn                 mov cl, nn
                long    @@i_mov_immb            ' B2 nn                 mov dl, nn
                long    @@i_mov_immb            ' B3 nn                 mov bl, nn
                long    @@i_mov_immb            ' B4 nn                 mov ah, nn
                long    @@i_mov_immb            ' B5 nn                 mov ch, nn
                long    @@i_mov_immb            ' B6 nn                 mov dh, nn
                long    @@i_mov_immb            ' B7 nn                 mov bh, nn
                long    @@i_mov_immw            ' B8 ll hh              mov ax, hhll
                long    @@i_mov_immw            ' B9 ll hh              mov cx, hhll
                long    @@i_mov_immw            ' BA ll hh              mov dx, hhll
                long    @@i_mov_immw            ' BB ll hh              mov bx, hhll
                long    @@i_mov_immw            ' BC ll hh              mov sp, hhll
                long    @@i_mov_immw            ' BD ll hh              mov bp, hhll
                long    @@i_mov_immw            ' BE ll hh              mov si, hhll
                long    @@i_mov_immw            ' BF ll hh              mov di, hhll

                long    @@i_ret_near_sp         ' C0 dl dh              ret (SP+dhdl)
                long    @@i_ret_near            ' C1                    ret
                long    @@i_ret_near_sp         ' C2 dl dh              ret (SP+dhdl)
                long    @@i_ret_near            ' C3                    ret
                long    @@i_les                 ' C4 rm                 les [rm]
                long    @@i_lds                 ' C5 rm                 lds [rm]
                long    @@i_mov_modrm_imm8      ' C6 rm nn              mov byte [rm], nn
                long    @@i_mov_modrm_imm16     ' C7 rm ll hh           mov word [rm], hhll
                long    @@i_ret_far_sp          ' C8 dl dh              retf (SP+dhdl)
                long    @@i_ret_far             ' C9                    retf
                long    @@i_ret_far_sp          ' CA dl dh              retf (SP+dhdl)
                long    @@i_ret_far             ' CB                    retf
                long    @@i_int3                ' CC                    int3
                long    @@i_int                 ' CD                    int
                long    @@i_into                ' CE                    into
                long    @@i_iret                ' CF                    iret

                long    @@i_d0_prefix           ' D0 rm                 rol/ror/rolc/rorc/shl/shr/shra byte[rm]
                long    @@i_d1_prefix           ' D1 rm                 rol/ror/rolc/rorc/shl/shr/shraw word[rm]
                long    @@i_d2_prefix           ' D2 rm                 rol/ror/rolc/rorc/shl/shr/shrab byte[rm], cl
                long    @@i_d3_prefix           ' D3 rm                 rol/ror/rolc/rorc/shl/shr/shraw word[rm], cl
                long    @@i_aam                 ' D4                    aam
                long    @@i_aad                 ' D5                    aad
                long    @@i_salc                ' D6                    salc
                long    @@i_xlatb               ' D7                    xlatb
                long    i_esc_op                ' D8 rm                 esc rm
                long    i_esc_op                ' D9 rm                 esc rm
                long    i_esc_op                ' DA rm                 esc rm
                long    i_esc_op                ' DB rm                 esc rm
                long    i_esc_op                ' DC rm                 esc rm
                long    i_esc_op                ' DD rm                 esc rm
                long    i_esc_op                ' DE rm                 esc rm
                long    i_esc_op                ' DF rm                 esc rm

                long    @@i_loopne              ' E0 dd                 loopne dd
                long    @@i_loope               ' E1 dd                 loope dd
                long    @@i_loop                ' E2 dd                 loop dd
                long    @@i_jcxz                ' E3 dd                 jcxz dd
                long    @@i_in_al_imm           ' E4 pp                 in al, [pp]
                long    @@i_in_ax_imm           ' E5 pp                 in ax, [pp]
                long    @@i_out_imm_al          ' E6 pp                 out [pp], al
                long    @@i_out_imm_ax          ' E7 pp                 out [pp], ax
                long    @@i_call_displ          ' E8 dl dh              call +dhdl
                long    @@i_jmp_displ           ' E9 dl dh              jmp +dhdl
                long    @@i_jmp_far             ' EA ol oh sl sh        jmp shsl:ohol
                long    @@i_jmp_displ8          ' EB dd                 jmp +dd
                long    @@i_in_al_dx            ' EC pp                 in al, [dx]
                long    @@i_in_ax_dx            ' ED pp                 in ax, [dx]
                long    @@i_out_dx_al           ' EE pp                 out [dx], al
                long    @@i_out_dx_ax           ' EF pp                 out [dx], ax

                long    @@i_lock                ' F0                    lock
                long    @@i_lock                ' F1                    lock
                long    @@i_hlt                 ' F2                    repne
                long    @@i_hlt                 ' F3                    repe
                long    @@i_hlt                 ' F4                    hlt
                long    @@i_cmc                 ' F5                    cmc
                long    @@i_f6_prefix           ' F6 rm                 test/not/net/mul/imul/div/idiv [rm8]
                long    @@i_f7_prefix           ' F7 rm                 test/not/net/mul/imul/div/idiv [rm16]
                long    @@i_clc                 ' F8                    clc
                long    @@i_stc                 ' F9                    stc
                long    @@i_cli                 ' FA                    cli
                long    @@i_sti                 ' FB                    sti
                long    @@i_cld                 ' FC                    cld
                long    @@i_std                 ' FD                    std
                long    @@i_fe_prefix           ' FF rm                 inc/dec [rm]
                long    @@i_ff_prefix           ' FF rm                 inc/dec/call/call far/jmp/jmp far/push/cmp [rm]

i_hlt
                bith    i_flags, #I_HALT_BIT
        {_ret_}   decmod  i_ip, i_ffffh
                debug("**** i_hlt ****")
                debug(uhex_word(i_cs, i_ip))
                cogid   pa
                cogstop pa

'   add [modrm], r8
'   or  [modrm], r8
'   adc [modrm], r8
'   sbb [modrm], r8
'   and [modrm], r8
'   sub [modrm], r8
'   xor [modrm], r8
'   cmp [modrm], r8

i_math_modrm_r8
                call    #\i_setupmodrm
                call    #\i_getmodr8
                mov     i_data1, i_data
                call    #\i_readopb
                mov     i_data0, i_data
                mov     i_temp0, i_opcode
_do_modrm_op8
                and     i_temp0, #%00_111_000   wz
        if_z    jmp     #.add
                cmp     i_temp0, #%00_001_000   wz
        if_z    jmp     #.or
                cmp     i_temp0, #%00_010_000   wz
        if_z    jmp     #.adc
                cmp     i_temp0, #%00_011_000   wz
        if_z    jmp     #.sbb
                cmp     i_temp0, #%00_100_000   wz
        if_z    jmp     #.and
                cmp     i_temp0, #%00_101_000   wz
        if_z    jmp     #.sub
                cmp     i_temp0, #%00_110_000   wz
        if_z    jmp     #.xor
                cmp     i_temp0, #%00_111_000   wz
        if_z    jmp     #.cmp
                ret

.add
                add     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_add_flags8
.or
                or      i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_logic_flags8
.adc
                testb   i_flags, #I_CF_BIT      wc
                addx    i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_add_flags8
.sbb
                testb   i_flags, #I_CF_BIT      wc
                subx    i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_sub_flags8
.and
                and     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_logic_flags8
.sub
                sub     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_sub_flags8
.xor
                xor     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_logic_flags8
.cmp
                sub     i_data, i_data1
                jmp     #\i_sub_flags8

i_math_imm8s
                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data0, i_data
                call    #\i_readcodeb
                getbyte i_data1, i_tmpb, #0
                signx   i_data1, #7
                mov     i_temp0, i_modrm
                jmp     #_do_modrm_op8

i_math_imm8
                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data0, i_data
                call    #\i_readcodeb
                getbyte i_data1, i_tmpb, #0
                mov     i_temp0, i_modrm
                jmp     #_do_modrm_op8

' --------------------------------------------------------------------

'   add r8, [modrm]
'   or  r8, [modrm]
'   adc r8, [modrm]
'   sbb r8, [modrm]
'   and r8, [modrm]
'   sub r8, [modrm]
'   xor r8, [modrm]
'   cmp r8, [modrm]

i_math_al_imm8
                call    #\i_readimmb
                mov     i_data1, i_data
                mov     i_modrm, #%00_000_110
                skipf   #%111
i_math_r8_modrm
                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data1, i_data
                call    #\i_getmodr8
                mov     i_data0, i_data
                mov     i_temp0, i_opcode

                and     i_temp0, #%00_111_000   wz
        if_z    jmp     #.add
                cmp     i_temp0, #%00_001_000   wz
        if_z    jmp     #.or
                cmp     i_temp0, #%00_010_000   wz
        if_z    jmp     #.adc
                cmp     i_temp0, #%00_011_000   wz
        if_z    jmp     #.sbb
                cmp     i_temp0, #%00_100_000   wz
        if_z    jmp     #.and
                cmp     i_temp0, #%00_101_000   wz
        if_z    jmp     #.sub
                cmp     i_temp0, #%00_110_000   wz
        if_z    jmp     #.xor
                cmp     i_temp0, #%00_111_000   wz
        if_z    jmp     #.cmp
                ret

.add
                add     i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_add_flags8
.or
                or      i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_logic_flags8
.adc
                testb   i_flags, #I_CF_BIT      wc
                addx    i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_add_flags8
.sbb
                testb   i_flags, #I_CF_BIT      wc
                subx    i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_sub_flags8
.and
                and     i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_logic_flags8
.sub
                sub     i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_sub_flags8
.xor
                xor     i_data, i_data1
                call    #\i_setmodr8
                jmp     #\i_logic_flags8
.cmp
                sub     i_data, i_data1
                jmp     #\i_sub_flags8

i_test_r8_modrm
                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data1, i_data
                call    #\i_getmodr8
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags8

i_test_al_imm
                call    #\i_readimmb
                mov     i_data1, i_data
                getbyte i_data, i_ax, #0
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags8

' --------------------------------------------------------------------

'   add [modrm], r16
'   or  [modrm], r16
'   adc [modrm], r16
'   sbb [modrm], r16
'   and [modrm], r16
'   sub [modrm], r16
'   xor [modrm], r16
'   cmp [modrm], r16

i_math_modrm_r16
                call    #\i_setupmodrm
                call    #\i_getmodr16
                mov     i_data1, i_data
                call    #\i_readopw
                mov     i_data0, i_data
                mov     i_temp0, i_opcode
_do_modrm_op16
                and     i_temp0, #%00_111_000   wz
        if_z    jmp     #.add16
                cmp     i_temp0, #%00_001_000   wz
        if_z    jmp     #.or16
                cmp     i_temp0, #%00_010_000   wz
        if_z    jmp     #.adc16
                cmp     i_temp0, #%00_011_000   wz
        if_z    jmp     #.sbb16
                cmp     i_temp0, #%00_100_000   wz
        if_z    jmp     #.and16
                cmp     i_temp0, #%00_101_000   wz
        if_z    jmp     #.sub16
                cmp     i_temp0, #%00_110_000   wz
        if_z    jmp     #.xor16
                cmp     i_temp0, #%00_111_000   wz
        if_z    jmp     #.cmp16
                ret

.add16
                add     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_add_flags16
.or16
                or      i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_logic_flags16
.adc16
                testb   i_flags, #I_CF_BIT      wc
                addx    i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_add_flags16
.sbb16
                testb   i_flags, #I_CF_BIT      wc
                subx    i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_sub_flags16
.and16
                and     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_logic_flags16
.sub16
                sub     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_sub_flags16
.xor16
                xor     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_logic_flags16
.cmp16
                sub     i_data, i_data1
                jmp     #\i_sub_flags16

i_math_imm16s
                call    #\i_setupmodrm
                call    #\i_readopw
                mov     i_data0, i_data
                call    #\i_readcodeb
                getbyte i_data1, i_tmpb, #0
                signx   i_data1, #7
                mov     i_temp0, i_modrm
                jmp     #_do_modrm_op16

i_math_imm16
                call    #\i_setupmodrm
                call    #\i_readopw
                mov     i_data0, i_data
                call    #\i_readcodeb
                getbyte i_data1, i_tmpb, #0
                call    #\i_readcodeb
                setbyte i_data1, i_tmpb, #1
                mov     i_temp0, i_modrm
                jmp     #_do_modrm_op16

' --------------------------------------------------------------------

'   add r16, [modrm]
'   or  r16, [modrm]
'   adc r16, [modrm]
'   sbb r16, [modrm]
'   and r16, [modrm]
'   sub r16, [modrm]
'   xor r16, [modrm]
'   cmp r16, [modrm]

i_math_ax_imm16
                call    #\i_readimmw
                mov     i_data1, i_data
                mov     i_modrm, #%00_000_110
                skipf   #%111
i_math_r16_modrm
                call    #\i_setupmodrm
                call    #\i_readopw
                mov     i_data1, i_data
                call    #\i_getmodr16
                mov     i_data0, i_data
                mov     i_temp0, i_opcode

                and     i_temp0, #%00_111_000   wz
        if_z    jmp     #.add16
                cmp     i_temp0, #%00_001_000    wz
        if_z    jmp     #.or16
                cmp     i_temp0, #%00_010_000    wz
        if_z    jmp     #.adc16
                cmp     i_temp0, #%00_011_000    wz
        if_z    jmp     #.sbb16
                cmp     i_temp0, #%00_100_000    wz
        if_z    jmp     #.and16
                cmp     i_temp0, #%00_101_000    wz
        if_z    jmp     #.sub16
                cmp     i_temp0, #%00_110_000    wz
        if_z    jmp     #.xor16
                cmp     i_temp0, #%00_111_000    wz
        if_z    jmp     #.cmp16
                ret

.add16
                add     i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_add_flags16
.or16
                or      i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_logic_flags16
.adc16
                testb   i_flags, #I_CF_BIT      wc
                addx    i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_add_flags16
.sbb16
                testb   i_flags, #I_CF_BIT      wc
                subx    i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_sub_flags16
.and16
                and     i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_logic_flags16
.sub16
                sub     i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_sub_flags16
.xor16
                xor     i_data, i_data1
                call    #\i_setmodr16
                jmp     #\i_logic_flags16
.cmp16
                sub     i_data, i_data1
                jmp     #\i_sub_flags16

i_test_r16_modrm
                call    #\i_setupmodrm
                call    #\i_readopw
                mov     i_data1, i_data
                call    #\i_getmodr16
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags16

i_test_ax_imm
                call    #\i_readimmw
                mov     i_data1, i_data
                getword i_data, i_ax, #0
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags16

' --------------------------------------------------------------------

i_inc16
                mov     pa, i_opcode
                call    #\i_getr16
                mov     i_data0, i_data
                mov     i_data1, #1
                add     i_data, i_data1
                call    #\i_setr16
                jmp     #\i_add_flags16_nc

i_dec16
                mov     pa, i_opcode
                call    #\i_getr16
                mov     i_data0, i_data
                mov     i_data1, #1
                sub     i_data, i_data1
                call    #\i_setr16
                jmp     #\i_sub_flags16_nc

' --------------------------------------------------------------------

i_mov_modrm_sreg
                call    #\i_setupmodrm
                call    #\i_getmodsreg
                jmp     #\i_writeopw

i_mov_sreg_modrm
                call    #\i_setupmodrm
                call    #\i_readopw
                jmp     #\i_setmodsreg

i_mov_modrm_r16
                call    #\i_setupmodrm
                call    #\i_getmodr16
                jmp     #\i_writeopw

i_mov_r16_modrm
                call    #\i_setupmodrm
                call    #\i_readopw
                jmp     #\i_setmodr16

i_mov_modrm_r8
                call    #\i_setupmodrm
                call    #\i_getmodr8
                jmp     #\i_writeopb

i_mov_r8_modrm
                call    #\i_setupmodrm
                call    #\i_readopb
                jmp     #\i_setmodr8

i_mov_immb
                call    #\i_readimmb
                mov     pa, i_opcode
                jmp     #\i_setr8

i_mov_immw
                call    #\i_readimmw
                mov     pa, i_opcode
                jmp     #\i_setr16

i_mov_al_offs
                mov     i_modrm, #%00_000_110
                call    #\i_setupmodrm2
                call    #\i_readopb
                jmp     #\i_setmodr8

i_mov_ax_offs
                mov     i_modrm, #%00_000_110
                call    #\i_setupmodrm2
                call    #\i_readopw
                jmp     #\i_setmodr16

i_mov_offs_al
                mov     i_modrm, #%00_000_110
                call    #\i_setupmodrm2
                call    #\i_getmodr8
                jmp     #\i_writeopb

i_mov_offs_ax
                mov     i_modrm, #%00_000_110
                call    #\i_setupmodrm2
                call    #\i_getmodr16
                jmp     #\i_writeopw

i_mov_modrm_imm8
                call    #\i_setupmodrm
                call    #\i_readimmb
                jmp     #\i_writeopb

i_mov_modrm_imm16
                call    #\i_setupmodrm
                call    #\i_readimmw
                jmp     #\i_writeopw

' --------------------------------------------------------------------

i_push
                decmod  i_sp, i_ffffh
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                getbyte i_tmpb, i_data, #1
                call    #\i_writememb
                decmod  i_sp, i_ffffh
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                getbyte i_tmpb, i_data, #0
                jmp     #\i_writememb

i_pop
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                call    #\i_readmemb
                getbyte i_data, i_tmpb, #0
                incmod  i_sp, i_ffffh
                getword i_ea, i_ss, #0
                shl     i_ea, #4
                add     i_ea, i_sp
                call    #\i_readmemb
                setbyte i_data, i_tmpb, #1
        _ret_   incmod  i_sp, i_ffffh

i_pop_modrm
                call    #\i_setupmodrm
                call    #i_pop
                jmp     #\i_writeopw

i_pushf
                getword i_data, i_flags, #0
                and     i_data, ##ALL_FLAGS
                or      i_data, i_flags_pre
                jmp     #i_push

i_popf
                call    #i_pop
                and     i_data, ##ALL_FLAGS
                or      i_data, i_flags_pre
        _ret_   setword i_flags, i_data, #0

' --------------------------------------------------------------------

i_fe_prefix
                call    #\i_setupmodrm
                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' INC
        if_z    jmp     #.inc
                cmp     i_temp0, #%00_001_000   wz  ' DEC
        if_z    jmp     #.dec
                ret

.inc
                call    #\i_readopb
                mov     i_data0, i_data
                mov     i_data1, #1
                add     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_add_flags8_nc

.dec
                call    #\i_readopb
                mov     i_data0, i_data
                mov     i_data1, #1
                sub     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_sub_flags8_nc

' --------------------------------------------------------------------

i_f6_prefix
                call    #\i_setupmodrm
                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' TEST
        if_nz   cmp     i_temp0, #%00_001_000   wz  ' TEST (alias)
        if_z    jmp     #.test
                cmp     i_temp0, #%00_010_000   wz  ' NOT
        if_z    jmp     #.not
                cmp     i_temp0, #%00_011_000   wz  ' NEG
        if_z    jmp     #.neg
                cmp     i_temp0, #%00_100_000   wz  ' MUL
        if_z    jmp     #.mul
                cmp     i_temp0, #%00_101_000   wz  ' IMUL
        if_z    jmp     #.imul
                cmp     i_temp0, #%00_110_000   wz  ' DIV
        if_z    jmp     #.div
                cmp     i_temp0, #%00_111_000   wz  ' IDIV
        if_z    jmp     #.idiv
                ret

.test
                call    #\i_readimmb
                mov     i_data1, i_data
                call    #\i_readopb
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags8

.not
                call    #\i_readopb
                not     i_data
                jmp     #\i_writeopb

.neg
                call    #\i_readopb
                mov     i_data1, i_data
                mov     i_data, #0
                mov     i_data0, i_data
                sub     i_data, i_data1
                call    #\i_writeopb
                jmp     #\i_sub_flags8

.mul
                call    #\i_readopb
                mov     i_data1, i_data

                getbyte i_data, i_ax, #0

                mul     i_data, i_data1         wz
                getword i_ax, i_data, #0

                bitz    i_flags, #I_ZF_BIT

                testb   i_ax, #7                wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF              wc
                bitnc   i_flags, #I_PF_BIT

                testn   i_ax, #$FF              wz
                bitnz   i_flags, #I_CF_BIT
        _ret_   bitnz   i_flags, #I_OF_BIT

.imul
                call    #\i_readopb
                mov     i_data1, i_data
                signx   i_data1, #7

                getbyte i_data, i_ax, #0
                signx   i_data, #7

                muls    i_data, i_data1         wz
                getword i_ax, i_data, #0

                bitz    i_flags, #I_ZF_BIT

                testb   i_ax, #7                wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF              wc
                bitnc   i_flags, #I_PF_BIT

                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT

                cmps    i_data, #127            wcz
        if_gt   bith    i_flags, #I_CF_BIT
        if_gt   bith    i_flags, #I_OF_BIT

                cmps    i_data, ##-128          wcz
        if_lt   bith    i_flags, #I_CF_BIT
        if_lt   bith    i_flags, #I_OF_BIT

                ret

.div
                call    #\i_readopb
                mov     i_data1, i_data         wz
        if_z    jmp     #i_divzero

                getword i_data, i_ax, #0

                qdiv    i_data, i_data1
                getqx   i_temp0
                getqy   i_temp1

                testn   i_temp0, #$FF           wz
        if_nz   jmp     #i_divzero

                setbyte i_ax, i_temp0, #0
        _ret_   setbyte i_ax, i_temp1, #1

.idiv
                call    #\i_readopb
                mov     i_data1, i_data         wz
        if_z    jmp     #i_divzero

                signx   i_data1, #7
                testb   i_data1, #31            wc
        if_c    abs     i_data1

                getword i_data, i_ax, #0
                cmp     i_data, ##$8000         wz
        if_z    jmp     #i_divzero
                signx   i_data, #15
                testb   i_data, #31             wz
        if_z    abs     i_data

                qdiv    i_data, i_data1
                getqx   i_temp0
                getqy   i_temp1
    if_c_ne_z   neg     i_temp0
    if_z        neg     i_temp1

                getbyte i_temp2, i_temp0, #0
                signx   i_temp2, #7
                cmp     i_temp0, i_temp2        wz
        if_nz   jmp     #i_divzero

                setbyte i_ax, i_temp0, #0
        _ret_   setbyte i_ax, i_temp1, #1

' --------------------------------------------------------------------

i_f7_prefix
                call    #\i_setupmodrm
                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' TEST
        if_nz   cmp     i_temp0, #%00_001_000   wz  ' TEST (alias)
        if_z    jmp     #.test
                cmp     i_temp0, #%00_010_000   wz  ' NOT
        if_z    jmp     #.not
                cmp     i_temp0, #%00_011_000   wz  ' NEG
        if_z    jmp     #.neg
                cmp     i_temp0, #%00_100_000   wz  ' MUL
        if_z    jmp     #.mul
                cmp     i_temp0, #%00_101_000   wz  ' IMUL
        if_z    jmp     #.imul
                cmp     i_temp0, #%00_110_000   wz  ' DIV
        if_z    jmp     #.div
                cmp     i_temp0, #%00_111_000   wz  ' IDIV
        if_z    jmp     #.idiv
                ret

.test
                call    #\i_readimmw
                mov     i_data1, i_data
                call    #\i_readopw
                mov     i_data0, i_data
                and     i_data, i_data1
                jmp     #\i_logic_flags16

.not
                call    #\i_readopw
                not     i_data
                jmp     #\i_writeopw

.neg
                call    #\i_readopw
                mov     i_data1, i_data
                mov     i_data, #0
                mov     i_data0, i_data
                sub     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_sub_flags16

.mul
                call    #\i_readopw
                mov     i_data1, i_data

                getword i_data, i_ax, #0

                mul     i_data, i_data1         wz
                getword i_ax, i_data, #0
                getword i_dx, i_data, #1

                bitz    i_flags, #I_ZF_BIT

                testb   i_ax, #15               wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF              wc
                bitnc   i_flags, #I_PF_BIT

                cmp     i_dx, #0                wz
                bitnz   i_flags, #I_CF_BIT
        _ret_   bitnz   i_flags, #I_OF_BIT

.imul
                call    #\i_readopw
                mov     i_data1, i_data
                signx   i_data1, #15

                getword i_data, i_ax, #0
                signx   i_data, #15

                muls    i_data, i_data1         wz
                getword i_ax, i_data, #0
                getword i_dx, i_data, #1

                bitz    i_flags, #I_ZF_BIT

                testb   i_ax, #15               wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF              wc
                bitnc   i_flags, #I_PF_BIT

                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT

                cmps    i_data, ##32767         wcz
        if_gt   bith    i_flags, #I_CF_BIT
        if_gt   bith    i_flags, #I_OF_BIT

                cmps    i_data, ##-32768        wcz
        if_lt   bith    i_flags, #I_CF_BIT
        if_lt   bith    i_flags, #I_OF_BIT
                ret

.div
                call    #\i_readopw
                mov     i_data1, i_data         wz
        if_z    jmp     #i_divzero

                getword i_data, i_ax, #0
                setword i_data, i_dx, #1

                qdiv    i_data, i_data1
                getqx   i_temp0
                getqy   i_temp1

                testn   i_temp0, i_ffffh        wz
        if_nz   jmp     #i_divzero

                getword i_ax, i_temp0, #0
        _ret_   getword i_dx, i_temp1, #0

.idiv
                call    #\i_readopw
                mov     i_data1, i_data         wz
        if_z    jmp     #i_divzero

                signx   i_data1, #15
                testb   i_data1, #31            wc
        if_c    abs     i_data1

                getword i_data, i_ax, #0
                setword i_data, i_dx, #1
                cmp     i_data, ##$8000_0000    wz
        if_z    jmp     #i_divzero

                testb   i_data, #31             wz
        if_z    abs     i_data

                qdiv    i_data, i_data1
                getqx   i_temp0
                getqy   i_temp1
    if_c_ne_z   neg     i_temp0
    if_z        neg     i_temp1

                getword i_temp2, i_temp0, #0
                signx   i_temp2, #15
                cmp     i_temp0, i_temp2        wz
        if_nz   jmp     #i_divzero

                getword i_ax, i_temp0, #0
        _ret_   getword i_dx, i_temp1, #0

' --------------------------------------------------------------------

i_ff_prefix
                call    #\i_setupmodrm
                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' INC
        if_z    jmp     #.inc
                cmp     i_temp0, #%00_001_000   wz  ' DEC
        if_z    jmp     #.dec
                cmp     i_temp0, #%00_010_000   wz  ' CALL
        if_z    jmp     #.call_near
                cmp     i_temp0, #%00_011_000   wz  ' CALL FAR
        if_z    jmp     #.call_far
                cmp     i_temp0, #%00_100_000   wz  ' JMP
        if_z    jmp     #.jmp_near
                cmp     i_temp0, #%00_101_000   wz  ' JMP FAR
        if_z    jmp     #.jmp_far
                cmp     i_temp0, #%00_110_000   wz  ' PUSH
        if_z    jmp     #.push
                cmp     i_temp0, #%00_111_000   wz  ' PUSH
        if_z    jmp     #.push
                ret

.inc
                call    #\i_readopw
                mov     i_data0, i_data
                mov     i_data1, #1
                add     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_add_flags16_nc

.dec
                call    #\i_readopw
                mov     i_data0, i_data
                mov     i_data1, #1
                sub     i_data, i_data1
                call    #\i_writeopw
                jmp     #\i_sub_flags16_nc

.call_near
                getword i_data, i_ip, #0
                call    #i_push
.jmp_near
                call    #\i_readopw
        _ret_   getword i_ip, i_data, #0

.call_far
                getword i_data, i_cs, #0
                call    #i_push
                getword i_data, i_ip, #0
                call    #i_push
.jmp_far
                call    #\i_setupea
                call    #\i_readw
                getword i_data0, i_data, #0
                call    #\i_readw
                getword i_cs, i_data, #0
        _ret_   getword i_ip, i_data0, #0

.push
                call    #\i_readopw
                jmp     #i_push

' --------------------------------------------------------------------

i_ret_near
                call    #i_pop
        _ret_   getword i_ip, i_data, #0

i_ret_near_sp
                call    #\i_readimmw
                mov     i_data0, i_data
                call    #i_pop
                getword i_ip, i_data, #0
                add     i_sp, i_data0
        _ret_   getword i_sp, i_sp, #0

i_ret_far
                call    #i_pop
                getword i_ip, i_data, #0
                call    #i_pop
        _ret_   getword i_cs, i_data, #0

i_ret_far_sp
                call    #\i_readimmw
                mov     i_data0, i_data
                call    #i_pop
                getword i_ip, i_data, #0
                call    #i_pop
                getword i_cs, i_data, #0
                add     i_sp, i_data0
        _ret_   getword i_sp, i_sp, #0

' --------------------------------------------------------------------

i_push_r16
                mov     pa, i_opcode
                call    #\i_getr16
                jmp     #i_push

i_pop_r16
                call    #i_pop
                mov     pa, i_opcode
                jmp     #\i_setr16

i_push_sreg
                mov     pa, i_opcode
                call    #\i_getsreg
                jmp     #i_push

i_pop_sreg
                call    #i_pop
                mov     pa, i_opcode
                jmp     #\i_setsreg

' --------------------------------------------------------------------

i_daas
                getbyte i_data, i_ax, #0

                getword i_temp0, i_flags, #0    ' save flags
                bitl    i_temp0, #I_AF_BIT
                bitl    i_temp0, #I_CF_BIT

                getnib  i_temp1, i_ax, #0
                cmpr    i_temp1, #$9        wc
                testb   i_flags, #I_AF_BIT  orc
        if_nc   jmp     #.l1

                testb   i_opcode, #3        wz
                getbyte i_data1, i_ax, #0
                sumz    i_data1, #6
                setbyte i_data, i_data1, #0

                testb   i_flags, #I_CF_BIT  wc
                testn   i_data, #$FF        wz
   if_c_or_nz   bith    i_temp0, #I_CF_BIT

                bith    i_temp0, #I_AF_BIT

.l1
                getbyte i_data1, i_ax, #0
                cmpr    i_data1, #$99       wc
                testb   i_flags, #I_CF_BIT  orc

                testb   i_opcode, #3        wz
        if_c    sumz    i_data, #$60
                bitc    i_temp0, #I_CF_BIT

                setbyte i_ax, i_data, #0
                setword i_flags, i_temp0, #0

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT
                test    i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_aaas
                getnib  i_temp1, i_ax, #0
                cmpr    i_temp1, #$9        wc
                testb   i_flags, #I_AF_BIT  orc

                testb   i_opcode, #3        wz
                getbyte i_data, i_ax, #0
        if_c    sumz    i_data, #6
                setbyte i_ax, i_data, #0

                getbyte i_data, i_ax, #1
        if_c    sumz    i_data, #1
                setbyte i_ax, i_data, #1

                muxc    i_flags, #(1 << I_CF_BIT) | (1 << I_AF_BIT)

                setnib  i_ax, #0, #1

                test    i_ax, #$0F          wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_aam
                call    #\i_readcodeb
                getbyte i_data, i_ax, #0

                qdiv    i_data, i_tmpb
                getqx   i_temp0
                getqy   i_temp1
                setbyte i_ax, i_temp0, #1
                setbyte i_ax, i_temp1, #0

                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT
                bitl    i_flags, #I_AF_BIT

                testb   i_ax, #7            wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF          wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

i_aad
                call    #\i_readcodeb
                getbyte i_data, i_ax, #1
                mul     i_data, i_tmpb

                getbyte i_temp0, i_ax, #0
                add     i_data, i_temp0

                getbyte i_ax, i_data, #0

                bitl    i_flags, #I_CF_BIT
                bitl    i_flags, #I_OF_BIT
                bitl    i_flags, #I_AF_BIT

                testb   i_ax, #7            wz
                bitz    i_flags, #I_SF_BIT
                test    i_ax, #$FF          wcz
                bitz    i_flags, #I_ZF_BIT
        _ret_   bitnc   i_flags, #I_PF_BIT

' --------------------------------------------------------------------

i_call_far
                call    #\i_readimmw
                getword i_data0, i_data, #0
                call    #\i_readimmw
                getword i_data1, i_data, #0

                getword i_data, i_cs, #0
                call    #i_push
                getword i_data, i_ip, #0
                call    #i_push

                getword i_cs, i_data1, #0
        _ret_   getword i_ip, i_data0, #0

i_jmp_far
                call    #\i_readimmw
                getword i_data0, i_data, #0
                call    #\i_readimmw
                getword i_cs, i_data, #0
        _ret_   getword i_ip, i_data0, #0

i_call_near
                call    #\i_readimmw
                getword i_data0, i_data, #0

                getword i_data, i_ip, #0
                call    #i_push

        _ret_   getword i_ip, i_data0, #0

i_jmp_near
                call    #\i_readimmw
        _ret_   getword i_ip, i_data, #0


i_call_displ
                call    #\i_readimmw
                getword i_data0, i_data, #0

                getword i_data, i_ip, #0
                call    #i_push

                add     i_ip, i_data0
        _ret_   getword i_ip, i_ip, #0

i_jmp_displ
                call    #\i_readimmw
                add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jmp_displ8
                call    #\i_readimmb
                signx   i_data, #7
                add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_loop
                call    #\i_readcodeb
                signx   i_tmpb, #7
                decmod  i_cx, i_ffffh       wz
        if_nz   add     i_ip, i_tmpb
        _ret_   getword i_ip, i_ip, #0

i_loope
                call    #\i_readcodeb
                signx   i_tmpb, #7
                decmod  i_cx, i_ffffh       wz
                testb   i_flags, #I_ZF_BIT  wc
  if_nz_and_c   add     i_ip, i_tmpb
        _ret_   getword i_ip, i_ip, #0

i_loopne
                call    #\i_readcodeb
                signx   i_tmpb, #7
                decmod  i_cx, i_ffffh       wz
                testb   i_flags, #I_ZF_BIT  wc
  if_nz_and_nc  add     i_ip, i_tmpb
        _ret_   getword i_ip, i_ip, #0

i_jcxz
                call    #\i_readcodeb
                signx   i_tmpb, #7
                cmp     i_cx, #0            wz
        if_z    add     i_ip, i_tmpb
        _ret_   getword i_ip, i_ip, #0

' --------------------------------------------------------------------

i_jo
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_OF_BIT  wz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jc
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_CF_BIT  wz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jz
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_ZF_BIT  wz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_js
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_SF_BIT  wz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jp
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_PF_BIT  wz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jce
                call    #\i_readimmb
                signx   i_data, #7
                testbn  i_opcode, #0        wc
                testb   i_flags, #I_CF_BIT  wz
                testb   i_flags, #I_ZF_BIT  orz
    if_c_eq_z   add     i_ip, i_data
        _ret_   getword i_ip, i_ip, #0

i_jl
                call    #\i_readimmb
                signx   i_data, #7
                testb   i_flags, #I_SF_BIT  wc  ' (SF != OF)
                testb   i_flags, #I_OF_BIT  wz  ' |
                modc    _c_ne_z             wc  ' | -> (C)
                testbn  i_flags, #I_ZF_BIT  wz  ' (!ZF) -> (Z)
    if_c_and_z  add     i_ip, i_data            ' ((SF != OF) && (!ZF))
        _ret_   getword i_ip, i_ip, #0

i_jle
                call    #\i_readimmb
                signx   i_data, #7
                testb   i_flags, #I_SF_BIT  wc  ' (SF != OF)
                testb   i_flags, #I_OF_BIT  wz  ' |
                modc    _c_ne_z             wc  ' | -> (C)
                testb   i_flags, #I_ZF_BIT  wz  ' (ZF) -> (Z)
    if_c_or_z   add     i_ip, i_data            ' ((SF != OF) || (ZF))
        _ret_   getword i_ip, i_ip, #0

i_jnl
                call    #\i_readimmb
                signx   i_data, #7
                testb   i_flags, #I_SF_BIT  wc
                testb   i_flags, #I_OF_BIT  wz
    if_c_eq_z   add     i_ip, i_data            ' (SF == OF)
        _ret_   getword i_ip, i_ip, #0

i_jnle
                call    #\i_readimmb
                signx   i_data, #7
                testb   i_flags, #I_SF_BIT  wc  ' (SF == OF)
                testb   i_flags, #I_OF_BIT  wz  ' |
                modc    _c_eq_z             wc  ' | -> (C)
                testbn  i_flags, #I_ZF_BIT  wz  ' (!ZF) -> (Z)
    if_c_and_z  add     i_ip, i_data            ' ((SF == OF) && (!ZF))
        _ret_   getword i_ip, i_ip, #0

' --------------------------------------------------------------------

i_in_al_imm
                call    #\i_readcodeb
                getbyte i_ea, i_tmpb, #0
                call    #\i_readiob
        _ret_   setbyte i_ax, i_tmpb, #0

i_in_ax_imm
                call    #\i_readcodeb
                getbyte i_ea, i_tmpb, #0
                call    #\i_readiob
                setbyte i_ax, i_tmpb, #0
                add     i_ea, #1
                call    #\i_readiob
        _ret_   setbyte i_ax, i_tmpb, #1

i_in_al_dx
                getword i_ea, i_dx, #0
                call    #\i_readiob
        _ret_   setbyte i_ax, i_tmpb, #0

i_in_ax_dx
                getword i_ea, i_dx, #0
                call    #\i_readiob
                setbyte i_ax, i_tmpb, #0
                add     i_ea, #1
                call    #\i_readiob
        _ret_   setbyte i_ax, i_tmpb, #1

i_out_imm_al
                call    #\i_readcodeb
                getbyte i_ea, i_tmpb, #0
                getbyte i_tmpb, i_ax, #0
                jmp     #\i_writeiob

i_out_imm_ax
                call    #\i_readcodeb
                getbyte i_ea, i_tmpb, #0
                getbyte i_tmpb, i_ax, #0
                call    #\i_writeiob
                add     i_ea, #1
                getbyte i_tmpb, i_ax, #1
                jmp     #\i_writeiob

i_out_dx_al
                getword i_ea, i_dx, #0
                getbyte i_tmpb, i_ax, #0
                jmp     #\i_writeiob

i_out_dx_ax
                getword i_ea, i_dx, #0
                getbyte i_tmpb, i_ax, #0
                call    #\i_writeiob
                add     i_ea, #1
                getbyte i_tmpb, i_ax, #1
                jmp     #\i_writeiob

' --------------------------------------------------------------------

i_xlatb
                getbyte i_temp0, i_ax, #0
                add     i_temp0, i_bx
                getword i_temp0, i_temp0, #0
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_temp0
                call    #\i_readmemb
        _ret_   setbyte i_ax, i_tmpb, #0

i_les
                call    #\i_setupmodrm
                call    #\i_setupea
                call    #\i_readw
                call    #\i_setmodr16
                call    #\i_readw
        _ret_   mov     i_es, i_data

i_lds
                call    #\i_setupmodrm
                call    #\i_setupea
                call    #\i_readw
                call    #\i_setmodr16
                call    #\i_readw
        _ret_   mov     i_ds, i_data

i_movsb
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si
                call    #\i_readb

                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di
                call    #\i_writeb

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_si, #1
                getword i_si, i_si, #0
                sumz    i_di, #1
        _ret_   getword i_di, i_di, #0

i_movsw
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si
                call    #\i_readw

                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di
                call    #\i_writew

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_si, #2
                getword i_si, i_si, #0
                sumz    i_di, #2
        _ret_   getword i_di, i_di, #0

i_lodsb
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si

                call    #\i_readb
                setbyte i_ax, i_data, #0

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_si, #1
        _ret_   getword i_si, i_si, #0

i_lodsw
                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si

                call    #\i_readw
                getword i_ax, i_data, #0

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_si, #2
        _ret_   getword i_si, i_si, #0

i_stosb
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di

                getbyte i_data, i_ax, #0
                call    #\i_writeb

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #1
        _ret_   getword i_di, i_di, #0

i_stosw
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di

                getword i_data, i_ax, #0
                call    #\i_writew

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #2
        _ret_   getword i_di, i_di, #0

i_scasb
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di

                call    #\i_readb
                mov     i_data1, i_data

                getbyte i_data, i_ax, #0
                mov     i_data0, i_data

                sub     i_data, i_data1

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #1
                getword i_di, i_di, #0

                jmp     #\i_sub_flags8

i_scasw
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di

                call    #\i_readw
                mov     i_data1, i_data

                getword i_data, i_ax, #0
                mov     i_data0, i_data

                sub     i_data, i_data1

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #2
                getword i_di, i_di, #0

                jmp     #\i_sub_flags16

i_cmpsb
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di
                call    #\i_readb
                mov     i_data1, i_data

                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si
                call    #\i_readb
                mov     i_data0, i_data

                sub     i_data, i_data1

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #1
                getword i_di, i_di, #0
                sumz    i_si, #1
                getword i_si, i_si, #0

                jmp     #\i_sub_flags8

i_cmpsw
                getword i_ea, i_es, #0
                shl     i_ea, #4
                add     i_ea, i_di
                call    #\i_readw
                mov     i_data1, i_data

                testb   i_flags, #I_SEG_BIT wz
        if_x1   getword i_ea, i_override, #0
        if_x0   getword i_ea, i_ds, #0
                shl     i_ea, #4
                add     i_ea, i_si
                call    #\i_readw
                mov     i_data0, i_data

                sub     i_data, i_data1

                testb   i_flags, #I_DF_BIT  wz
                sumz    i_di, #2
                getword i_di, i_di, #0
                sumz    i_si, #2
                getword i_si, i_si, #0

                jmp     #\i_sub_flags16

' --------------------------------------------------------------------

i_divzero
                getword i_ip, i_ip_start, #0
                mov     i_temp0, #0
                jmp     #i_trap

i_into
                testb   i_flags, #I_OF_BIT  wz
        if_x1   mov     i_temp0, #4
        if_x1   jmp     #i_trap
                ret

i_int3          mov     i_temp0, #3
                jmp     #i_trap

i_int           call    #\i_readcodeb
                mov     i_temp0, i_tmpb
i_trap          getword i_data, i_flags, #0
                and     i_data, ##ALL_FLAGS
                or      i_data, i_flags_pre
                call    #i_push
                getword i_data, i_cs, #0
                call    #i_push
                getword i_data, i_ip, #0
                call    #i_push
                bitl    i_flags, #I_TF_BIT
                bitl    i_flags, #I_IF_BIT
                mov     i_ea, i_temp0
                shl     i_ea, #2
                call    #\i_readw
                getword i_ip, i_data, #0
                call    #\i_readw
        _ret_   getword i_cs, i_data, #0

i_iret
                call    #i_pop
                getword i_ip, i_data, #0
                call    #i_pop
                getword i_cs, i_data, #0
                call    #i_pop
                setword i_flags, i_data, #0
        _ret_   bith    i_flags, #I_NO_INT_BIT

' --------------------------------------------------------------------

i_d2_prefix
                getbyte i_rep_cnt, i_cx, #0
                skip    #%1
i_d0_prefix
                mov     i_rep_cnt, #1

                call    #\i_setupmodrm
                call    #\i_readopb
                mov     i_data0, i_data

                cmp     i_rep_cnt, #0           wz
        if_z    ret
                and     i_rep_cnt, #$1F             ' *** 286 ***

                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' ROL
        if_z    jmp     #.rol
                cmp     i_temp0, #%00_001_000   wz  ' ROR
        if_z    jmp     #.ror
                cmp     i_temp0, #%00_010_000   wz  ' ROLC
        if_z    jmp     #.rolc
                cmp     i_temp0, #%00_011_000   wz  ' RORC
        if_z    jmp     #.rorc
                cmp     i_temp0, #%00_100_000   wz  ' SHL
        if_z    jmp     #.shl
                cmp     i_temp0, #%00_101_000   wz  ' SHR
        if_z    jmp     #.shr
                cmp     i_temp0, #%00_110_000   wz
        if_z    jmp     #\@@i_hlt
                cmp     i_temp0, #%00_111_000   wz  ' SHRA
        if_z    jmp     #.shra
                ret

.rol
                testb   i_data, #7          wc

                shl     i_data, #1
                bitc    i_data, #0

                djnz    i_rep_cnt, #.rol

                bitc    i_flags, #I_CF_BIT

                testb   i_flags, #I_CF_BIT  wz
                testb   i_data, #7          xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopb

.ror
                testb   i_data, #0          wc

                shr     i_data, #1
                bitc    i_data, #7

                djnz    i_rep_cnt, #.ror

                bitc    i_flags, #I_CF_BIT

                testb   i_data, #7          wz
                testb   i_data, #6          xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopb

.rolc
                testb   i_data, #7          wc

                shl     i_data, #1
                testb   i_flags, #I_CF_BIT  wz
                bitz    i_data, #0

                bitc    i_flags, #I_CF_BIT
                djnz    i_rep_cnt, #.rolc

                testb   i_flags, #I_CF_BIT  wz
                testb   i_data, #7          xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopb

.rorc
                testb   i_data, #0          wc

                shr     i_data, #1
                testb   i_flags, #I_CF_BIT  wz
                bitz    i_data, #7

                bitc    i_flags, #I_CF_BIT
                djnz    i_rep_cnt, #.rorc

                testb   i_data, #7          wz
                testb   i_data, #6          xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopb

.shl
                testb   i_data, #7          wc
                shl     i_data, #1
                djnz    i_rep_cnt, #.shl

                bitc    i_flags, #I_CF_BIT

                testb   i_data, #8          wz
                testb   i_data, #7          xorz
                bitz    i_flags, #I_OF_BIT

                test    i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopb

.shr
                cmp     i_rep_cnt, #1       wz  ' check count=1 for overflow
.shr_loop
                testb   i_data, #0          wc
                shr     i_data, #1
                djnz    i_rep_cnt, #.shr_loop

                bitc    i_flags, #I_CF_BIT

        if_z    testb   i_data0, #7         wc  ' overflow defined only if count=1
        if_z    bitc    i_flags, #I_OF_BIT
        if_nz   bitl    i_flags, #I_OF_BIT

                test    i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopb

.shra
                testb   i_data, #0          wc
                testb   i_data, #7          wz
                shr     i_data, #1
                bitz    i_data, #7
                djnz    i_rep_cnt, #.shra

                bitc    i_flags, #I_CF_BIT

                bitl    i_flags, #I_OF_BIT

                test    i_data, #$FF        wcz
                bitz    i_flags, #I_ZF_BIT
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #7          wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopb

i_d3_prefix
                getbyte i_rep_cnt, i_cx, #0
                skip    #%1
i_d1_prefix
                mov     i_rep_cnt, #1

                call    #\i_setupmodrm
                call    #\i_readopw
                mov     i_data0, i_data

                cmp     i_rep_cnt, #0           wz
        if_z    ret
                and     i_rep_cnt, #$1F             ' *** 286 ***

                mov     i_temp0, i_modrm
                and     i_temp0, #%00_111_000   wz  ' ROL
        if_z    jmp     #.rol
                cmp     i_temp0, #%00_001_000   wz  ' ROR
        if_z    jmp     #.ror
                cmp     i_temp0, #%00_010_000   wz  ' ROLC
        if_z    jmp     #.rolc
                cmp     i_temp0, #%00_011_000   wz  ' RORC
        if_z    jmp     #.rorc
                cmp     i_temp0, #%00_100_000   wz  ' SHL
        if_z    jmp     #.shl
                cmp     i_temp0, #%00_101_000   wz  ' SHR
        if_z    jmp     #.shr
                cmp     i_temp0, #%00_110_000   wz
        if_z    jmp     #\@@i_hlt
                cmp     i_temp0, #%00_111_000   wz  ' SHRA
        if_z    jmp     #.shra
                ret

.rol
                testb   i_data, #15         wc

                shl     i_data, #1
                bitc    i_data, #0

                djnz    i_rep_cnt, #.rol

                bitc    i_flags, #I_CF_BIT

                testb   i_flags, #I_CF_BIT  wz
                testb   i_data, #15         xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopw

.ror
                testb   i_data, #0          wc

                shr     i_data, #1
                bitc    i_data, #15

                djnz    i_rep_cnt, #.ror

                bitc    i_flags, #I_CF_BIT

                testb   i_data, #15         wz
                testb   i_data, #14         xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopw

.rolc
                testb   i_data, #15         wc

                shl     i_data, #1
                testb   i_flags, #I_CF_BIT  wz
                bitz    i_data, #0

                bitc    i_flags, #I_CF_BIT
                djnz    i_rep_cnt, #.rolc

                testb   i_flags, #I_CF_BIT  wz
                testb   i_data, #15         xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopw

.rorc
                testb   i_data, #0          wc

                shr     i_data, #1
                testb   i_flags, #I_CF_BIT  wz
                bitz    i_data, #15

                bitc    i_flags, #I_CF_BIT
                djnz    i_rep_cnt, #.rorc

                testb   i_data, #15         wz
                testb   i_data, #14         xorz
                bitz    i_flags, #I_OF_BIT

                jmp     #\i_writeopw

.shl
                testb   i_data, #15         wc
                shl     i_data, #1
                djnz    i_rep_cnt, #.shl

                bitc    i_flags, #I_CF_BIT

                testb   i_data, #16         wz
                testb   i_data, #15         xorz
                bitz    i_flags, #I_OF_BIT

                test    i_data, i_ffffh     wz
                bitz    i_flags, #I_ZF_BIT

                test    i_data, #$FF        wc
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopw

.shr
                cmp     i_rep_cnt, #1       wz  ' check count=1 for overflow
.shr_loop
                testb   i_data, #0          wc
                shr     i_data, #1
                djnz    i_rep_cnt, #.shr_loop

                bitc    i_flags, #I_CF_BIT

        if_z    testb   i_data0, #15        wc  ' overflow defined only if count=1
        if_z    bitc    i_flags, #I_OF_BIT
        if_nz   bitl    i_flags, #I_OF_BIT

                test    i_data, i_ffffh     wz
                bitz    i_flags, #I_ZF_BIT

                test    i_data, #$FF        wc
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopw

.shra
                testb   i_data, #0          wc
                testb   i_data, #15         wz
                shr     i_data, #1
                bitz    i_data, #15
                djnz    i_rep_cnt, #.shra

                bitc    i_flags, #I_CF_BIT

                bitl    i_flags, #I_OF_BIT

                test    i_data, i_ffffh     wz
                bitz    i_flags, #I_ZF_BIT

                test    i_data, #$FF        wc
                bitnc   i_flags, #I_PF_BIT

                testb   i_data, #15         wz
                bitz    i_flags, #I_SF_BIT

                jmp     #\i_writeopw

' --------------------------------------------------------------------

i_lock
i_wait
                ret

i_cmc   _ret_   bitnot  i_flags, #I_CF_BIT

i_clc   _ret_   bitl    i_flags, #I_CF_BIT

i_stc   _ret_   bith    i_flags, #I_CF_BIT

i_cli   _ret_   bitl    i_flags, #I_IF_BIT

i_sti           bith    i_flags, #I_NO_INT_BIT
        _ret_   bith    i_flags, #I_IF_BIT

i_cld   _ret_   bitl    i_flags, #I_DF_BIT

i_std   _ret_   bith    i_flags, #I_DF_BIT

i_cbw
                signx   i_ax, #7
        _ret_   getword i_ax, i_ax, #0

i_cwd
                testb   i_ax, #15           wc
        _ret_   muxc    i_dx, i_ffffh

i_salc
                testb   i_flags, #I_CF_BIT  wc
        _ret_   muxc    i_ax, #$FF

i_sahf
                getbyte i_data, i_ax, #1
                and     i_data, ##ALL_FLAGS
                or      i_data, i_flags_pre
        _ret_   setbyte i_flags, i_data, #0

i_lahf
                getword i_data, i_flags, #0
                or      i_data, i_flags_pre
        _ret_   setbyte i_ax, i_data, #1

i_lea
                call    #\i_setupmodrm
                getword i_data, i_offset, #0
                jmp     #\i_setmodr16

i_xchg
                mov     pa, i_opcode
                call    #\i_getr16
                mov     i_data0, i_data
                getword i_data, i_ax, #0
                getword i_ax, i_data0, #0
                jmp     #\i_setr16

i_xchg_modrm8
                call    #\i_setupmodrm

                call    #\i_readopb
                mov     i_data1, i_data

                call    #\i_getmodr8
                mov     i_data0, i_data

                mov     i_data, i_data1
                call    #\i_setmodr8
                mov     i_data, i_data0
                jmp     #\i_writeopb

i_xchg_modrm16
                call    #\i_setupmodrm

                call    #\i_readopw
                mov     i_data1, i_data

                call    #\i_getmodr16
                mov     i_data0, i_data

                mov     i_data, i_data1
                call    #\i_setmodr16
                mov     i_data, i_data0
                jmp     #\i_writeopw

CON             ' 8086 Constants

    I_CF_BIT = 0    ' Carry
    I_PF_BIT = 2    ' Parity
    I_AF_BIT = 4    ' Aux. Carry
    I_ZF_BIT = 6    ' Zero
    I_SF_BIT = 7    ' Sign
    I_TF_BIT = 8    ' Trap
    I_IF_BIT = 9    ' Interrupt
    I_DF_BIT = 10   ' Direction
    I_OF_BIT = 11   ' Overflow

    ALL_FLAGS = (1 << I_CF_BIT) | (1 << I_PF_BIT) | (1 << I_AF_BIT) | (1 << I_ZF_BIT) | (1 << I_SF_BIT) | (1 << I_TF_BIT) | (1 << I_IF_BIT) | (1 << I_DF_BIT) | (1 << I_OF_BIT)

    I_KB_RESET   = 17

    I_REP_BIT    = 26
    I_REP_ZF_BIT = 27

    I_SEG_BIT    = 28
    I_HALT_BIT   = 29
    I_LOCK_BIT   = 30
    I_NO_INT_BIT = 31

DAT ' System
                orgh

system_init
                ret

i_run_interrupts

                ' irq7 - printer

                ' irq6 - floppy

                ' irq5 - hard disk

                ' irq4 - serial interface 1

                ' irq3 - serial interface 2

                ' irq1 - keyboard
'                pollatn             wz
'        if_x1   bith    pic_irq, #1     ' signal irq

.lw1            locktry #0              wc
        if_nc   jmp     #.lw1

                rdbyte  i_temp0, #@irq  wz
                or      pic_irq, i_temp0
                wrbyte  #0, #@irq

                lockrel #0

                testb   pic_irq, #PIC_IS_BIT    wc
                testb   i_flags, #I_IF_BIT      wz
   if_not_01    ret

                getbyte i_temp0, pic_irq, #PIC_ISR_BYTE
                getbyte i_temp1, pic_irq, #PIC_IRR_BYTE
                or      i_temp0, i_temp1
                setbyte pic_irq, i_temp0, #PIC_ISR_BYTE
                setbyte pic_irq, #0, #PIC_IRR_BYTE

                call    #pic_intack

                getbyte i_temp0, pic_icw, #PIC_ICW2_BYTE
                testb   pic_irq, #PIC_IS_BIT    wz
        if_x1   getnib  i_temp1, pic_irq, #PIC_IR_NIB
        if_x1   add     i_temp0, i_temp1
        if_x1   jmp     #\i_trap

                ret

cga_03D5_wr
                rdbyte  pa, #@cga_io_03D4
                cmp     pa, #17         wcz
        if_a    ret     wcz
                add     pa, #@cga_io_mc6845
                wrbyte  i_tmpb, pa
                ret     wcz

DAT             ' PPI 8255A
                orgh

ppi_60_rd
                testb   ppi, #PPI_PA_INPUT          wz ' PA input ?
        if_x0   getbyte i_tmpb, ppi, #PPI_PA_BYTE      ' no, return the out state
        if_x1   rdbyte  i_tmpb, #@kbd_data
                ret     wcz

ppi_61_wr
                testb   ppi, #(PPI_PB_BYTE * 8) + 6 wc
                testb   i_tmpb, #6                  wz
        if_01   bitnz   i_flags, #I_KB_RESET

                testb   ppi, #(PPI_PB_BYTE * 8) + 7 wc
                testb   i_tmpb, #7                  wz
                setbyte ppi, i_tmpb, #PPI_PB_BYTE
        if_10   jmp     #.reset

                testb   i_tmpb, #(PPI_PB_BYTE * 8) + 7 wz
        if_x1   wrbyte  #$00, #@kbd_data
                ret     wcz

.reset
                bitl    i_flags, #I_KB_RESET        wcz
        if_x1   wrbyte  #$AA, #@kbd_data
        if_x1   bith    pic_irq, #1     ' signal irq
                ret     wcz

ppi_62_rd
                testb   ppi, #(PPI_PB_BYTE * 8) + 3  wz
        if_x0   mov     i_tmpb, #%00001101 ' Low switches
                '                     ||||
                '                     |||+-- Loop on POST
                '                     ||+--- 1=Co-Processor installed
                '                     ++---- Planar RAM size (00=64K, 01=128K, 10=192K, 11=256K)
        if_x1   mov     i_tmpb, #%00000010 ' High switches
                '                     ||||
                '                     ||++-- Display (10=CGA)
                '                     ++---- Num. Floppy drives (00=1, 01=2, 10=3, 11=4)
                ret     wcz

CON ' PPI 8255A constants

    PPI_PA_BYTE  = 0
    PPI_PB_BYTE  = 1
    PPI_PC_BYTE  = 2
    PPI_CTL_BYTE = 3

    PPI_PA_INPUT  = (PPI_CTL_BYTE * 8) + 4
    PPI_PCU_INPUT = (PPI_CTL_BYTE * 8) + 3
    PPI_PB_INPUT  = (PPI_CTL_BYTE * 8) + 1
    PPI_PCL_INPUT = (PPI_CTL_BYTE * 8) + 0

DAT             ' PIC 8259A
                orgh

pic_20_wr
                testb   i_tmpb, #4      wc
                testb   i_tmpb, #3      wz
        if_00   jmp     #.ocw2
        if_01   setbyte pic_ocw, i_tmpb, #PIC_OCW3_BYTE ' OCW3
        if_01   ret
                mov     pic_icw, #0     ' ICW1
                mov     pic_ocw, #0
                mov     pic_irq, #0
                setbyte pic_ocw, #%00001010, #PIC_OCW3_BYTE
                setnib  pic_irq, #7, #PIC_IR_NIB
                setbyte pic_icw, i_tmpb, #0
                ret     wcz

.ocw2
                testb   i_tmpb, #5      wz  ' EOI
        if_x1   getnib  i_temp0, pic_irq, #PIC_IR_NIB
        if_x1   add     i_temp0, #PIC_ISR_BYTE * 8
        if_x1   bitl    pic_irq, i_temp0
        if_x1   bitl    pic_irq, #PIC_IS_BIT
        if_x1   setnib  i_temp0, #7, #PIC_IR_NIB
                ret     wcz

pic_20_rd
                mov     i_tmpb, #0

                bitl    pic_ocw, #PIC_OCW3_POLL_BIT wcz
                testb   pic_ocw, #PIC_OCW3_RR_BIT   wz
        if_11   jmp     #.poll

                testb   pic_ocw, #PIC_OCW3_RR_BIT   wc
                testb   pic_ocw, #PIC_OCW3_RIS_BIT  wz
        if_10   getbyte i_tmpb, pic_irq, #PIC_IRR_BYTE
        if_11   getbyte i_tmpb, pic_irq, #PIC_ISR_BYTE
                ret     wcz

.poll
                call    #pic_intack
                getbyte i_tmpb, pic_irq, #PIC_POLL_BYTE
                ret     wcz

pic_21_wr
                bith    pic_ocw, #29    wcz
        if_0x   setbyte pic_icw, i_tmpb, #1 ' ICW2
        if_0x   ret     wcz

                bith    pic_ocw, #30    wcz
                testb   pic_icw, #1     wz
        if_00   setbyte pic_icw, i_tmpb, #2 ' ICW3
        if_01   setbyte pic_icw, i_tmpb, #3 ' ICW4
        if_01   bith    pic_ocw, #31
        if_0x   ret     wcz

                bith    pic_ocw, #31    wcz
        if_0x   setbyte pic_icw, i_tmpb, #3 ' ICW4
        if_0x   ret     wcz

                setbyte pic_ocw, i_tmpb, #0 ' OCW1 (IMR)
                'debug("PIC 21 (W): ", ubin_byte(i_tmpb),ubin_long(pic_ocw))
                ret     wcz

pic_21_rd
                getbyte i_tmpb, pic_ocw, #PIC_OCW1_BYTE ' OCW1 (IMR)
                ret     wcz

pic_intack
                testb   pic_ocw, #0    wc
                testb   pic_irq, #(PIC_ISR_BYTE * 8) + 0    wz
        if_01   setnib  pic_irq, #0, #PIC_IR_NIB
        if_01   bith    pic_irq, #PIC_IS_BIT
        if_01   ret

                testb   pic_ocw, #1    wc
                testb   pic_irq, #(PIC_ISR_BYTE * 8) + 1    wz
        if_01   setnib  pic_irq, #1, #PIC_IR_NIB
        if_01   bith    pic_irq, #PIC_IS_BIT
        if_01   ret

                testb   pic_ocw, #2    wc
                testb   pic_irq, #(PIC_ISR_BYTE * 8) + 2    wz
        if_01   setnib  pic_irq, #2, #PIC_IR_NIB
        if_01   bith    pic_irq, #PIC_IS_BIT
        if_01   ret

                testb   pic_ocw, #3    wc
                testb   pic_irq, #(PIC_ISR_BYTE * 8) + 3    wz
        if_01   setnib  pic_irq, #3, #PIC_IR_NIB
        if_01   bith    pic_irq, #PIC_IS_BIT
        if_01   ret

                testb   pic_ocw, #4    wc
                testb   pic_irq, #(PIC_ISR_BYTE * 8) + 4    wz
        if_01   setnib  pic_irq, #4, #PIC_IR_NIB
        if_01   bith    pic_irq, #PIC_IS_BIT
        if_01   ret

                testb   pic_ocw, #5    wc
                testb   pic_irq, #(PIC_ISR_BYTE * 8) + 5    wz
        if_01   setnib  pic_irq, #5, #PIC_IR_NIB
        if_01   bith    pic_irq, #PIC_IS_BIT
        if_01   ret

                testb   pic_ocw, #6    wc
                testb   pic_irq, #(PIC_ISR_BYTE * 8) + 6    wz
        if_01   setnib  pic_irq, #6, #PIC_IR_NIB
        if_01   bith    pic_irq, #PIC_IS_BIT
        if_01   ret

                testb   pic_ocw, #7    wc
                testb   pic_irq, #(PIC_ISR_BYTE * 8) + 7    wz
                setnib  pic_irq, #7, #PIC_IR_NIB
        if_01   bith    pic_irq, #PIC_IS_BIT

                ret

CON ' PIC 8259A Constants

    ' pic_icw
    PIC_ICW1_BYTE = 0
    PIC_ICW2_BYTE = 1
    PIC_ICW3_BYTE = 2
    PIC_ICW4_BYTE = 3

    ' pic_ocw
    PIC_OCW1_BYTE = 0
    PIC_OCW2_BYTE = 1
    PIC_OCW3_BYTE = 2

    PIC_OCW3_POLL_BIT = (PIC_OCW3_BYTE * 8) + 2
    PIC_OCW3_RR_BIT   = (PIC_OCW3_BYTE * 8) + 1
    PIC_OCW3_RIS_BIT  = (PIC_OCW3_BYTE * 8) + 0

    PIC_ICW2_BIT  = 29
    PIC_ICW3_BIT  = 30
    PIC_ICW4_BIT  = 31

    ' pic_irq
    PIC_IRR_BYTE  = 0
    PIC_ISR_BYTE  = 1
    PIC_POLL_BYTE = 3
    PIC_IS_BIT    = 31
    PIC_IR_NIB    = 6

DAT             ' PIT 8254
                orgh

pit_40_wr
                'debug("PIT  (W) : ", uhex_long(i_cs,i_ip,i_ea),uhex_byte(i_tmpb),dly(#500))
                rdword  i_temp0, #@tmr0
                testb   i_temp0, #5         wc
                testb   i_temp0, #4         wz
        if_01   jmp     #.ctl_01 ' write counter bits 0-7 only
        if_10   jmp     #.ctl_10 ' write counter bits 8-15 only
        if_11   jmp     #.ctl_11 ' write counter bits 0-7 first, then 8-15
                ret     wcz
.ctl_01
                wrword  i_tmpb, #@tmr0_reload
                'bitl    i_temp0, #TMR_OUT
                bitl    i_temp0, #TMR_NULL
                bith    i_temp0, #TMR_RELOAD    ' signal reload counter
                wrword  i_temp0, #@tmr0
                ret     wcz
.ctl_10
                shl     i_tmpb, #8
                wrword  i_tmpb, #@tmr0_reload
                'bitl    i_temp0, #TMR_OUT
                bitl    i_temp0, #TMR_NULL
                bith    i_temp0, #TMR_RELOAD    ' signal reload counter
                wrword  i_temp0, #@tmr0
                ret     wcz
.ctl_11
                bitnot  i_temp0, #TMR_HL   wcz
                rdword  i_temp1, #@tmr0_reload
        if_0x   setbyte i_temp1, i_tmpb, #0
        if_1x   setbyte i_temp1, i_tmpb, #1
                wrword  i_temp1, #@tmr0_reload

                'bitl    i_temp0, #TMR_OUT
                bitl    i_temp0, #TMR_NULL
                bith    i_temp0, #TMR_RELOAD    ' signal reload counter
                wrword  i_temp0, #@tmr0
                ret     wcz

pit_40_rd
                rdword  i_temp0, #@tmr0
                testb   i_temp0, #5             wc
                testb   i_temp0, #4             wz
        if_01   jmp     #.ctl_01 ' read counter bits 0-7 only
        if_10   jmp     #.ctl_10 ' read counter bits 8-15 only
        if_11   jmp     #.ctl_11 ' read counter bits 0-7 first, then 8-15
                ret     wcz
.ctl_01
                bitl    i_temp0, #TMR_LATCH     wcz
        if_x0   rdword  i_temp1, #@tmr0_cnt
        if_x1   rdword  i_temp1, #@tmr0_latch
                getbyte i_tmpb, i_temp1, #0
                wrword  i_temp0, #@tmr0
                'debug("PIT  (R) : ", uhex_long(i_cs,i_ip,i_ea),uhex_byte(i_tmpb), dly(#200))
                ret     wcz
.ctl_10
                bitl    i_temp0, #TMR_LATCH     wcz
        if_x0   rdword  i_temp1, #@tmr0_cnt
        if_x1   rdword  i_temp1, #@tmr0_latch
                getbyte i_tmpb, i_temp1, #1
                wrword  i_temp0, #@tmr0
                ret     wcz
.ctl_11
                bitnot  i_temp0, #TMR_HL        wcz
                testb   i_temp0, #TMR_LATCH     wz
        if_x0   rdword  i_temp1, #@tmr0_cnt
        if_x1   rdword  i_temp1, #@tmr0_latch

        if_0x   getbyte i_tmpb, i_temp1, #0
        if_1x   getbyte i_tmpb, i_temp1, #1
        if_11   bitl    i_temp0, #TMR_LATCH
                wrword  i_temp0, #@tmr0

                ret     wcz

pit_41_wr
                'debug("PIT  (W) : ", uhex_long(i_cs,i_ip,i_ea),uhex_byte(i_tmpb),dly(#500))
                rdword  i_temp0, #@tmr1
                testb   i_temp0, #5         wc
                testb   i_temp0, #4         wz
        if_01   jmp     #.ctl_01 ' write counter bits 0-7 only
        if_10   jmp     #.ctl_10 ' write counter bits 8-15 only
        if_11   jmp     #.ctl_11 ' write counter bits 0-7 first, then 8-15
                ret     wcz
.ctl_01
                wrword  i_tmpb, #@tmr1_reload
                'bitl    i_temp0, #TMR_OUT
                bitl    i_temp0, #TMR_NULL
                bith    i_temp0, #TMR_RELOAD    ' signal reload counter
                wrword  i_temp0, #@tmr1
                ret     wcz
.ctl_10
                shl     i_tmpb, #8
                wrword  i_tmpb, #@tmr1_reload
                'bitl    i_temp0, #TMR_OUT
                bitl    i_temp0, #TMR_NULL
                bith    i_temp0, #TMR_RELOAD    ' signal reload counter
                wrword  i_temp0, #@tmr1
                ret     wcz
.ctl_11
                bitnot  i_temp0, #TMR_HL   wcz
                rdword  i_temp1, #@tmr1_reload
        if_0x   setbyte i_temp1, i_tmpb, #0
        if_1x   setbyte i_temp1, i_tmpb, #1
                wrword  i_temp1, #@tmr1_reload

                'bitl    i_temp0, #TMR_OUT
                bitl    i_temp0, #TMR_NULL
                bith    i_temp0, #TMR_RELOAD    ' signal reload counter
                wrword  i_temp0, #@tmr1
                ret     wcz

pit_41_rd
                rdword  i_temp0, #@tmr1
                testb   i_temp0, #5             wc
                testb   i_temp0, #4             wz
        if_01   jmp     #.ctl_01 ' read counter bits 0-7 only
        if_10   jmp     #.ctl_10 ' read counter bits 8-15 only
        if_11   jmp     #.ctl_11 ' read counter bits 0-7 first, then 8-15
                ret     wcz
.ctl_01
                bitl    i_temp0, #TMR_LATCH     wcz
        if_x0   rdword  i_temp1, #@tmr1_cnt
        if_x1   rdword  i_temp1, #@tmr1_latch
                getbyte i_tmpb, i_temp1, #0
                wrword  i_temp0, #@tmr1
                'debug("PIT  (R) : ", uhex_long(i_cs,i_ip,i_ea),uhex_byte(i_tmpb), dly(#200))
                ret     wcz
.ctl_10
                bitl    i_temp0, #TMR_LATCH     wcz
        if_x0   rdword  i_temp1, #@tmr1_cnt
        if_x1   rdword  i_temp1, #@tmr1_latch
                getbyte i_tmpb, i_temp1, #1
                wrword  i_temp0, #@tmr1
                ret     wcz
.ctl_11
                bitnot  i_temp0, #TMR_HL        wcz
                testb   i_temp0, #TMR_LATCH     wz
        if_x0   rdword  i_temp1, #@tmr1_cnt
        if_x1   rdword  i_temp1, #@tmr1_latch

        if_0x   getbyte i_tmpb, i_temp1, #0
        if_1x   getbyte i_tmpb, i_temp1, #1
        if_11   bitl    i_temp0, #TMR_LATCH
                wrword  i_temp0, #@tmr1

                ret     wcz

pit_43_wr
                'debug("PIT  (W) : ", uhex_long(i_cs,i_ip,i_ea),uhex_byte(i_tmpb),dly(#500))
                testb   i_tmpb, #5          wc
                testb   i_tmpb, #4          wz
        if_00   jmp     #.latch

                testb   i_tmpb, #7          wc
                testb   i_tmpb, #6          wz

        if_00   rdword  i_temp0, #@tmr0
        if_00   setbyte i_temp0, i_tmpb, #0
        if_00   bith    i_temp0, #TMR_NULL
        if_00   wrword  i_temp0, #@tmr0

        if_01   rdword  i_temp0, #@tmr1
        if_01   setbyte i_temp0, i_tmpb, #0
        if_01   bith    i_temp0, #TMR_NULL
        if_01   wrword  i_temp0, #@tmr1

        if_10   rdword  i_temp0, #@tmr2
        if_10   setbyte i_temp0, i_tmpb, #0
        if_10   bith    i_temp0, #TMR_NULL
        if_10   wrword  i_temp0, #@tmr2
                ret     wcz
.latch
                testb   i_tmpb, #7          wc
                testb   i_tmpb, #6          wz

        if_00   rdword  i_temp0, #@tmr0_cnt
        if_00   wrword  i_temp0, #@tmr0_latch
        if_00   rdword  i_temp0, #@tmr0
        if_00   bith    i_temp0, #TMR_LATCH
        if_00   wrword  i_temp0, #@tmr0

        if_01   rdword  i_temp0, #@tmr1_cnt
        if_01   wrword  i_temp0, #@tmr1_latch
        if_01   rdword  i_temp0, #@tmr1
        if_01   bith    i_temp0, #TMR_LATCH
        if_01   wrword  i_temp0, #@tmr1

        if_10   rdword  i_temp0, #@tmr2_cnt
        if_10   wrword  i_temp0, #@tmr2_latch
        if_10   rdword  i_temp0, #@tmr2
        if_10   bith    i_temp0, #TMR_LATCH
        if_10   wrword  i_temp0, #@tmr2
                ret     wcz

DAT
                org     $000

pit_cog
                mov     ijmp1, ##@pit_tick
                getct   pit_ct
                addct1  pit_ct, #_CLKFREQ / 1_193_180
                setint1 #EVENT_CT1

.loop
                jmp     #.loop

{
                getct   pit_ct
                addct1  pit_ct, #_CLKFREQ / 1_193_180
.loop
                pollct1             wc
        if_nc   jmp     #.loop

.lw1            locktry #0                          wc
        if_nc   jmp     #.lw1
                call    #pit_tick
                lockrel #0

                addct1  pit_ct, #_CLKFREQ / 1_193_180
                jmp     #.loop
}

pit_tick
                addct1  pit_ct, #_CLKFREQ / 1_193_180

'                testb   pit_tmr0, #TMR_GATE     wc
'                testb   pit_tmr0, #TMR_NULL     wz
'   if_nc_or_z   jmp     #pit_tick1

                rdword  pit_tmr0, #@tmr0
                'debug("pit_tick : ", ubin_word(pit_tmr), dly(#500))
                testb   pit_tmr0, #TMR_NULL      wz
        if_x1   jmp     #pit_tick1

                bitl    pit_tmr0, #TMR_RELOAD    wcz
        if_x0   jmp     #.l1
                rdword  pit_temp0, #@tmr0_reload
                wrword  pit_temp0, #@tmr0_cnt
                wrword  pit_tmr0, #@tmr0
                jmp     #pit_tick1

.l1
                getbyte pit_temp0, pit_tmr0, #0
                and     pit_temp0, #%0000_111_0 wz
        if_z    jmp     #.mode0
                cmp     pit_temp0, #%0000_010_0 wz
        if_ne   cmp     pit_temp0, #%0000_110_0 wz
        if_e    jmp     #.mode2
                cmp     pit_temp0, #%0000_011_0 wz
        if_ne   cmp     pit_temp0, #%0000_111_0 wz
        if_e    jmp     #.mode3
                cmp     pit_temp0, #%0000_101_0 wz
                jmp     #pit_tick1

.mode0
                rdword  pit_temp0, #@tmr0_cnt
                sub     pit_temp0, #1           wcz
                wrword  pit_temp0, #@tmr0_cnt
        if_nz   jmp     #pit_tick1

                rdbyte  pit_temp0, #@irq
                bith    pit_temp0, #0
                wrbyte  pit_temp0, #@irq

                jmp     #pit_tick1
.mode2
.mode3
                rdword  pit_temp0, #@tmr0_cnt
                sub     pit_temp0, #1           wcz
                wrword  pit_temp0, #@tmr0_cnt
        if_nz   jmp     #pit_tick1
                bith    pit_tmr0, #TMR_RELOAD
                wrword  pit_tmr0, #@tmr0

                rdbyte  pit_temp0, #@irq
                bith    pit_temp0, #0
                wrbyte  pit_temp0, #@irq

                jmp     #pit_tick1

pit_tick1
'                testb   pit_tmr1, #TMR_GATE     wc
'                testb   pit_tmr1, #TMR_NULL     wz
'   if_nc_or_z   jmp     #pit_tick_end

                rdword  pit_tmr1, #@tmr1
                'debug("*** pit_tick1 *** ", ubin_word(pit_tmr),dly(#200))
                testb   pit_tmr1, #TMR_NULL      wz
        if_x1   jmp     #pit_tick2

                bitl    pit_tmr1, #TMR_RELOAD    wcz
        if_x0   jmp     #.l1
                rdword  pit_temp0, #@tmr1_reload
                wrword  pit_temp0, #@tmr1_cnt
                wrword  pit_tmr1, #@tmr1
                jmp     #pit_tick2

.l1             getbyte pit_temp0, pit_tmr1, #0
                and     pit_temp0, #%0000_111_0 wz
        if_z    jmp     #.mode0
                cmp     pit_temp0, #%0000_010_0 wz
        if_ne   cmp     pit_temp0, #%0000_110_0 wz
        if_e    jmp     #.mode2
                cmp     pit_temp0, #%0000_011_0 wz
        if_ne   cmp     pit_temp0, #%0000_111_0 wz
        if_e    jmp     #.mode3
                cmp     pit_temp0, #%0000_101_0 wz
                jmp     #pit_tick2

.mode0
                rdword  pit_temp0, #@tmr1_cnt
                sub     pit_temp0, #1           wcz
                wrword  pit_temp0, #@tmr1_cnt
                'debug("*** pit_tick1.mode0 *** ", ubin_word(pit_temp0),dly(#200))
                jmp     #pit_tick2
.mode2
.mode3
                rdword  pit_temp0, #@tmr1_cnt
                sub     pit_temp0, #1           wcz
                wrword  pit_temp0, #@tmr1_cnt
                'debug("*** pit_tick1.mode0 *** ", ubin_word(pit_temp0),dly(#200))
        if_nz   jmp     #pit_tick2
                bith    pit_tmr1, #TMR_RELOAD
                wrword  pit_tmr1, #@tmr1
                'debug("DMA TMR0 : ", ubin_long(dma_ctl),dly(#500))

                ' DMA
                rdlong  pit_dma_ctl, #@dma_ctl
                testb   pit_dma_ctl, #8 + 2     wz  ' controller enable
        if_x1   jmp     #pit_tick2
                testb   pit_dma_ctl, #16 + 0    wz  ' ch0 mask
        if_x1   jmp     #pit_tick2
                bitl    pit_dma_ctl, #4 + 0     wcz ' ch0 request
        'if_x0   jmp     #pit_tick_end

                rdlong  pit_dma_mode, #@dma_mode
                testb   pit_dma_mode, #4        wz  ' auto init
        if_x0   jmp     #pit_tick2

                rdword  pit_temp0, #@dma            ' ch0 address
                incmod  pit_temp0, i_ffffh
                wrword  pit_temp0, #@dma
                rdword  pit_temp0, #@dma + 2        ' ch0 counter
                sub     pit_temp0, #1           wz
                wrword  pit_temp0, #@dma + 2
        if_z    bith    pit_dma_ctl, #0             ' signal ch0 end

                wrlong  pit_dma_ctl, #@dma_ctl

                jmp     #pit_tick2

pit_tick2
pit_tick_end
                reti1

pit_ct          res     1
pit_tmr0        res     1
pit_tmr1        res     1
pit_tmr2        res     1

pit_temp0       res     1
pit_temp1       res     1
pit_temp2       res     1

pit_dma_ctl     res     1
pit_dma_mode    res     1

                fit     $1F0

CON ' PIT 8254 Constants

    TMR_HL     =  8
    TMR_RELOAD =  9
    TMR_NULL   = 10
    TMR_LATCH  = 13
    TMR_GATE   = 14
    TMR_OUT    = 15

DAT             ' DMA 8237A
                orgh

dma_rd
                rdlong  i_temp0, #@dma_ctl

                cmp     i_ea, #$07      wcz
        if_be   jmp     #dma_addr_rd
                cmp     i_ea, #$08      wcz ' read status register
        if_e    getbyte i_tmpb, i_temp0, #0
                ret     wcz

dma_addr_rd
                bitnot  i_temp0, #31    wcz
                wrlong  i_temp0, #@dma_ctl

                mov     i_temp2, i_ea
                rcl     i_temp2, #1
                add     i_temp2, #@dma
                rdbyte  i_tmpb, i_temp2

                ret     wcz

dma_wr
                rdlong  i_temp0, #@dma_ctl

                cmp     i_ea, #$07      wcz
        if_be   jmp     #dma_addr_wr
                cmp     i_ea, #$09      wcz ' write request register
        if_e    jmp     #dma_request_wr
                cmp     i_ea, #$0A      wcz ' write single mask register
        if_e    jmp     #dma_mask_wr
                cmp     i_ea, #$0B      wcz ' write mode register
        if_e    jmp     #dma_mode_wr
                cmp     i_ea, #$0D      wcz ' master clear
        if_e    jmp     #dma_clear_wr
                cmp     i_ea, #$0F      wcz ' write all mask register
        if_e    jmp     #dma_allmask_wr

                cmp     i_ea, #$08      wcz ' write command register
        if_e    setbyte i_temp0, i_tmpb, #1
                cmp     i_ea, #$0C      wcz ' clear byte pointer flip-flop
        if_e    bitl    i_temp0, #31
                cmp     i_ea, #$0E      wcz ' clear mask register
        if_e    setnib  i_temp0, #0, #4
                wrlong  i_temp0, #@dma_ctl
                ret     wcz

dma_addr_wr
                bitnot  i_temp0, #31    wcz
                wrlong  i_temp0, #@dma_ctl

                mov     i_temp2, i_ea
                rcl     i_temp2, #1
                add     i_temp2, #@dma
                wrbyte  i_tmpb, i_temp2

                ret     wcz

dma_request_wr
                testb   i_tmpb, #1      wc
                testb   i_tmpb, #0      wz
        if_00   mov     i_temp2, #%0001_0000
        if_00   bitl    i_temp0, #0
        if_01   mov     i_temp2, #%0010_0000
        if_01   bitl    i_temp0, #1
        if_10   mov     i_temp2, #%0100_0000
        if_10   bitl    i_temp0, #2
        if_11   mov     i_temp2, #%1000_0000
        if_11   bitl    i_temp0, #3
                testb   i_tmpb, #2      wz
                muxz    i_temp0, i_temp2
                wrlong  i_temp0, #@dma_ctl
                ret     wcz

dma_mask_wr
                testb   i_tmpb, #1      wc
                testb   i_tmpb, #0      wz
        if_00   mov     i_temp2, #%0001
        if_01   mov     i_temp2, #%0010
        if_10   mov     i_temp2, #%0100
        if_11   mov     i_temp2, #%1000
                shl     i_temp2, #16
                testb   i_tmpb, #2      wz
                muxz    i_temp0, i_temp2
                wrlong  i_temp0, #@dma_ctl
                ret     wcz

dma_allmask_wr
                setnib  i_temp0, i_tmpb, #4
                wrlong  i_temp0, #@dma_ctl
                ret     wcz

dma_mode_wr
                testb   i_tmpb, #1      wc
                testb   i_tmpb, #0      wz
                rdlong  i_temp1, #@dma_mode
        if_00   setbyte i_temp1, i_tmpb, #0
        if_01   setbyte i_temp1, i_tmpb, #1
        if_10   setbyte i_temp1, i_tmpb, #2
        if_11   setbyte i_temp1, i_tmpb, #3
                wrlong  i_temp1, #@dma_mode
                ret     wcz

dma_clear_wr
                wrlong  ##%0_00000000000_1111_00000100_00000000, #@dma_ctl
                wrlong  #0, #@dma
                wrlong  #0, #@dma + 4
                ret     wcz

DAT             ' ROM and RAM
                orgh

cga_charrom     file    "CGA.F08"

rom_FE000       file    "BIOS.ROM"

ram_00000
                ' space used as
CON

                RAM_SIZE = $4_0000  ' 256K RAM
                CGA_VRAM = $0_4000  ' 16K CGA video ram
